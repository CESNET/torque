/*
*         OpenPBS (Portable Batch System) v2.3 Software License
*
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
*
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
*
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
*
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
*
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
*
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
*
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
*
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
*
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
*
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
*
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
*
* 7. DISCLAIMER OF WARRANTY
*
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
*
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/

#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <string.h>
#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <netdb.h>
#include <sys/types.h>
#include <netinet/in.h>
#include <stdarg.h>
#include <assert.h>
#if defined(NTOHL_NEEDS_ARPA_INET_H) && defined(HAVE_ARPA_INET_H)
#include <arpa/inet.h>
#endif


#include "portability.h"
#include "libpbs.h"
#include "server_limits.h"
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "server.h"
#include "net_connect.h"
#include "batch_request.h"
#include "work_task.h"
#include "svrfunc.h"
#include "pbs_job.h"
#include "log.h"
#include "pbs_nodes.h"
#include "rpp.h"
#include "dis.h"
#include "dis_init.h"
#include "resmon.h"
#include "mcom.h"
#include "utils.h"
#include "cloud.h"
#include "api.h"

#include "assertions.h"
#include "nodespec.h"

#define IS_VALID_STR(STR)  (((STR) != NULL) && ((STR)[0] != '\0'))

extern void DIS_rpp_reset A_((void));

extern int LOGLEVEL;

#if !defined(H_ERRNO_DECLARED)
extern int h_errno;
#endif

int    svr_totnodes = 0; /* total number nodes defined       */
int   svr_clnodes  = 0; /* number of cluster nodes     */
int   svr_tsnodes  = 0; /* number of time shared nodes     */
int   svr_chngNodesfile = 0; /* 1 signals want nodes file update */
/* on server shutdown, (qmgr mods)  */

struct pbsnode **pbsndlist = NULL;

struct pbsnode **pbsndmast = NULL;
static int  svr_numnodes = 0; /* number of nodes currently available (global!!! - set in node_spec) */
static int       svr_numcfgnodes = 0;   /* number of nodes currently configured (global!!! - set in node_spec) */
static int  exclusive;  /* node allocation type */

static FILE  *nstatef = NULL;
static int       num_addrnote_tasks = 0; /* number of outstanding send_cluster_addrs tasks */

extern int  server_init_type;
extern int  has_nodes;

extern time_t    time_now;

extern int ctnodes A_((char *));
extern char *path_home;
extern char *path_nodes;
extern char *path_nodes_new;
extern char *path_nodestate;
extern char *path_nodenote;
extern char *path_nodenote_new;
extern unsigned int pbs_mom_port;
extern char  server_name[];

extern struct server server;
extern tlist_head svr_newnodes;
extern attribute_def  node_attr_def[];   /* node attributes defs */
extern int            SvrNodeCt;

#define SKIP_NONE 0
#define SKIP_EXCLUSIVE 1
#define SKIP_ANYINUSE 2
#define SKIP_NONE_REUSE 3

#ifndef MAX_BM
#define MAX_BM   64
#endif

int hasprop(struct pbsnode *, struct prop *, int proc_count);
int hasadprop(struct pbsnode *, struct prop *);
void send_cluster_addrs(struct work_task *);
int add_cluster_addrs(int);
int is_compose(int, int);
int add_job_to_node(struct pbsnode *,struct pbssubn *,short,job *,int,int);
int node_satisfies_request(struct pbsnode *,char *);
int reserve_node(struct pbsnode *,short,job *,char *,struct howl **);
int build_host_list(struct howl **,struct pbssubn *,struct pbsnode *);
void adjust_resources_use(struct pbsnode *pnode, struct jobinfo *jp, int,
       enum batch_op op);

/*

 GBS - I put this in since it's used in the server to mom
 communication for resource manager information.  The server
 opens rpp sockets for pinging.  I just used those for the
 resource manager queries.

*/

static void
funcs_dis(void)  /* The equivalent of DIS_tcp_funcs() */

  {
  if (dis_getc != rpp_getc)
    {
    dis_getc = (int (*)(int))rpp_getc;
    dis_puts = (int (*)(int, const char *, size_t))rpp_write;
    dis_gets = (int (*)(int, char *, size_t))rpp_read;
    disr_commit = (int (*)(int, int))rpp_rcommit;
    disw_commit = (int (*)(int, int))rpp_wcommit;
    }

  return;
  }

/*#define      setup_dis(x)    funcs_dis()  */    /* RPP doesn't need reset */
/*#define      close_dis(x)    rpp_close(x) */
/*#define      flush_dis(x)    rpp_flush(x) */

/**
**      Modified by Tom Proett <proett@nas.nasa.gov> for PBS.
*/

tree *ipaddrs = NULL; /* tree of ip addrs */
tree *streams = NULL; /* tree of stream numbers */


/**
 * specialized version of tfind for looking in the ipadders tree
 * @param key - the node we are searching for
 * @return a pointer to the pbsnode
*/

struct pbsnode *tfind_addr(

        const u_long key)

  {
  return tfind(key, &ipaddrs);
  }



/* update_node_state - central location for updating node state */
/* NOTE:  called each time a node is marked down, each time a MOM reports node  */
/*        status, and when pbs_server sends hello/cluster_addrs */

void update_node_state(

  struct pbsnode *np,         /* I (modified) */
  int             newstate)   /* I (one of INUSE_*) */

  {
  char *id = "update_node_state";

  struct pbssubn *sp;
#ifdef ALT_CLSTR_ADDR
  int ret;
  int send_addrs = FALSE;
#endif

  /*
   * LOGLEVEL >= 4 logs all state changes
   *          >= 2 logs down->(busy|free) changes
   *          (busy|free)->down changes are always logged
   */

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer, "adjusting state for node %s - state=%d, newstate=%d",
            (np->nd_name != NULL) ? np->nd_name : "NULL",
            np->nd_state,
            newstate);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

  log_buffer[0] = '\0';

#ifdef ALT_CLSTR_ADDR
  /*
   *  If coming out of DOWN or UNKNOWN states
   *  then we want to send IS_CLUSTER_ADDRS message
   */

  if ((np->nd_state & INUSE_DOWN) ||
      (np->nd_state & INUSE_UNKNOWN))
    {
    if (!(newstate & INUSE_DOWN))
      {
      send_addrs = TRUE;
      }
    }

#endif

  if (newstate & INUSE_DOWN)
    {
    if (!(np->nd_state & INUSE_DOWN))
      {
      sprintf(log_buffer, "node %s marked down",
              (np->nd_name != NULL) ? np->nd_name : "NULL");

      np->nd_state |= INUSE_DOWN;
      np->nd_state &= ~INUSE_UNKNOWN;

      /* mark all subnodes down */

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        sp->inuse |= INUSE_DOWN;
        }
      }

    /* ignoring the obvious possibility of a "down,busy" node */
    }  /* END if (newstate & INUSE_DOWN) */
  else if (newstate & INUSE_BUSY)
    {
    if ((!(np->nd_state & INUSE_BUSY) && (LOGLEVEL >= 4)) ||
        ((np->nd_state & INUSE_DOWN) && (LOGLEVEL >= 2)))
      {
      sprintf(log_buffer, "node %s marked busy",
              (np->nd_name != NULL) ? np->nd_name : "NULL");
      }

    np->nd_state |= INUSE_BUSY;

    np->nd_state &= ~INUSE_UNKNOWN;

    if (np->nd_state & INUSE_DOWN)
      {
      np->nd_state &= ~INUSE_DOWN;

      /* clear down on all subnodes */

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        sp->inuse &= ~INUSE_DOWN;
        }
      }
    }  /* END else if (newstate & INUSE_BUSY) */
  else if (newstate == INUSE_FREE)
    {
    if (((np->nd_state & INUSE_DOWN) && (LOGLEVEL >= 2)) ||
        ((np->nd_state & INUSE_BUSY) && (LOGLEVEL >= 4)))
      {
      sprintf(log_buffer, "node %s marked free",
              (np->nd_name != NULL) ? np->nd_name : "NULL");
      }

    np->nd_state &= ~INUSE_BUSY;

    np->nd_state &= ~INUSE_UNKNOWN;

    np->nd_state &= ~INUSE_FROZEN;

#ifdef BROKENVNODECHECKS

    if ((np->nd_state & INUSE_JOB) ||
        (np->nd_state & INUSE_JOBSHARE) ||
        (np->nd_nsn != np->nd_nsnfree))
      {
      int snjcount;   /* total number of jobs assigned to nodes */
      int snjacount;  /* number of subnodes with job array associated with them */

      int nsn_free;
      int SNIsAllocated;  /* boolean */

      struct jobinfo *jp;

      struct jobinfo *jpprev;

      char   tmpLine[1024];

      /* count jobs on all subnodes */

      snjcount = 0;
      snjacount = 0;

      /* initially set free subnode count to config subnode count */

      nsn_free = np->nd_nsn;

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        if (sp->jobs != NULL)
          {
          SNIsAllocated = 0;  /* mark subnode allocated only after job detected */

          snjacount++;

          sp->inuse &= ~(INUSE_JOB | INUSE_JOBSHARE);

          /* look for and remove duplicate job entries in subnode job list */

          jpprev = NULL;

          for (jp = sp->jobs;jp != NULL;jp = jp->next)
            {
            if (jp->job != NULL)
              {
              if ((jp->job->ji_qs.ji_state != JOB_STATE_RUNNING) ||
                  (jp->job->ji_qs.ji_substate == JOB_SUBSTATE_SUSPEND) ||
                  (jp->job->ji_wattr[JOB_ATR_state].at_val.at_char == 'S'))
                {
                /* only count suspended and running jobs */

                continue;
                }

              snjcount++;

              if (SNIsAllocated == 0)
                {
                SNIsAllocated = 1;

                nsn_free--;
                }
              }

            if ((jpprev != NULL) && (jpprev->job == jp->job))
              {
              /* duplicate job entry detected */

              sprintf(tmpLine, "ALERT:  duplicate entry for job '%s' detected on node %s (clearing entry)",
                      (jp->job != NULL) ? jp->job->ji_qs.ji_jobid : "???",
                      np->nd_name);

              log_record(
                PBSEVENT_SCHED,
                PBS_EVENTCLASS_REQUEST,
                id,
                tmpLine);

              jpprev->next = jp->next;

              free(jp);

              break;
              }

            jpprev = jp;
            }  /* END for (jp) */
          }    /* END if (sp->jobs != NULL) */
        }      /* END for (sp) */

      if (snjcount == 0)
        {
        /* node has no jobs but is in allocated state - free subnodes */

        np->nd_nsnfree = np->nd_nsn;

        sprintf(log_buffer, "job allocation released on node %s - node marked free",
                (np->nd_name != NULL) ? np->nd_name : "NULL");

        if (snjacount > 0)
          {
          strcat(log_buffer, " - subnode job array is corrupt");
          }

        np->nd_state &= ~(INUSE_JOB | INUSE_JOBSHARE);
        }
      else
        {
        if (np->nd_nsnfree != nsn_free)
          {
          sprintf(log_buffer, "subnode allocation adjusted on node %s (%d -> %d)",
                  (np->nd_name != NULL) ? np->nd_name : "NULL",
                  np->nd_nsnfree,
                  nsn_free);

          np->nd_nsnfree = nsn_free;

          /* what is the exact meaning of JOBSHARE? */

          np->nd_state &= ~INUSE_JOBSHARE;
          }
        else
          {
          /* subnode availability values are correct */

          if (LOGLEVEL >= 7)
            {
            sprintf(log_buffer, "subnode allocation correct on node %s (%d free, %d configured)",
                    (np->nd_name != NULL) ? np->nd_name : "NULL",
                    np->nd_nsnfree,
                    np->nd_nsn);
            }
          }

        if (np->nd_nsnfree > 0)
          {
          /* if any sub-nodes are free, job cannot be in job-exclusive */

          np->nd_state &= ~INUSE_JOB;

          if (LOGLEVEL >= 3)
            {
            if (log_buffer[0] == '\0')
              sprintf(log_buffer, "unset job-exclusive state for node %s in state %d (%d free, %d configured)",
                      (np->nd_name != NULL) ? np->nd_name : "NULL",
                      np->nd_state,
                      np->nd_nsnfree,
                      np->nd_nsn);
            else
              strcat(log_buffer, "(unset job-exclusive state)");
            }
          }
        }    /* END else (snjcount == 0) */
      }      /* END if ((np->nd_state & INUSE_JOB) || ...) */
    else
      {
      /* skipping subnode allocation check */

      if (LOGLEVEL >= 7)
        {
        sprintf(log_buffer, "skipping subnode allocation test for node %s in state %d (%d free, %d configured)\n",
                (np->nd_name != NULL) ? np->nd_name : "NULL",
                np->nd_state,
                np->nd_nsnfree,
                np->nd_nsn);
        }
      }

#endif /* BROKENVNODECHECKS */

    if (np->nd_state & INUSE_DOWN)
      {
      np->nd_state &= ~INUSE_DOWN;

      /* clear down on all subnodes */

      for (sp = np->nd_psn;sp != NULL;sp = sp->next)
        {
        sp->inuse &= ~INUSE_DOWN;
        }
      }
    }    /* END else if (newstate == INUSE_FREE) */

  if (newstate & INUSE_UNKNOWN)
    {
    np->nd_state |= INUSE_UNKNOWN;
    }

  if ((LOGLEVEL >= 2) && (log_buffer[0] != '\0'))
    {
    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

#ifdef ALT_CLSTR_ADDR
  if (send_addrs)
    {
    /* send the cluster addrs */

    ret = is_compose(np->nd_stream, IS_CLUSTER_ADDRS);

    if (ret == DIS_SUCCESS)
      {
      ret = add_cluster_addrs(np->nd_stream);
      }

    if (ret == DIS_SUCCESS)
      {
      ret = rpp_flush(np->nd_stream);
      }

    if ((ret == DIS_SUCCESS) && (LOGLEVEL >= 3))
      {
      sprintf(log_buffer, "sent cluster-addrs to node %s\n",
              np->nd_name);

      log_record(PBSEVENT_SYSTEM, PBS_EVENTCLASS_SERVER, id, log_buffer);
      }

    if (ret != DIS_SUCCESS)
      {
      /* a DIS write error has occurred */

      if (LOGLEVEL >= 1)
        {
        DBPRT(("%s: error processing node %s\n",
               id,
               np->nd_name))
        }

      sprintf(log_buffer, "%s %d to %s",

              dis_emsg[ret],
              errno,
              np->nd_name);

      log_err(-1, id, log_buffer);

      rpp_close(np->nd_stream);

      update_node_state(np, INUSE_DOWN);
      }
    } /* END send_addrs */

#endif

  return;
  }  /* END update_node_state() */





/*
 * find_job_by_node - return a job structure by looking for a jobid in a
 * specific node struct
 *
 * probably only useful as a test to see if a job exists on a given node
 * and it's much faster than find_job()
 */

job *find_job_by_node(

  struct pbsnode *pnode, /* I */
  char           *jobid) /* I */

  {

  struct pbssubn *np;

  struct jobinfo *jp;

  struct job     *pjob = NULL;

  char *at;

  if ((at = strchr(jobid, (int)'@')) != NULL)
    * at = '\0'; /* strip off @server_name */

  /* for each subnode on node ... */

  for (np = pnode->nd_psn;np != NULL;np = np->next)
    {
    /* for each jobinfo on subnode on node ... */

    for (jp = np->jobs;jp != NULL;jp = jp->next)
      {
      if ((jp->job != NULL) &&
          (jp->job->ji_qs.ji_jobid != NULL) &&
          (strcmp(jobid, jp->job->ji_qs.ji_jobid) == 0))
        {
        /* desired job located on node */

        pjob = jp->job;

        break;
        }
      }
    }    /* END for (np) */

  if (at != NULL)
    *at = '@';  /* restore @server_name */

  return(pjob);
  }  /* END find_job_by_node() */




/*
 * sync_node_jobs() - determine if a MOM has a stale job and possibly delete it
 *
 * This function is called every time we get a node stat from the pbs_mom.
 *
 * @see is_stat_get()
 */

void sync_node_jobs(

  struct pbsnode *np,            /* I */
  char           *jobstring_in)  /* I (space delimited list of jobs 'seen' by mom) */

  {
  char      *id = "sync_node_jobs";

  char      *joblist;
  char      *jobidstr;

  struct batch_request *preq;
  int        conn;

  struct job *pjob;

  if ((jobstring_in == NULL) || (!isdigit(*jobstring_in)))
    {
    /* NO-OP */

    return;
    }

  if (np->nd_state & INUSE_DELETED)
    {
    /* should never happen */

    return;
    }

  /* FORMAT <JOBID>[ <JOBID>]... */

  joblist = strdup(jobstring_in);

  if (joblist == NULL)
    {
    /* FAILURE - cannot alloc memory */

    sprintf(log_buffer,"cannot alloc memory for %s",
      jobstring_in);

    log_err(-1,id,log_buffer);

    return;
    }

  jobidstr = strtok(joblist, " ");

  while ((jobidstr != NULL) && isdigit(*jobidstr))
    {
    if (strstr(jobidstr, server_name) != NULL)
      {
      if (find_job_by_node(np, jobidstr) == NULL)
        {
        pjob = find_job(jobidstr);

        if (pjob != NULL)
          {
          /* job exists, but doesn't currently have resources assigned to this node */

          /* double check the job struct because we could be in the middle of moving
             the job around because of data staging, suspend, or rerun */

          if (pjob->ji_wattr[(int)JOB_ATR_exec_host].at_val.at_str == NULL)
            {
            pjob = NULL;
            }
          else if (strstr(pjob->ji_wattr[(int)JOB_ATR_exec_host].at_val.at_str, np->nd_name) == NULL)
            {
            pjob = NULL;
            }
          }

        if (pjob == NULL)
          {
          /* job is reported by mom but server has no record of job */

          sprintf(log_buffer, "stray job %s found on %s",
            jobidstr,
            np->nd_name);

          log_err(-1, id, log_buffer);

          /* NOTE:  node is actively reporting so should not be deleted and
                    np->nd_addrs[] should not be NULL */

          conn = svr_connect(
                   np->nd_addrs[0],
                   pbs_mom_port,
                   process_Dreply,
                   ToServerDIS);

          if (conn >= 0)
            {
            if ((preq = alloc_br(PBS_BATCH_DeleteJob)) == NULL)
              {
              log_err(-1, id, "unable to allocate DeleteJob request - big trouble!");

              svr_disconnect(conn);
              }
            else
              {
              strcpy(preq->rq_ind.rq_delete.rq_objname, jobidstr);

              if (issue_Drequest(conn, preq, release_req, 0) != 0)
                {
                /* release_req will free preq and close connection if successful */
                free_br(preq);

                svr_disconnect(conn);
                }
              }
            }

          DIS_rpp_reset();
          }
        }
      }

    jobidstr = strtok(NULL, " ");
    }  /* END while ((jobidstr != NULL) && ...) */

  /* SUCCESS */

  free(joblist);

  return;
  }  /* END sync_node_jobs() */




/*
 * update_job_data() - update job with values passed through "jobdata"
 *
 * This function is called every time we get a "jobdata" status from the pbs_mom.
 *
 * @see is_stat_get()
 */

void update_job_data(

  struct pbsnode *np,            /* I */
  char           *jobstring_in)  /* I (changed attributes sent by mom) */

  {
  char      *id = "update_job_data";

  char      *jobdata;
  char      *jobidstr;
  char      *attr_name;
  char      *attr_value;
  

  struct job *pjob;

  if ((jobstring_in == NULL) || (!isdigit(*jobstring_in)))
    {
    /* NO-OP */

    return;
    }

  if (np->nd_state & INUSE_DELETED)
    {
    /* should never happen */

    return;
    }

  /* FORMAT <JOBID>:<atrtributename=value>,<atrtributename=value>... */

  jobdata = strdup(jobstring_in);

  jobidstr = strtok(jobdata, ":");

  if ((jobidstr != NULL) && isdigit(*jobidstr))
    {
    if (strstr(jobidstr, server_name) != NULL)
      {
      pjob = find_job_by_node(np, jobidstr);
      if (pjob == NULL)
        {
        pjob = find_job(jobidstr);
        }

      if (pjob != NULL)
        {
        int bad;

        svrattrl tA;
        
        /* job exists, so get the attributes and update them */

        attr_name = strtok(NULL, "=");
        
        while (attr_name != NULL)
          {
          attr_value = strtok(NULL, ",");
          
          if (LOGLEVEL >= 9)
            {
            sprintf(log_buffer, "Mom sent changed attribute %s value %s for job %s",
              attr_name,
              attr_value,
              pjob->ji_qs.ji_jobid);
              
            log_event(
              PBSEVENT_JOB,
              PBS_EVENTCLASS_JOB,
              pjob->ji_qs.ji_jobid,
              log_buffer);  
            }
          
          memset(&tA, 0, sizeof(tA));

          tA.al_name  = attr_name;
          tA.al_resc  = "";
          tA.al_value = attr_value;
          tA.al_op    = SET;

          modify_job_attr(
            pjob,
            &tA,                              /* I: ATTR_sched_hint - svrattrl */
            ATR_DFLAG_MGWR | ATR_DFLAG_SvWR,
            &bad);

          attr_name = strtok(NULL, "=");
          }
        }
      else if (pjob == NULL)
        {
        /* job is reported by mom but server has no record of job */

        sprintf(log_buffer, "stray job %s reported on %s",
                jobidstr,
                np->nd_name);

        log_err(-1, id, log_buffer);

        }
      }
    }

  free(jobdata);
  }  /* END update_job_data() */





/*
 * send_cluster_addrs - sends IS_CLUSTER_ADDRS messages to a set of nodes
 *                      called from a work task, all nodes will eventually
 *                      be sent the current list of IPs.
 */

void send_cluster_addrs(

  struct work_task *ptask)
  {
  char id[] = "send_cluster_addrs";
  static int startcount = 0;

  struct pbsnode *np;
  new_node *nnew;
  int i, ret;

  num_addrnote_tasks--;

  if (num_addrnote_tasks > 0)
    {
    /* new nodes are still being added... don't bother yet or start over */

    DBPRT(("%s: not sending addrs yet, %d tasks exist\n",
           id,
           num_addrnote_tasks));

    startcount = 0;

    return;
    }

  for (i = startcount;i < svr_totnodes;i++)
    {
    if (i - startcount > 50)
      {
      /* only ping 50 nodes at a time, ping next batch later */

      break;
      }

    np = pbsndmast[i];

    /* Don't bother with nodes that we don't currently have a connection,
     * otherwise we'll get bogged down.  The skipped nodes will get the
     * updated info when they reconnect.
     */

    if ((np == NULL) || (np->nd_state & INUSE_DELETED) || (np->nd_stream < 0))
      continue;

    ret = is_compose(np->nd_stream, IS_CLUSTER_ADDRS);

    if (ret == DIS_SUCCESS)
      {
      if (add_cluster_addrs(np->nd_stream) == DIS_SUCCESS)
        {
        if (rpp_flush(np->nd_stream) == DIS_SUCCESS)
          {
          sprintf(log_buffer, "successful addr to node %s\n",
                  np->nd_name);

          log_record(
            PBSEVENT_SYSTEM,
            PBS_EVENTCLASS_SERVER,
            id,
            log_buffer);

          continue;
          }
        }

      ret = DIS_NOCOMMIT;
      }

    /* ping unsuccessful, mark node down, clear stream */

    update_node_state(np, INUSE_DOWN);

    sprintf(log_buffer, "%s %d to %s",
            dis_emsg[ret],
            errno,
            np->nd_name);

    log_err(-1, id, log_buffer);

    rpp_close(np->nd_stream);

    tdelete((u_long)np->nd_stream, &streams);

    np->nd_stream = -1;
    }  /* END for (i) */

  startcount = i;

  /* only ping nodes once (disable new task) */

  if (startcount < svr_totnodes)
    {
    /* continue outstanding pings after checking for other requests */

    set_task(WORK_Timed, time_now, send_cluster_addrs, NULL);
    }
  else
    {
    /* all nodes have new addr list, so clear the new nodes */

    while ((nnew = (new_node *)GET_NEXT(svr_newnodes)) != NULL)
      {
      np = find_nodebyname(nnew->nn_name);

      if (np != NULL)
        {
        np->nd_state &= ~INUSE_OFFLINE;
        }

      delete_link(&nnew->nn_link);
      }

    /* reset startcount, as we've sent the updates for all servers */
    startcount = 0;
    }
  }     /* END send_cluster_addrs */






/*
 *      setup_notification -  Sets up the  mechanism for notifying
 *                            other members of the server's node
 *                            pool that a new node was added manually
 *                            via qmgr.  Actual notification occurs some
 *                            time later through the send_cluster_addrs mechanism
 */

void setup_notification(char *pname)

  {

  struct pbsnode *pnode;
  new_node       *nnew;

  if (pname != NULL)
    {
    pnode = find_nodebyname(pname);

    assert(pnode != NULL);

    /* call it offline until after all nodes get the new ipaddr */
    pnode->nd_state |= INUSE_OFFLINE;

    nnew = malloc(sizeof(new_node));

    if (nnew == NULL)
      {
      return;
      }

    CLEAR_LINK(nnew->nn_link);

    nnew->nn_name = strdup(pname);

    append_link(&svr_newnodes, &nnew->nn_link, nnew);
    }

  set_task(

    WORK_Timed,
    time_now + 5,
    send_cluster_addrs,
    NULL);

  num_addrnote_tasks++;

  return;
  }






int is_stat_get(

  struct pbsnode *np)  /* I (modified) */

  {
  char      *id = "is_stat_get";

  int stream = np->nd_stream;
  int        rc;
  char      *ret_info;
  attribute  temp;
  char       date_attrib[100];
  int        msg_error = 0;

  extern int TConnGetSelectErrno();
  extern int TConnGetReadErrno();

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer, "received status from node %s",
            (np != NULL) ? np->nd_name : "NULL");

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

  if (stream < 0)
    {
    return(DIS_EOF);
    }

  /*
   *  Before filling the "temp" attribute, initialize it.
   *  The second and third parameter to decode_arst are never
   *  used, so just leave them empty. (GBS)
   */

  memset(&temp, 0, sizeof(temp));

  rc = DIS_SUCCESS;

  if (decode_arst(&temp, NULL, NULL, NULL))
    {
    DBPRT(("is_stat_get:  cannot initialize attribute\n"));

    rpp_eom(stream);

    return(DIS_NOCOMMIT);
    }

  funcs_dis();

  while (((ret_info = disrst(stream, &rc)) != NULL) && (rc == DIS_SUCCESS))
    {
    /* add the info to the "temp" attribute */

    if (decode_arst(&temp, NULL, NULL, ret_info))
      {
      DBPRT(("is_stat_get: cannot add attributes\n"));

      free_arst(&temp);

      free(ret_info);

      rpp_eom(stream);

      return(DIS_NOCOMMIT);
      }

    if (!strncmp(ret_info, "state", 5))
      {
      /* MOM currently never sends multiple states - bad assumption for the future? */

      if (!strncmp(ret_info, "state=down", 10))
        {
        update_node_state(np, INUSE_DOWN);
        }
      else if (!strncmp(ret_info, "state=busy", 10))
        {
        update_node_state(np, INUSE_BUSY);
        }
      else if (!strncmp(ret_info, "state=free", 10))
        {
        update_node_state(np, INUSE_FREE);
        }
      else
        {
        sprintf(log_buffer, "unknown %s from node %s",
                ret_info,
                (np->nd_name != NULL) ? np->nd_name : "NULL");

        log_err(-1, id, log_buffer);

        update_node_state(np, INUSE_UNKNOWN);
        }
      }
    else if (!strncmp(ret_info, "me", 2))  /* shorter str compare than "message" */
      {
      if (!strncmp(ret_info, "message=ERROR", 13))
        {
        msg_error = 1;
        }
      }
    else if (server.sv_attr[(int)SRV_ATR_MomJobSync].at_val.at_long &&
             !strncmp(ret_info, "jobdata=", 8))
      {
      /* update job attributes based on what the MOM gives us */
      
      update_job_data(np, ret_info + strlen("jobdata="));
      }
    else if (server.sv_attr[(int)SRV_ATR_MomJobSync].at_val.at_long &&
             !strncmp(ret_info, "jobs=", 5))
      {
      /* walk job list reported by mom */

      sync_node_jobs(np, ret_info + strlen("jobs="));
      }
    else if (server.sv_attr[(int)SRV_ATR_AutoNodeNP].at_val.at_long &&
             !strncmp(ret_info, "ncpus=", 6))
      {

      struct attribute nattr;

      /* first we decode ret_info into nattr... */

      if ((node_attr_def + ND_ATR_np)->at_decode(&nattr, ATTR_NODE_np, NULL, ret_info + 6) == 0)
        {
        /* ... and if MOM's ncpus is higher than our np... */
        if (nattr.at_val.at_long > np->nd_nsn)
          {
          /* ... then we do the defined magic to create new subnodes */
          (node_attr_def + ND_ATR_np)->at_action(&nattr, (void *)np, ATR_ACTION_ALTER);

          update_nodes_file();
          }
        }
      }
    else if(server.sv_attr[(int)SRV_ATR_NPDefault].at_val.at_long)
      {
        struct pbsnode *pnode;
        int i;
        long max_np;
        long nsnfreediff;

        max_np = server.sv_attr[(int)SRV_ATR_NPDefault].at_val.at_long;

        for(i = 0; i < svr_totnodes; i++)
          {
          pnode = pbsndlist[i];

          nsnfreediff = pnode->nd_nsn - pnode->nd_nsnfree;
          pnode->nd_nsn = max_np;
          pnode->nd_nsnfree = max_np - nsnfreediff;

          }
      }
    else
      {
      resource_def *def;
      resource *res;
      int store = 0;
      char *target_name = ret_info, *c = strchr(ret_info,'=');
      if (c != NULL)
        *c = '\0';

      /* check if the resource is in the list specified in ATTR_ResourcesToStore */
      if (server.sv_attr[SRV_ATR_ResourcesToStore].at_flags & ATR_VFLAG_SET)
        {
        int i;
        struct array_strings *tmp =
            server.sv_attr[SRV_ATR_ResourcesToStore].at_val.at_arst;

        for (i = 0; i < tmp->as_usedptr; i++)
          {
          if (strcmp(tmp->as_string[i],ret_info) == 0)
            {
            store = 1;
            break;
            }
          }
        }

      /* check if the resource is mapped to some other name */
      if (store && (server.sv_attr[SRV_ATR_ResourcesMappings].at_flags & ATR_VFLAG_SET))
        {
        int i;
        struct array_strings *tmp =
            server.sv_attr[SRV_ATR_ResourcesMappings].at_val.at_arst;

        for (i = 0; i < tmp->as_usedptr; i++)
          {
          if (strncmp(tmp->as_string[i],ret_info,strlen(ret_info)) == 0)
            {
            char *new_name = strchr(tmp->as_string[i],'=');

            if (new_name == NULL) /* mallformed value */
              continue;

            target_name = ++new_name;
            }
          }
        }

      if (store)
        {
        def = find_resc_def(svr_resc_def,target_name,svr_resc_size);
        if (def != 0)
          {
          res = find_resc_entry(&np->attributes[0],def);
          if (res != 0)
            {
            if ((res->rs_value.at_flags & ATR_VFLAG_FORCED) == 0)
              def->rs_decode(&res->rs_value,0,0,c+1);
            }
          else
            {
            res = add_resource_entry(&np->attributes[0],def);
            def->rs_decode(&res->rs_value,0,0,c+1);
            res->rs_value.at_flags &= ~ATR_VFLAG_FORCED;
            }
          }
        }
      }
    free(ret_info);
    }    /* END while (rc != DIS_EOD) */

  /* clear the transmission */

  rpp_eom(stream);

  /* DIS_EOD is the only valid final value of rc, check it */

  if (rc != DIS_EOD)
    {
    update_node_state(np, INUSE_UNKNOWN);

    free_arst(&temp);

    return(rc);
    }

  if (msg_error && server.sv_attr[(int)SRV_ATR_DownOnError].at_val.at_long)
    {
    update_node_state(np, INUSE_DOWN);
    }

  /* it's nice to know when the last update happened */

  sprintf(date_attrib, "rectime=%ld",
          (long)time_now);

  if (decode_arst(&temp, NULL, NULL, date_attrib))
    {
    DBPRT(("is_stat_get:  cannot add date_attrib\n"));

    update_node_state(np, INUSE_UNKNOWN);

    free_arst(&temp);

    return(DIS_NOCOMMIT);
    }


  /* insert the information from "temp" into np */

  if (node_status_list(&temp, np, ATR_ACTION_ALTER))
    {
    DBPRT(("is_stat_get: cannot set node status list\n"));

    update_node_state(np, INUSE_UNKNOWN);

    return(DIS_NOCOMMIT);
    }

  /* NOTE:  node state adjusted in update_node_state() */

  return(DIS_SUCCESS);
  }  /* END is_stat_get() */




/*
** Start a standard inter-server message.
*/

int is_compose(

  int stream,  /* I */
  int command) /* I */

  {
  int ret;

  if (stream < 0)
    {
    return(DIS_EOF);
    }

  DIS_rpp_reset();

  ret = diswsi(stream, IS_PROTOCOL);

  if (ret != DIS_SUCCESS)
    goto done;

  ret = diswsi(stream, IS_PROTOCOL_VER);

  if (ret != DIS_SUCCESS)
    goto done;

  ret = diswsi(stream, command);

  if (ret != DIS_SUCCESS)
    goto done;

  return(DIS_SUCCESS);

done:

  DBPRT(("is_compose: send error %s\n",
         dis_emsg[ret]))

  return(ret);
  }  /* END is_compose() */




/* EOF on a stream received (either stream or addr must be specified) */
/* mark node down and remove associated streams */
/* NOTE: pass in stream = -1 if you wish the stream to be optional */

void stream_eof(

  int  stream,  /* I (optional) */
  u_long addr,  /* I (optional) */
  int  ret)     /* I (ignored) */

  {
  static char     id[] = "stream_eof";

  struct pbsnode *np;

  rpp_close(stream);

  np = NULL;

  if (stream >= 0)
    {
    /* find who the stream belongs to and mark down */

    np = tfind((u_long)stream, &streams);
    }

  if ((np == NULL) && (addr != 0))
    {
    np = tfind((u_long)addr, &ipaddrs);
    }

  if (np == NULL)
    {
    /* cannot locate node */

    return;
    }

  sprintf(log_buffer, "connection to %s is bad, remote service may be down, message may be corrupt, or connection may have been dropped remotely (%s).  setting node state to down",

          np->nd_name,
          dis_emsg[ret]);

  log_err(-1, id, log_buffer);

  /* mark node and all subnodes as down */

  update_node_state(np, INUSE_DOWN);

  /* remove stream from list of valid connections */

  if (np->nd_stream >= 0)
    {
    tdelete((u_long)np->nd_stream, &streams);

    np->nd_stream = -1;
    }

  return;
  }  /* END stream_eof() */




/*
 * Send a ping to any node that is in an unknown state.
 * If wt_parm1 is NULL, set up a worktask to ping again.
 *
 *      This shouldn't be called anymore...
 *      This is mostly only used for opening the socket
 *      connection to the node.
*/

#define TNODE_PINGCOUNT     256
#define TNODE_PINGRETRYTIME   3

void ping_nodes(

  struct work_task *ptask)  /* I (optional) */

  {
  static  char         *id = "ping_nodes";

  struct  pbsnode *np;

  struct  sockaddr_in *addr;
  int                    i, ret, com;
  extern  int            pbs_rm_port;

  static  int            startcount = 0;

  void *ptable;
  char *value;

  extern int RPPConfigure(int, int);
  extern int RPPReset(void);

  if (LOGLEVEL >= 6)
    {
    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      "starting");
    }

  sprintf(log_buffer, "ping attempting to contact %d nodes",

          (svr_totnodes - startcount > TNODE_PINGCOUNT) ?
          TNODE_PINGCOUNT :
          (svr_totnodes - startcount < 0) ?
          svr_totnodes :
          svr_totnodes - startcount); /* phew! */

  log_record(
    PBSEVENT_SCHED,
    PBS_EVENTCLASS_REQUEST,
    id,
    log_buffer);

  /* read magrathea status from pbs_cache
   * and set INUSE_FROZEN for frozen nodes
   * flag is cleared only for nodes which are not down,
   * otherwise is cleared when ping from node arrives
   */
  ptable=cache_hash_init();
  if (cache_hash_fill_local("magrathea",ptable)==0)
    {
    for (i=0; i< svr_totnodes; i++)
      {
      value=cache_hash_find(ptable,pbsndmast[i]->nd_name);
      if (value!=NULL)
        {
        struct pbsnode *nd;
        nd=pbsndmast[i];

        if (strstr(value,"frozen")!=NULL)
          {
          if (nd->nd_state & INUSE_FROZEN)
            {
            log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE, nd->nd_name, "frozen flag already set");
            }
          else
            {
            nd->nd_state |= INUSE_FROZEN;
            log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE, nd->nd_name, "frozen flag set");
            }
          }
        else
          {
          if ((nd->nd_state & INUSE_FROZEN))
            {
            nd->nd_state &= ~(INUSE_FROZEN);
            log_event(PBSEVENT_SYSTEM, PBS_EVENTCLASS_NODE, nd->nd_name, "frozen flag removed");
            }
          }
        free(value);
        }
      }
    }


  /* change RPP to report node state quickly */

  RPPConfigure(2, 2); /* (timeout,retry) retry must be at least 2 */

  for (i = startcount;i < svr_totnodes;i++)
    {
    if (i - startcount > TNODE_PINGCOUNT)
      {
      /* only ping TNODE_PINGCOUNT nodes at a time, ping next batch later */

      break;
      }

    np = pbsndmast[i];

    if (np->nd_state & (INUSE_DELETED | INUSE_OFFLINE))
      continue;

    if ((np->nd_state & INUSE_NEEDS_HELLO_PING) == 0)
      continue;

    if (np->nd_stream < 0)
      {
      /* nodes are down until proven otherwise */

      update_node_state(np, INUSE_DOWN);

      /* open new stream */

      np->nd_stream = rpp_open(np->nd_name, pbs_rm_port, NULL);

      if (np->nd_stream == -1)
        {
        sprintf(log_buffer, "rpp_open to %s",
                np->nd_name);

        log_err(errno, id, log_buffer);

        continue;
        }

      tinsert((u_long)np->nd_stream, np, &streams);
      }  /* END if (np->nd_stream < 0) */

    if (LOGLEVEL >= 6)
      {
      sprintf(log_buffer, "sending ping to %s (new stream %d)",
              np->nd_name, np->nd_stream);

      log_record(
        PBSEVENT_SCHED,
        PBS_EVENTCLASS_REQUEST,
        id,
        log_buffer);
      }

    /* nodes are down until proven otherwise */

    com = IS_HELLO;

    ret = is_compose(np->nd_stream, com);

    if (ret == DIS_SUCCESS)
      {
      if (rpp_flush(np->nd_stream) == 0)
        {
        sprintf(log_buffer, "successful ping to node %s (stream %d)",
                np->nd_name, np->nd_stream);

        log_record(
          PBSEVENT_SCHED,
          PBS_EVENTCLASS_REQUEST,
          id,
          log_buffer);

        continue;
        }

      ret = DIS_NOCOMMIT;
      }

    /* ping unsuccessful, mark node down, clear stream */

    update_node_state(np, INUSE_DOWN);

    addr = rpp_getaddr(np->nd_stream);

    sprintf(log_buffer, "%s %d to %s(%s)",
            dis_emsg[ret],
            errno,
            np->nd_name,
            netaddr(addr));

    log_err(-1, id, log_buffer);

    rpp_close(np->nd_stream);

    tdelete((u_long)np->nd_stream, &streams);

    np->nd_stream = -1;
    }  /* END for (i) */

  RPPReset();

  startcount = i;

  /* only ping nodes once (disable new task) */

  if (startcount < svr_totnodes)
    {
    /* continue outstanding pings in TNODE_PINGRETRYTIME seconds */

    set_task(WORK_Timed, time_now + TNODE_PINGRETRYTIME, ping_nodes, NULL);
    }

  return;
  }  /* END ping_nodes() */





/* add_cluster_addrs - add the IPaddr of every node to the stream */

int add_cluster_addrs(

  int stream) /* I */

  {
  char id[] = "add_cluster_addrs";

  int i, j, ret;

  struct pbsnode *np;

  /* should we cache this response and send it as a single string? */

  for (i = 0;i < svr_totnodes;i++)
    {
    np = pbsndmast[i];

    if (np->nd_state & INUSE_DELETED)
      continue;

    if (LOGLEVEL == 7)  /* higher loglevel gets more info below */
      {
      sprintf(log_buffer, "adding node[%d] %s to hello response",
              i,
              np->nd_name);

      log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buffer);
      }

    for (j = 0;np->nd_addrs[j];j++)
      {
      u_long ipaddr = np->nd_addrs[j];

      if (LOGLEVEL >= 8)
        {
        sprintf(log_buffer, "adding node[%d] interface[%d] %s to hello response",
                i,
                j,
                netaddr_pbs_net_t(ipaddr));

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buffer);
        }

      ret = diswul(stream, ipaddr);

      if (ret != DIS_SUCCESS)
        {
        /* FAILURE */

        return(ret);
        }
      }  /* END for (j) */
    }    /* END for (i) */

  return(DIS_SUCCESS);
  } /* END add_cluster_addrs */




/*
 **     Mark any nodes that haven't checked in as down.
 **     This should be used rather than the ping_nodes task.  If
 **     the node isn't down then it checks to see that the
 **     last update hasn't been too long ago.
 */

void check_nodes(

  struct work_task *ptask)  /* I (modified) */

  {
  static char     id[] = "check_nodes";

  struct pbsnode *np;
  int             i, chk_len;

  /* load min refresh interval */

  chk_len = server.sv_attr[(int)SRV_ATR_check_rate].at_val.at_long;

  if (LOGLEVEL >= 5)
    {
    sprintf(log_buffer, "verifying nodes are active (min_refresh = %d seconds)",
            chk_len);

    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      id,
      log_buffer);
    }

  /* evaluate all nodes */

  for (i = 0;i < svr_totnodes;i++)
    {
    np = pbsndmast[i];

    if (np->nd_state & (INUSE_DELETED | INUSE_DOWN | INUSE_FROZEN))
      continue;

    if (np->nd_lastupdate < (time_now - chk_len))
      {
      if (LOGLEVEL >= 0)
        {
        sprintf(log_buffer, "node %s not detected in %ld seconds, marking node down",
                np->nd_name,
                (long int)(time_now - np->nd_lastupdate));

        log_event(
          PBSEVENT_ADMIN,
          PBS_EVENTCLASS_SERVER,
          id,
          log_buffer);
        }

      update_node_state(np, (INUSE_DOWN));
      }
    }    /* END for (i = 0) */

  if (ptask->wt_parm1 == NULL)
    {
    set_task(
      WORK_Timed,
      time_now + chk_len,
      check_nodes,
      NULL);
    }

  return;
  }  /* END check_nodes() */



/* sync w/#define IS_XXX */

const char *PBSServerCmds2[] =
  {
  "NULL",
  "HELLO",
  "CLUSTER_ADDRS",
  "UPDATE",
  "STATUS",
  NULL
  };

/*
 * Input is coming from the pbs_mom over a DIS rpp stream.
 * Read the stream to get a Inter-Server request.
 */

void is_request(

  int  stream,  /* I */
  int  version, /* I */
  int *cmdp)    /* O (optional) */

  {
  static char   id[] = "is_request";

  int  command = 0;
  int  ret = DIS_SUCCESS;
  int  i;

  unsigned long ipaddr;

  struct sockaddr_in *addr;

  struct pbsnode *node;

  struct pbssubn *sp;

  if (cmdp != NULL)
    *cmdp = 0;

  if (LOGLEVEL >= 4)
    {
    sprintf(log_buffer, "message received from stream %d (version %d)",
            stream,
            version);

    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      id,
      log_buffer);
    }

  addr = rpp_getaddr(stream);

  if (version != IS_PROTOCOL_VER)
    {
    sprintf(log_buffer, "protocol version %d unknown from %s",
            version,
            netaddr(addr));

    log_err(-1, id, log_buffer);

    rpp_close(stream);

    return;
    }

  /* check that machine is known */

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer, "message received from stream %s",
            netaddr(addr));

    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      id,
      log_buffer);
    }

  if ((node = tfind((u_long)stream, &streams)) != NULL)
    goto found;

  ipaddr = ntohl(addr->sin_addr.s_addr);

  if ((node = tfind(ipaddr, &ipaddrs)) != NULL)
    {
    if (node->nd_stream >= 0)
      {
      if (LOGLEVEL >= 3)
        {
        sprintf(log_buffer, "stream %d from node %s already open on %d (marking node state 'unknown')",
                stream,
                node->nd_name,
                node->nd_stream);

        log_event(
          PBSEVENT_ADMIN,
          PBS_EVENTCLASS_SERVER,
          id,
          log_buffer);
        }

      rpp_close(stream);

      rpp_close(node->nd_stream);

      tdelete((u_long)node->nd_stream, &streams);

      if (node->nd_state & INUSE_OFFLINE)
        {
        node->nd_state = (INUSE_UNKNOWN | INUSE_OFFLINE);
        }
      else
        {
        node->nd_state = INUSE_UNKNOWN;
        }

      node->nd_stream = -1;

      /* do a ping in 5 seconds */

      /*
      set_task(WORK_Timed,time_now + 5,
        ping_nodes, node);
      */

      return;
      }  /* END if (node->nd_stream >= 0) */

    node->nd_stream = stream;

    tinsert((u_long)stream, node, &streams);

    goto found;
    }  /* END if ((node = tfind(ipaddr,&ipaddrs)) != NULL) */

  /* node not listed in trusted ipaddrs list */

  sprintf(log_buffer, "bad attempt to connect from %s (address not trusted - check entry in server_priv/nodes)",
          netaddr(addr));

  if (LOGLEVEL >= 2)
    {
    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

  log_err(-1, id, log_buffer);

  rpp_close(stream);

  return;

found:

  command = disrsi(stream, &ret);

  if (ret != DIS_SUCCESS)
    goto err;

  if (cmdp != NULL)
    *cmdp = command;

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer, "message %s (%d) received from mom on host %s (%s) (stream %d)",
            PBSServerCmds2[command],
            command,
            node->nd_name,
            netaddr(addr),
            stream);

    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      id,
      log_buffer);
    }

  switch (command)
    {

    case IS_NULL:  /* a ping from server */

      DBPRT(("%s: IS_NULL\n",
             id))

      break;

    case IS_HELLO:

      if (LOGLEVEL >= 1)
        {
        sprintf(log_buffer, "HELLO received from %s",
                node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buffer);
        }

#ifndef ALT_CLSTR_ADDR
      ret = is_compose(stream, IS_CLUSTER_ADDRS);

      if (ret != DIS_SUCCESS)
        goto err;

      if (add_cluster_addrs(stream) != DIS_SUCCESS)
        goto err;

      /* NOTE:  re-enabled rpp_flush/disabled rpp_eom (CRI) */

      ret = rpp_flush(stream);

      if (ret != DIS_SUCCESS)
        goto err;

      if (LOGLEVEL >= 3)
        {
        sprintf(log_buffer, "sending cluster-addrs to node %s\n",
                node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buffer);
        }

      /* rpp_eom(stream); */

      /* CLUSTER_ADDRS successful */
#endif
      node->nd_state &= ~(INUSE_NEEDS_HELLO_PING|INUSE_FROZEN|INUSE_DOWN);

      break;

    case IS_UPDATE:

      DBPRT(("%s: IS_UPDATE\n",
             id))

      i = disrui(stream, &ret);

      if (ret != DIS_SUCCESS)
        {
        if (LOGLEVEL >= 1)
          {
          sprintf(log_buffer, "IS_UPDATE error %d on node %s\n",
                  ret,
                  node->nd_name);

          log_err(ret, id, log_buffer);
          }

        goto err;
        }

      DBPRT(("%s: IS_UPDATE %s 0x%x\n",

             id,
             node->nd_name,
             i))

      update_node_state(node, i);

      break;

    case IS_STATUS:

      /* pbs_server brought up
         pbs_mom brought up
         they send IS_HELLO to each other
         pbs_mom sends IS_STATUS message to pbs_server (replying to IS_HELLO)
         pbs_server sends IS_CLUSTER_ADDRS message to pbs_mom  (replying to IS_HELLO)
         pbs_mom uses IS_CLUSTER_ADDRS message to authorize contacts from sisters */

      if (LOGLEVEL >= 2)
        {
        sprintf(log_buffer, "IS_STATUS received from %s",
                node->nd_name);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buffer);
        }

      ret = is_stat_get(node);

      if (ret != DIS_SUCCESS)
        {
        if (LOGLEVEL >= 1)
          {
          sprintf(log_buffer, "IS_STATUS error %d on node %s",
                  ret,
                  node->nd_name);

          log_err(ret, id, log_buffer);
          }

        goto err;
        }

      node->nd_lastupdate = time_now;

      if (LOGLEVEL >= 9)
        {
        sprintf(log_buffer, "node '%s' is at state '0x%x'\n",
                node->nd_name,
                node->nd_state);

        log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buffer);
        }

      for (sp = node->nd_psn;sp != NULL;sp = sp->next)
        {
        if (!(node->nd_state & INUSE_OFFLINE) &&
            (sp->inuse & INUSE_OFFLINE))
          {
          /* this doesn't seem to ever happen */

          if (LOGLEVEL >= 2)
            {
            sprintf(log_buffer, "sync'ing subnode state '%s' with node state on node %s\n",
                    "offline",
                    node->nd_name);

            log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, log_buffer);
            }

          sp->inuse &= ~INUSE_OFFLINE;
          }

        sp->inuse &= ~INUSE_DOWN;
        }

      break;

    default:

      sprintf(log_buffer, "unknown command %d sent from %s",
              command,
              node->nd_name);

      log_err(-1, id, log_buffer);

      goto err;

      break;
    }  /* END switch (command) */

  rpp_eom(stream);

  return;

err:

  /* a DIS write error has occurred */

  if (LOGLEVEL >= 1)
    {
    DBPRT(("%s: error processing node %s\n",
           id,
           node->nd_name))
    }

  sprintf(log_buffer, "%s from %s(%s)",

          dis_emsg[ret],
          node->nd_name,
          netaddr(addr));

  log_err(-1, id, log_buffer);

  rpp_close(stream);

  update_node_state(node, INUSE_DOWN);

  return;
  }  /* END is_request() */




void
write_node_state(void)

  {

  struct pbsnode *np;
  static char *fmt = "%s %d\n";
  int i;

  int   savemask;

  if (LOGLEVEL >= 5)
    {
    DBPRT(("write_node_state: entered\n"))
    }

  /* don't store volatile states like down and unknown */

  savemask = INUSE_OFFLINE | INUSE_RESERVE;

  if (nstatef != NULL)
    {
    fseek(nstatef, 0L, SEEK_SET); /* rewind and clear */

    if (ftruncate(fileno(nstatef), (off_t)0) != 0)
      {
      log_err(errno, "write_node_state", "could not truncate file");

      return;
      }
    }
  else
    {
    /* need to open for first time, temporary-move to pbsd_init */

    if ((nstatef = fopen(path_nodestate, "w+")) == NULL)
      {
      log_err(
        errno,
        "write_node_state",
        "could not open file");

      return;
      }
    }

  /*
  ** The only state that carries forward is if the
  ** node has been marked offline.
  */

  for (i = 0;i < svr_totnodes;i++)
    {
    np = pbsndmast[i];

    if (np->nd_state & INUSE_DELETED)
      continue;

    if (np->nd_state & INUSE_OFFLINE)
      {
      fprintf(nstatef, fmt,
              np->nd_name,
              np->nd_state & savemask);
      }
    }    /* END for (i) */

  if (fflush(nstatef) != 0)
    {
    log_err(errno, "write_node_state", "failed saving node state to disk");
    }

  return;
  }  /* END write_node_state() */



/* Create a new node_note file then overwrite the previous one.
 *
 *   The note file could get up to:
 *      (# of nodes) * (2 + MAX_NODE_NAME + MAX_NOTE)  bytes in size
 */
int
write_node_note(void)
  {
#ifndef NDEBUG
  static char id[] = "write_node_note";
#endif

  struct pbsnode *np;
  int i;
  FILE *nin;

  if (LOGLEVEL >= 2)
    {
    DBPRT(("%s: entered\n",
           id))
    }

  if ((nin = fopen(path_nodenote_new, "w")) == NULL)
    goto err1;

  if ((svr_totnodes == 0) || (pbsndmast == NULL))
    {
    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      "node_note",
      "Server has empty nodes list");

    fclose(nin);

    return(-1);
    }

  /* for each node ... */

  for (i = 0;i < svr_totnodes;++i)
    {
    np = pbsndmast[i];

    if (np->nd_state & INUSE_DELETED)
      continue;

    /* write node name followed by its note string */

    if (np->nd_note != NULL && np->nd_note != '\0')
      {
      fprintf(nin, "%s %s\n",
              np->nd_name,
              np->nd_note);
      }
    }

  fflush(nin);

  if (ferror(nin))
    {
    fclose(nin);
    goto err1;
    }

  fclose(nin);

  if (rename(path_nodenote_new, path_nodenote) != 0)
    {
    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      "node_note",
      "replacing old node note file failed");

    return(-1);
    }

  return(0);

err1:
  log_event(
    PBSEVENT_ADMIN,
    PBS_EVENTCLASS_SERVER,
    "node_note",
    "Node note file update failed");

  return(-1);

  }  /* END write_node_note() */



/*
 * free_prop - free list of prop structures created by proplist()
 */

static void free_prop(

  struct prop *prop)

  {

  struct prop *pp;

  for (pp = prop;pp != NULL;pp = prop)
    {
    prop = pp->next;

    free(pp->name);

    if (pp->value)
      free(pp->value);

    free(pp);
    }  /* END for (pp) */

  return;
  }    /* END free_prop() */




/*
 * unreserve - unreserve nodes
 *
 * If handle is set to a existing resource_t, then release all nodes
 * associated with that handle, otherwise, (this is dangerous)
 * if handle == RESOURCE_T_ALL, release all nodes period.
 */

void node_unreserve(

  resource_t handle)

  {

  struct  pbsnode *np;

  struct  pbssubn *sp;
  int     i;

  /* clear old reserve */

  for (i = 0;i < svr_totnodes;i++)
    {
    np = pbsndlist[i];

    if (np->nd_state & INUSE_DELETED)
      continue;

    for (sp = np->nd_psn;sp;sp = sp->next)
      {
      if (sp->inuse & INUSE_RESERVE)
        {
        if ((handle == RESOURCE_T_ALL) || (handle == sp->allocto))
          {
          np->nd_nsnfree++;

          sp->inuse    &= ~INUSE_RESERVE;
          np->nd_state &= ~INUSE_RESERVE;
          }
        }
      }
    }

  return;
  }  /* END node_unreserve() */



int hasres(struct pbsnode *pnode, char  *name, char *value, int proc_count)
  {
  resource_def *rd;
  resource *total, *used, req, tmp;
  int rc;

  rd = find_resc_def(svr_resc_def,name,svr_resc_size);

  if (rd == NULL) /* unknown resource */
    return 0;

  if ((rd->rs_flags & (ATR_DFLAG_SELECT_PROC | ATR_DFLAG_SELECT_MOM)) == 0)
    return 1; /* this resource is not per-proc or per-node and therefore not checked */

  total = find_resc_entry(&pnode->attributes[0],rd);

  if (total == NULL) /* resource not present on node */
    return 0;

  used = find_resc_entry(&pnode->attributes[1],rd);

  rd->rs_decode(&req.rs_value,0,name,value); /* encode the request into resource */

  /* now we need to determine if this resource is per-proc or per-node */
  /* if it is per-proc, we need to multiply the value accordingly by the number of procs */
  /* because there is no universal logic for this, we simply have to manually multiply the value */
  if ((rd->rs_flags & ATR_DFLAG_SELECT_PROC) != 0)
    {
    switch (rd->rs_type)
      {
      case ATR_TYPE_LONG:
        req.rs_value.at_val.at_long *= proc_count;
        break;
      case ATR_TYPE_LL:
        req.rs_value.at_val.at_ll *= proc_count;
        break;
      case ATR_TYPE_SHORT:
        req.rs_value.at_val.at_short *= proc_count;
        break;
      case ATR_TYPE_SIZE:
        /* keep it in the same unit */
        req.rs_value.at_val.at_size.atsv_num *= proc_count;
        break;
      default: /* we can't multiply non-numeric values */
        break; /* ATR_TYPE_JINFOP, ATR_TYPE_ACL, ATR_TYPE_RESC, ATR_TYPE_CHAR, ATR_TYPE_STR, ATR_TYPE_ARST, ATR_TYPE_LIST */
      }
    }

  rd->rs_set(&tmp.rs_value,&total->rs_value,SET); /* set the total */

  if (used != NULL && (used->rs_value.at_flags & ATR_VFLAG_SET))
    rd->rs_set(&tmp.rs_value,&used->rs_value,DECR); /* decrement the used amount */

  rc = rd->rs_comp(&tmp.rs_value,&req.rs_value); /* finally compare the result */

  rd->rs_free(&tmp.rs_value);
  rd->rs_free(&req.rs_value);

  if (rc >= 0)
    return 1;
  else
    return 0;
  }


/*
** Look through the property list and make sure that all
** those marked are contained in the node.
*/

int hasprop(
  struct pbsnode *pnode,
  struct prop    *props,
  int proc_count )

  {

  struct  prop    *need;

  for (need = props;need;need = need->next)
    {
    struct prop *pp;

    if (need->mark == 0 && (need->value == NULL)) /* not marked, skip */
      continue;                                    /* do not skip resources */

    if (need->value == NULL)
      {
      for (pp = pnode->nd_first;pp != NULL;pp = pp->next)
        {
        if (strcmp(pp->name, need->name) == 0)
          break;  /* found it */
        }

      if (pp == NULL)
        {
        return(0);
        }
      }
    else
      {
      if (!hasres(pnode,need->name,need->value,proc_count))
        return 0;
      }
    }

  return(1);
  }  /* END hasprop() */


/** Look through the additional property list and make sure that all those makred are contained in the node
 *
 */
int hasadprop(struct pbsnode *pnode, struct prop *props)
  {
  struct prop *need;

  for (need = props; need != NULL; need = need->next)
    {
    struct prop *pp;

    if (need->mark == 0)
      continue;

    for (pp = pnode->x_ad_prop; pp != NULL; pp = pp->next)
      {
      if (strcmp(pp->name, need->name) == 0)
        break;
      }

    if (pp == NULL)
      return 0;
    }

  return 1;
  }

/*
 * see if node has the number of processors required
 * if free == SKIP_NONE,  check against total number of processors, else
 * if free != SKIP_NONE,  check against number free
 *
 * Return 1 if possible, 0 if not
 */

static int hasppn(

  struct pbsnode *pnode,     /* I */
  int             node_req,  /* I */
  int             free)      /* I */

  {
  if ((free != SKIP_NONE) &&
      (free != SKIP_NONE_REUSE) &&
      (pnode->nd_nsnfree >= node_req))
    {
    return(1);
    }

  if (!free && (pnode->nd_nsn >= node_req))
    {
    return(1);
    }

  return(0);
  }  /* END hasppn() */




/*
** Mark the properties of a node that match the marked
** properties given.
*/

static void mark(

  struct pbsnode *pnode,  /* I */
  struct prop    *props)

  {

  struct  prop    *set, *pp;

  for (pp = pnode->nd_first;pp != NULL;pp = pp->next)
    {
    pp->mark = 0;

    for (set = props;set;set = set->next)
      {
      if (set->mark == 0)
        continue;

      if (strcmp(pp->name, set->name) == 0)
        {
        pp->mark = 1;

        break;
        }
      }
    }

  return;
  }  /* END mark() */




#define RECURSIVE_LIMIT 3

/*
** Search for a node which contains properties glorf and the requirements.
** skip indicates which nodes to pass over for this search.
** Don't do any recursive calls deeper than RECURSIVE_LIMIT.
**      RETURN:  0 = failure, 1 = SUCCESS
*/

static int search(

  struct prop  *glorf,  /* properties */
  int    vpreq,  /* VPs needed */
  int    skip,
  int    order,
  int    depth)

  {
  static int pass = INUSE_OFFLINE | INUSE_DOWN | INUSE_RESERVE | INUSE_UNKNOWN | INUSE_DELETED;

  struct pbsnode *pnode;
  int found;
  int i;

  if (++depth == RECURSIVE_LIMIT)
    {
    return(0);
    }

  /* look for nodes we haven't picked already */

  for (i = 0;i < svr_totnodes;i++)
    {
    pnode = pbsndlist[i];

    if (pnode->nd_state & INUSE_DELETED)
      continue;

    if (pnode->nd_exclusive) /* the node is already exclusively assigned, skip */
      continue;

    if (pnode->nd_ntype == NTYPE_CLUSTER || pnode->nd_ntype == NTYPE_VIRTUAL
        || pnode->nd_ntype == NTYPE_CLOUD)
      {
      if (pnode->nd_flag != okay)
        {
        if ((skip != SKIP_NONE_REUSE) || (pnode->nd_flag != thinking))
          {
          /* allow node re-use if SKIP_NONE_REUSE is set */

          continue;
          }
        }

      /* FIXME: this is rejecting job submits?
            if (pnode->nd_state & pass)
              continue;
      */

      if (!(hasprop(pnode, glorf, vpreq) || hasadprop(pnode, glorf)))
        continue;

      if ((skip == SKIP_NONE) || (skip == SKIP_NONE_REUSE))
        {
        if (vpreq > pnode->nd_nsn)
          continue;
        }
      else if ((skip == SKIP_ANYINUSE) &&
               ((pnode->nd_state & INUSE_SUBNODE_MASK) || (vpreq > pnode->nd_nsnfree)))
        {
        continue;
        }
      else if ((skip == SKIP_EXCLUSIVE) &&
               ((pnode->nd_state & INUSE_SUBNODE_MASK) ||
                (vpreq > (pnode->nd_nsnfree + pnode->nd_nsnshared))))
        {
        continue;
        }

      /* NOTE: allow node re-use if SKIP_NONE_REUSE by ignoring 'thinking' above */

      pnode->nd_flag = thinking;

      mark(pnode, glorf);

      pnode->nd_needed = vpreq;

      pnode->nd_order  = order;

      /* SUCCESS */

      return(1);
      }
    }

  if (glorf == NULL)  /* no property */
    {
    /* FAILURE */

    return(0);   /* can't retry */
    }

  /* try re-shuffling the nodes to get what we want */

  for (i = 0;i < svr_totnodes;i++)
    {
    pnode = pbsndlist[i];

    if (pnode->nd_state & INUSE_DELETED)
      continue;

    if (pnode->nd_ntype == NTYPE_CLUSTER || pnode->nd_ntype == NTYPE_VIRTUAL
        || pnode->nd_ntype == NTYPE_CLOUD)
      {
      if (pnode->nd_flag != thinking)
        {
        /* only shuffle nodes which have been selected above */

        continue;
        }

      if (pnode->nd_state & pass)
        continue;

      if ((skip == SKIP_EXCLUSIVE) && (vpreq < pnode->nd_nsnfree))
        continue;

      if ((skip == SKIP_ANYINUSE) &&
          (vpreq < (pnode->nd_nsnfree + pnode->nd_nsnshared)))
        continue;

      if (!(hasprop(pnode, glorf, vpreq) || hasadprop(pnode, glorf)))
        continue;

      pnode->nd_flag = conflict;

      /* Ben Webb patch (CRI 10/06/03) */

      found = search(
                pnode->nd_first,
                pnode->nd_needed,
                skip,
                pnode->nd_order,
                depth);

      pnode->nd_flag = thinking;

      if (found)
        {
        mark(pnode, glorf);

        pnode->nd_needed = vpreq;
        pnode->nd_order  = order;

        /* SUCCESS */

        return(1);
        }
      }
    }    /* END for (i) */

  /* FAILURE */

  /* not found */

  return(0);
  }  /* END search() */





/*
** Parse a number in a spec.
** Return 0 if okay, 1 if no number exists, -1 on error
*/

static int number(

  char **ptr,
  int   *num)

  {
  char holder[80];
  int i = 0;
  char *str = *ptr;

  while (isdigit(*str) && (unsigned int)(i + 1) < sizeof holder)
    holder[i++] = *str++;

  if (i == 0)
    {
    return(1);
    }

  holder[i] = '\0';

  if ((i = atoi(holder)) <= 0)
    {
    sprintf(log_buffer, "zero illegal");

    return(-1);
    }

  *ptr = str;

  *num = i;

  return(0);
  }  /* END number() */




/*
** Check string to see if it is a legal property name.
** If not, return 1.
** *prop set to static char array containing the properity,
** must be copied.
*/

static int property(

  char **ptr,
  char **prop)

  {
  static char name[80];
  char* str = *ptr;
  int i = 0;

  if (!isalpha(*str))
    {
    sprintf(log_buffer,
            "first character of property (%s) not a letter",
            str);

    return(1);
    }

  while (isalnum(*str) || *str == '-' || *str == '.' || *str == '=' || *str == '_')
    name[i++] = *str++;

  name[i] = '\0';

  *prop = (i == 0) ? NULL : name;

  /* skip over "/vp_number" */

  if (*str == '/')
    {
    do
      {
      str++;
      }
    while (isdigit(*str));
    }

  *ptr = str;

  return(0);
  }  /* END property() */





/*
** Create a property list from a string.
** Return 0 if all is well, 1 otherwise.
*/

static int proplist(

  char  **str,
  struct prop **plist,
  int   *node_req)

  {

  struct prop *pp;
  char  *pname;
  char  *pequal;

  *node_req = 1; /* default to 1 processor per node */

  for (;;)
    {
    if (property(str, &pname))
      {
      return(1);
      }

    if (pname == NULL)
      break;

    if ((pequal = strchr(pname, (int)'=')) != NULL)
      {
      /* special property */

      /* identify the special property and place its value */
      /* into node_req       */

      *pequal = '\0';

      if (strcmp(pname, "ppn") == 0)
        {
        pequal++;

        if ((number(&pequal, node_req) != 0) || (*pequal != '\0'))
          {
          return(1);
          }
        }
      /* check if it is a known resource */
      else if (find_resc_def(svr_resc_def,pname,svr_resc_size) != NULL)
        {
        pequal++;

        pp = (struct prop *)malloc(sizeof(struct prop));
        pp->mark = 0; /* TODO for now resources are marked not to be checked */
        pp->name = strdup(pname);
        pp->value = strdup(pequal);
        pp->next = *plist;
        *plist = pp;
        }
      else
        {
        return(1); /* not recognized - error */
        }
      }
    else
      {
      pp = (struct prop *)malloc(sizeof(struct prop));

      pp->mark = 1;
      pp->name = strdup(pname);
      pp->value = NULL;
      pp->next = *plist;

      *plist = pp;
      }

    if (**str != ':')
      break;

    (*str)++;
    }  /* END for(;;) */

  return 0;
  }  /* END proplist() */

/** Recalculate real nodespec and total resources
 *
 * real nodespec   - nodespec containing all resources
 * total resources - total amount of counted resources
 */
void regenerate_total_resources(job * pjob)
  {
  pars_spec *spec = NULL;
  resource_def *rd;
  resource *rs;
  pars_spec_node *node = NULL;
  pars_prop *prop = NULL;
  int i, ret;

  /* Step (1)
   * - find nodespec and parse
   */
  if ((pjob->ji_wattr[(int)JOB_ATR_resource].at_flags & ATR_VFLAG_SET) != 0)
    {
    if ((rd = find_resc_def(svr_resc_def,"nodes",svr_resc_size)) == NULL)
      return;

    if ((rs = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_resource],rd)) == NULL)
      return;

    spec = parse_nodespec(rs->rs_value.at_val.at_str);
    }

  /* Step (2)
   * - free up previous total resources
   */
  /* cleanup any previous values */
  job_attr_def[(int)JOB_ATR_total_resources].
    at_free(&pjob->ji_wattr[(int)JOB_ATR_total_resources]);

  /* Step (3)
   * - go through normal resources
   */
  expand_nodespec(spec); /* expand the nodespec (add the global part into the local parts) */

  if ((pjob->ji_wattr[(int)JOB_ATR_resource].at_flags & ATR_VFLAG_SET) != 0)
    {
    resource *jbrc = (resource *)GET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);
    rd = jbrc->rs_defin;
    while (jbrc != NULL)
      {
      if ((rd->rs_flags & ATR_DFLAG_SELECT_MOM) || (rd->rs_flags & ATR_DFLAG_SELECT_PROC)) /* per proc or per node resource */
        { /* always add to nodespec */
        tlist_head head;
        svrattrl *patlist;
        CLEAR_HEAD(head);
        rd->rs_encode(&jbrc->rs_value,&head,"ignored",rd->rs_name,ATR_ENCODE_CLIENT);
        patlist = (svrattrl *)GET_NEXT(head);
        add_res_to_nodespec(spec,patlist->al_atopl.resource,patlist->al_atopl.value);
        free_attrlist(&head);
        }
      else
        { /* per job resource, if counted, add to total resources */
        switch (rd->rs_type)
          {
          case ATR_TYPE_LONG: case ATR_TYPE_LL: case ATR_TYPE_SHORT: case ATR_TYPE_SIZE:
            {
            if ((rs = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd)) == NULL)
              {
              rs = add_resource_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd);
              ret = rd->rs_set(&rs->rs_value,&jbrc->rs_value,SET);
              if (ret != 0)
                return;
              }
            else
              {
              ret = jbrc->rs_defin->rs_set(&rs->rs_value,&jbrc->rs_value,INCR);
              if (ret != 0)
                return;
              }
            }
          }
        }
      jbrc = (resource*)GET_NEXT(jbrc->rs_link);
      }
    }

  /* Step (4)
   * - construct the processed_nodes resource
   */
  if ((rd = find_resc_def(svr_resc_def,"processed_nodes",svr_resc_size)) != NULL)
    {
    if ((rs = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_resource],rd)) != NULL)
      {
      char *buf = concat_nodespec(spec);
      rd->rs_free(&rs->rs_value);
      rd->rs_decode(&rs->rs_value,NULL,NULL,buf);
      free(buf);
      }
    else
      {
      if ((rs = add_resource_entry(&pjob->ji_wattr[(int)JOB_ATR_resource],rd)) != NULL)
        {
        char *buf = concat_nodespec(spec);
        rd->rs_decode(&rs->rs_value,NULL,NULL,buf);
        free(buf);
        }
      }
    }

  /* Step (5)
   * - go through the parsed spec and add counted parts into the total resources
   */

  node = spec->nodes;
  while (node != NULL)
    {
    prop = node->properties;
    while (prop != NULL)
      {
      if (prop->value != NULL && (rd = find_resc_def(svr_resc_def,prop->name,svr_resc_size)) != NULL)
        {
        resource decoded;
        int total_count = 1;

        if ((rd->rs_flags & ATR_DFLAG_SELECT_MOM) != 0)
          total_count = node->node_count;
        if ((rd->rs_flags & ATR_DFLAG_SELECT_PROC) != 0)
          total_count = node->node_count * node->procs;

        switch (rd->rs_type)
          {
          case ATR_TYPE_LONG: case ATR_TYPE_LL: case ATR_TYPE_SHORT: case ATR_TYPE_SIZE:
            break;
          default: total_count = 0; break;
          }

        if (total_count == 0)
          continue;

        ret = rd->rs_decode(&decoded.rs_value,0,prop->name,prop->value);
        if (ret != 0)
          return;

        rs = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd);

        for (i = 0;i < total_count;i++)
          {
          if (rs == NULL)
            {
            rs = add_resource_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd);
            ret = rd->rs_set(&rs->rs_value,&decoded.rs_value,SET);
            if (ret != 0)
              return;
            continue;
            }

          ret = rd->rs_set(&rs->rs_value,&decoded.rs_value,INCR);
          if (ret != 0)
            return;
          }
        }
      prop = prop->next;
      }
    node = node->next;
    }

  /* Step (6)
   * - add procs and nodect
   */
    {
    char buf[128];
    attribute attr;

    /* find the definition and decode the value */
    rd = find_resc_def(svr_resc_def, "procs", svr_resc_size);
    sprintf(buf,"%d",spec->total_procs);
    rd->rs_decode(&attr,"procs","",buf);

    /* check if procs are present */
    rs = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd);
    if (rs == NULL)
      rs = add_resource_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd);

    ret = rd->rs_set(&rs->rs_value,&attr,SET);
    if (ret != 0)
      return;

    /* find the definition and decode the value */
    rd = find_resc_def(svr_resc_def, "nodect", svr_resc_size);
    sprintf(buf,"%d",spec->total_nodes);
    rd->rs_decode(&attr,"nodect","",buf);

    /* check if procs are present */
    rs = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd);
    if (rs == NULL)
      rs = add_resource_entry(&pjob->ji_wattr[(int)JOB_ATR_total_resources],rd);

    ret = rd->rs_set(&rs->rs_value,&attr,SET);
    if (ret != 0)
      return;
    }

  return;
  }


/*
 * Evaluate one element in a node spec.
 *
 * Return 1 if it can be satisfied
 *        0 if it cannot be completly satisfied. (not used now)
 *       -1 if error - can never be satisfied.
 */

static int listelem(

  char **str,
  int    order)

  {
  int num = 1;
  int i, hit;
  int ret = -1;

  struct prop *prop = NULL;

  struct pbsnode *pnode;
  int node_req = 1;

  if ((i = number(str, &num)) == -1) /* get number */
    {
    /* FAILURE */

    return(ret);
    }

  if (i == 0)
    {
    /* number exists */

    if (**str == ':')
      {
      /* there are properties */

      (*str)++;

      if (proplist(str, &prop, &node_req))
        {
        return(ret);
        }
      }
    }
  else
    {
    /* no number */

    if (proplist(str, &prop, &node_req))
      {
      /* must be a prop list with no number in front */

      return(ret);
      }
    }

  /* count number of nodes with the requested property */

  hit = 0;

  for (i = 0;i < svr_totnodes;i++)
    {
    pnode = pbsndlist[i];

    if (pnode->nd_state & INUSE_DELETED)
      continue;

    if (pnode->nd_ntype == NTYPE_CLUSTER || pnode->nd_ntype == NTYPE_VIRTUAL
        || pnode->nd_ntype == NTYPE_CLOUD)
      {
      if ((hasprop(pnode, prop, node_req) || hasadprop(pnode, prop)) && hasppn(pnode, node_req, SKIP_NONE))
        hit++;

      if (hit == num)
        {
        break;  /* found enough  */
        }
      }
    }    /* END for (i) */

  if (hit < num)
    {
    /* request exceeds configured nodes */

    if ((SvrNodeCt == 0) || (SvrNodeCt < num))
      {
      /* request exceeds server resources_available */

      /* request can never be satisfied */

      goto done;
      }
    }

  /*
  ** Find an initial set of nodes to satisfy the request.
  ** Go ahead and use any nodes no matter what state they are in.
  */

  /* NOTE:  SKIP_NONE_REUSE will not mark nodes as inuse, ie allow node re-use */

  for (i = 0;i < num;i++)
    {
    if (SvrNodeCt == 0)
      {
      if (search(prop, node_req, SKIP_NONE, order, 0))
        continue;
      }
    else
      {
      if (search(prop, node_req, SKIP_NONE_REUSE, order, 0))
        continue;
      }

    /* can never be satisfied */

    goto done;
    }

  ret = 1;

done:

  free_prop(prop);

  return(ret);
  }  /* END listelem() */


/* cntjons - count jobs on (shared) nodes */

static int cntjons(

  struct pbsnode *pn)

  {

  struct pbssubn *psn;
  int ct = 0;
  int n;

  struct jobinfo *pj;

  psn = pn->nd_psn;

  for (n = 0;n < pn->nd_nsn;++n)
    {
    pj = psn->jobs;

    while (pj)
      {
      ++ct;

      pj = pj->next;
      }

    psn = psn->next;
    }

  return(ct);
  }




/*
 * nodecmp - compare two nodes for sorting
 * For "exclusive", depending on setting of node_order attribute:
 *     pack:    put free node with fewest non-zero free VPs in node first
 *     scatter: put free node with most fre VPs first
 * For "shared", put current shared with fewest jobs first,
 *  then free nodes, and others last
 */


#define BIG_NUM 32768 /* used only in nodecmp() */

static int nodecmp(

  const void *aa,
  const void *bb)

  {

  struct pbsnode *a = *(struct pbsnode **)aa;

  struct pbsnode *b = *(struct pbsnode **)bb;
  int aprim, bprim;

  /* exclusive is global */

  if (exclusive)
    {
    /* best is free */

    if (server.sv_attr[(int)SRV_ATR_NodePack].at_val.at_long)
      {
      /* pack - fill up nodes first */

      aprim = (a->nd_nsnfree > 0) ? a->nd_nsnfree : BIG_NUM;

      bprim = (b->nd_nsnfree > 0) ? b->nd_nsnfree : BIG_NUM;
      }
    else
      {
      /* scatter - spread amoung nodes first */

      aprim = a->nd_nsn - a->nd_nsnfree;
      bprim = b->nd_nsn - b->nd_nsnfree;
      }
    }
  else
    {
    /* best is shared with fewest jobs */

    aprim = (a->nd_state == INUSE_JOBSHARE) ?
            cntjons(a) :
            ((a->nd_state == INUSE_FREE) ? 5 : 1000);

    bprim = (b->nd_state == INUSE_JOBSHARE) ?
            cntjons(b) :
            ((b->nd_state == INUSE_FREE) ? 5 : 1000);
    }

  if (aprim == bprim)
    {
    return(a->nd_nprops - b->nd_nprops);
    }

  return (aprim - bprim);
  }  /* END nodecmp() */




int MSNPrintF(

  char **BPtr,   /* I */
  int   *BSpace, /* I */
  char  *Format, /* I */
  ...)           /* I */

  {
  int len;

  va_list Args;

  if ((BPtr == NULL) ||
      (BSpace == NULL) ||
      (Format == NULL) ||
      (*BSpace <= 0))
    {
    return(FAILURE);
    }

  va_start(Args,Format);

  len = vsnprintf(*BPtr,*BSpace,Format,Args);

  va_end(Args);

  if (len <= 0)
    {
    return(FAILURE);
    }
  
  if (len >= *BSpace)
    {
    /* truncation occurred due to attempted
     * overflow! */

    /* do not place BPtr past the end of the buffer:
     * it is too dangerous (calling function could derference it
     * to check for empty string, etc.)! */

    *BPtr += (*BSpace) - 1;
    *BSpace = 0;

    return(FAILURE);
    }
  
  *BPtr += len;
  *BSpace -= len;

  return(SUCCESS);
  }  /* END MSNPrintF() */


/** Count the parts in a nodespec
 *
 * (Only works for local specs)
 *
 * @param spec Nodespec to parse
 * @return Count of parts
 */
static int nodespec_part_count(const char *spec)
  {
  int result = 1;

  dbg_precondition(spec != NULL, "This function does not accept NULL");

  while (*spec != '\0')
    {
    if (*spec == '+')
      result++;
    spec++;
    }

  return result;
  }

/** Append requirements to each part of a spec
 *
 * @param spec the spec to be modified
 * @param app requirements to be appended
 * @return Modified nodespec
 */
static char *nodespec_app(const char *spec, const char *app)
  {
  char *cp;
  char *result;

  result = malloc(nodespec_part_count(spec) * (strlen(app) + 1) + strlen(spec) + 1);
  if (result == NULL) /* alloc fail */
    return NULL;

  cp = result;

  while (*spec)
    {
    if (*spec == '+') /* add the requirements before each '+' */
      {
      *cp++ = ':';

      strcpy(cp, app);

      cp += strlen(app);
      }

    *cp++ = *spec++;
    }

  *cp++ = ':'; /* and also after the last part of the spec */

  strcpy(cp, app);

  return(result);
  }  /* END nodespec_app() */

/** Expand nodespec
 *
 * Add the global nodespec part to local parts of nodespec and determine exclusivity.
 *
 * @param spec The spec to be parsed
 * @param exclusive 0 if shared, 1 if exclusive, 2 if node exclusive
 * @return NULL on failure or allocated modified spec
 */
static char *nodespec_expand(job *pjob, const char *spec, int *exclusive)
  {
  char *result, *globs, *cp, *tmp;
  static char shared[] = "shared"; /* shared */
  static char excl[] = "excl"; /* node exclusive */

  result = strdup(spec);
  if (result == NULL) /* alloc failure */
    return NULL;

  if ((globs = strchr(result, '#')) != NULL)
    /*find the first #, everything behind is global nodespec */
    {
    *globs++ = '\0';

    globs = strdup(globs);
    if (globs == NULL) /* alloc failure */
      goto fail;

    /* glob now stores the global part of the nodespec
     * - go thru each part of the global spec and append
     */
    while ((cp = strrchr(globs, '#')) != NULL)
      {
      *cp++ = '\0';

      if (!strcmp(cp, shared)) /* #shared */
        {
        *exclusive = 0;
        continue;
        }

      if (!strcmp(cp, excl)) /* #excl */
        {
        *exclusive = 1;
        continue;
        }

      tmp = nodespec_app(result, cp);
      if (tmp == NULL) /* alloc failure */
        {
        free(globs);
        goto fail;
        }

      free(result);
      result = tmp;
      }

    /* now parse the first part of the global nodespec */
    if (!strcmp(globs, shared)) /* #shared */
      {
      *exclusive = 0;
      free(globs);
      goto done_stage1;
      }

    if (!strcmp(globs, excl)) /* #excl */
      {
      *exclusive = 2; /* node exclusive */
      free(globs);
      goto done_stage1;
      }

    tmp = nodespec_app(result, globs);
    if (tmp == NULL) /* alloc failure */
      {
      free(globs);
      goto fail;
      }

    free(result);
    result = tmp;

    free(globs);
    }  /* END if ((globs = strchr(spec,'#')) != NULL) */

done_stage1:

  /* if job is provided, also add each of the requested resources in the job resource list */
  if (pjob != NULL && (pjob->ji_wattr[(int)JOB_ATR_resource].at_flags & ATR_VFLAG_SET) != 0)
    {
    resource *jbrc = (resource *)GET_NEXT(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);

    while (jbrc != NULL)
      {
      tlist_head head;
      svrattrl *patlist;
      char     *buff, *tmp;
      int       len;

      /* only add resources that are per-proc or per-node */
      if ((jbrc->rs_defin->rs_flags & (ATR_DFLAG_SELECT_MOM | ATR_DFLAG_SELECT_PROC)) == 0)
        {
        jbrc = (resource *)GET_NEXT(jbrc->rs_link);
        continue;
        }

      /* convert resource into char* */
      CLEAR_HEAD(head);
      jbrc->rs_defin->rs_encode(&jbrc->rs_value,&head,"ignored",
            jbrc->rs_defin->rs_name,ATR_ENCODE_CLIENT);
      patlist = (svrattrl *)GET_NEXT(head);

      if (patlist == NULL)
        goto fail;

      len  = strlen(patlist->al_atopl.resource);
      len += strlen(patlist->al_atopl.value);
      len += 2; /* '=' and '\0' */
      buff = malloc(len);

      if (buff == NULL)
        goto fail;

      sprintf(buff,"%s=%s",patlist->al_atopl.resource,patlist->al_atopl.value);

      /* append to each part of the nodespec */
      tmp = nodespec_app(result, buff);
      if (tmp == NULL)
        goto fail;

      free(buff);
      free(result);
      result = tmp;

      jbrc = (resource *)GET_NEXT(jbrc->rs_link);
      }
    }

  return result;

fail:
  free(result);
  return NULL;
  }


/*
 * Test a node specification.
 *
 * Return >0 - number of nodes counted in the spec if it works,
 *         0 - if it cannot be satisfied,
 *        -1 - if it can never be satisfied.
 * Okay to bail early if "early" is true.
 * VPs selected are marked "thinking"
 */

static int node_spec(

  char  *spec,       /* I */
  int    early,      /* I (boolean) */
  int    exactmatch, /* I (boolean) - NOT USED */
  char  *ProcBMStr,  /* I */
  job   *pjob,       /* O (optional) */
  char  *FailNode,   /* O (optional,minsize=1024) */
  char  *EMsg)       /* O (optional,minsize=1024) */

  {
  static char id[] = "node_spec";

  struct pbsnode *pnode;

  struct pbssubn *snp;
  char *str;
  int  i, num;
  int  rv;

  extern int PNodeStateToString(int, char *, int);

  if (EMsg != NULL)
    EMsg[0] = '\0';

  if (FailNode != NULL)
    FailNode[0] = '\0';

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer, "entered spec=%.4000s", spec);
    log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buffer);
    DBPRT(("%s\n", log_buffer));
    }

  exclusive = 1; /* by default, nodes (VPs) are requested exclusively */
  /* expand the global reqs into the local parts */
  spec = nodespec_expand(pjob, spec,&exclusive);

  if (pjob != NULL) /* store the expanded nodespec */
    {
    if (pjob->ji_expanded_spec != NULL)
      free(pjob->ji_expanded_spec);
    pjob->ji_expanded_spec = strdup(spec);
    }

  if (spec == NULL) /* memory alloc fail */
    {
    sprintf(log_buffer,"cannot alloc memory");
    if (LOGLEVEL >= 1)
      log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buffer);

    if (EMsg != NULL)
      strncpy(EMsg,log_buffer,1024);

    return(-1);
    }

  str = spec;
  /* count total nodes in the request */
  num = ctnodes(str);

  if (num > svr_clnodes) /* the request is for more nodes then the server has */
    {
    free(spec);

    sprintf(log_buffer, "job allocation request exceeds available cluster"
            " nodes, %d requested, %d available", num, svr_clnodes);

    if (LOGLEVEL >= 6)
      log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buffer);

    if (EMsg != NULL)
      strncpy(EMsg, log_buffer, 1024);

    return(-1);
    }

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer, "job allocation debug: %d requested, %d svr_clnodes,"
            " %d svr_totnodes", num, svr_clnodes, svr_totnodes);

    log_record(PBSEVENT_SCHED, PBS_EVENTCLASS_REQUEST, id, log_buffer);

    DBPRT(("%s\n", log_buffer));
    }

  /*
   * if SRV_ATR_NodePack set (true or false), then
   * sort nodes by state, number of VPs and number of attributes;
   * otherwise, leave unsorted
   */

  if (server.sv_attr[(int)SRV_ATR_NodePack].at_flags & ATR_VFLAG_SET)
    {
    qsort(pbsndlist, svr_totnodes, sizeof(struct pbsnode *), nodecmp);
    }

  /* reset subnodes (VPs) to okay */

  svr_numnodes = 0;

  svr_numcfgnodes = 0;

  for (i = 0;i < svr_totnodes;i++)
    {
    pnode = pbsndlist[i];

    if (pnode->nd_state & INUSE_DELETED)
      continue;

#ifdef GEOMETRY_REQUESTS
    /* must be dedicated node use for cpusets */
    if (IS_VALID_STR(ProcBMStr)) 
      {
      if (pnode->nd_state != INUSE_FREE)
        continue;

      if (node_satisfies_request(pnode,ProcBMStr) == FALSE)
        continue;
      }
#endif /* GEOMETRY_REQUESTS */

    if (LOGLEVEL >= 6)
      {
      DBPRT(("%s: %s nsn %d, nsnfree %d, nsnshared %d\n",
             id,
             pnode->nd_name,
             pnode->nd_nsn,
             pnode->nd_nsnfree,
             pnode->nd_nsnshared))
      }

    pnode->nd_flag   = okay;

    pnode->nd_needed = 0;

    for (snp = pnode->nd_psn;snp != NULL;snp = snp->next)
      {
      snp->flag = okay;

      if (LOGLEVEL >= 6)
        {
        DBPRT(("%s: %s/%d inuse 0x%x nprops %d\n",
               id,
               pnode->nd_name,
               snp->index,
               snp->inuse,
               pnode->nd_nprops))
        }
      }

    if (pnode->nd_ntype == NTYPE_CLUSTER || pnode->nd_ntype == NTYPE_VIRTUAL
        || pnode->nd_ntype == NTYPE_CLOUD)
      {
      /* configured node located */

      svr_numcfgnodes++;

      if ((pnode->nd_state & (INUSE_OFFLINE | INUSE_DOWN | INUSE_RESERVE | INUSE_JOB)) == 0)
        {
        /* NOTE:  checking if node is not just up, but free */

        /* available node located */

        svr_numnodes++;
        }
      }
    }    /* END for (i = 0) */

  /*
   * Make first pass at finding nodes to allocate.
   * process each subspec (piece between '+'s)
   */

  for (i = 1;;i++)
    {
    if ((rv = listelem(&str, i)) <= 0)
      {
      free(spec);

      return(rv);
      }

    if (*str != '+')
      break;

    str++;
    }  /* END for (i) */

  i = (int) * str;

  free(spec);

  if (i != 0)     /* garbled list */
    {
    /* FAILURE */

    sprintf(log_buffer, "job allocation request is corrupt");

    if (LOGLEVEL >= 6)
      {
      log_record(
        PBSEVENT_SCHED,
        PBS_EVENTCLASS_REQUEST,
        id,
        log_buffer);
      }

    if (EMsg != NULL)
      {
      strncpy(EMsg, log_buffer, 1024);
      }

    return(-1);
    }

  if ((num > svr_numnodes) && early) /* temp fail, not available */
    {
    /* FAILURE */

    sprintf(log_buffer, "job allocation request exceeds currently available cluster nodes, %d requested, %d available",
            num,
            svr_numnodes);

    if (LOGLEVEL >= 6)
      {
      log_record(
        PBSEVENT_SCHED,
        PBS_EVENTCLASS_REQUEST,
        id,
        log_buffer);
      }

    if (EMsg != NULL)
      {
      strncpy(EMsg, log_buffer, 1024);
      }

    return(0);
    }  /* END if ((num > svr_numnodes) && early) */

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer, "job allocation debug(2): %d requested, %d svr_numnodes",
            num,
            svr_numnodes);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);

    DBPRT(("%s\n",
           log_buffer));
    }

  /*
   *  At this point we know the spec is legal.
   * Here we find a replacement for any nodes chosen above
   * that are already inuse.
   */

  for (i = 0;i < svr_totnodes;i++)
    {
    pnode = pbsndlist[i];

    if (pnode->nd_state & INUSE_DELETED)
      continue;

    if (pnode->nd_ntype != NTYPE_CLUSTER && pnode->nd_ntype != NTYPE_VIRTUAL
        && pnode->nd_ntype != NTYPE_CLOUD)
      {
      /* node is ok */

      continue;
      }

    if (pnode->nd_flag != thinking)  /* thinking is global */
      {
      /* node is ok */

      continue;
      }

    if (pnode->nd_state == INUSE_FREE)
      {
      if (pnode->nd_needed <= pnode->nd_nsnfree)
        {
        /* adequate virtual nodes available - node is ok */

        continue;
        }

      if (!exclusive &&
          (pnode->nd_needed < pnode->nd_nsnfree + pnode->nd_nsnshared))
        {
        /* shared node - node is ok */

        continue;
        }
      }
    else
      {
      if (!exclusive &&
          (pnode->nd_needed <= pnode->nd_nsnfree + pnode->nd_nsnshared))
        {
        /* shared node - node is ok */

        continue;
        }
      }

    /* otherwise find replacement node */

    /* Ben Webb search patch applied (CRI 10/03/03) */

    pnode->nd_flag = okay;

    if (search(
          pnode->nd_first,
          pnode->nd_needed,
          (exclusive != 0) ? SKIP_ANYINUSE : SKIP_EXCLUSIVE,
          pnode->nd_order,
          0))
      {
      /* node is ok */

      continue;
      }

    if (early != 0)
      {
      /* FAILURE */

      /* specified node not available and replacement cannot be located */

      if (pnode->nd_needed > pnode->nd_nsnfree)
        {
        char JobList[1024];

        struct pbssubn *np;

        struct jobinfo *jp;

        char   *BPtr;
        int     BSpace;

        int     nindex;

        JobList[0] = '\0';

        BPtr = JobList;
        BSpace = sizeof(JobList);

        /* scheduler and pbs_server disagree on np availability - report current allocation */

        /* show allocating jobs */

        /* examine all subnodes in node */

        nindex = 0;

        for (np = pnode->nd_psn;np != NULL;np = np->next)
          {
          /* examine all jobs allocated to subnode */

          for (jp = np->jobs;jp != NULL;jp = jp->next)
            {
            MSNPrintF(&BPtr, &BSpace, "%s%s:%d",
                      (JobList[0] != '\0') ? "," : "",
                      (jp->job != NULL) ? jp->job->ji_qs.ji_jobid : "???",
                      nindex);
            }

          nindex++;
          }  /* END for (np) */

        snprintf(log_buffer, sizeof(log_buffer), "cannot allocate node '%s' to job - node not currently available (nps needed/free: %d/%d,  joblist: %s)",
                 pnode->nd_name,
                 pnode->nd_needed,
                 pnode->nd_nsnfree,
                 JobList);

#ifdef BROKENVNODECHECKS
        /* NOTE:  hack - should be moved to update node state */

        if (JobList[0] == '\0')
          {
          pnode->nd_nsnfree = pnode->nd_nsn;
          }

#endif
        }
      else
        {
        char NodeState[1024];

        PNodeStateToString(pnode->nd_state, NodeState, sizeof(NodeState));

        sprintf(log_buffer, "cannot allocate node '%s' to job - node not currently available (state: %s)",
                pnode->nd_name,
                NodeState);
        }

      if (LOGLEVEL >= 6)
        {
        log_record(
          PBSEVENT_SCHED,
          PBS_EVENTCLASS_REQUEST,
          id,
          log_buffer);
        }

      if (EMsg != NULL)
        {
        strncpy(EMsg, log_buffer, 1024);
        }

      if (FailNode != NULL)
        strncpy(FailNode, pnode->nd_name, 1024);

      return(0);
      }  /* END if (early != 0) */

    num = 0;
    }  /* END for (i) */

  /* SUCCESS - spec is ok */

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer, "job allocation debug(3): returning %d requested",
            num);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);

    DBPRT(("%s\n",
           log_buffer));
    }

  return(num);
  }  /* END node_spec() */




#ifdef GEOMETRY_REQUESTS
/**
 * get_bitmap
 *
 * @param pjob (I) - the job whose bitmap is be retrieved
 * @param ProcBMPtr (O) - the ptr to the string where the bitmap will be stored
 * @param ProcBMSize (I) - the size of the string ProcBMPtr points to
 * @return FAILURE if there is no specified bitmap or either pjob or ProcBMStrPtr are NULL
 * @return SUCCESS otherwise
 */
int get_bitmap(

  job  *pjob,        /* I */
  int   ProcBMSize,  /* I */
  char *ProcBMPtr)   /* O */

  {
  resource     *presc;
  resource_def *prd;

  char          LocalBM[MAX_BM];

  if ((pjob == NULL) ||
      (ProcBMPtr == NULL))
    {
    return(FAILURE);
    }

  LocalBM[0] = '\0';

  /* read the bitmap from the resource list */
  prd = find_resc_def(svr_resc_def,"procs_bitmap",svr_resc_size);
  presc = find_resc_entry(&pjob->ji_wattr[(int)JOB_ATR_resource],prd);
  
  if ((presc != NULL) && 
      (presc->rs_value.at_flags & ATR_VFLAG_SET))
    {
    snprintf(LocalBM,sizeof(LocalBM),"%s",presc->rs_value.at_val.at_str);
    }
  else
    {
    /* fail if there was no bitmap given */

    return(FAILURE);
    }

  if (LocalBM[0] == '\0')
    {
    /* fail if there was no bitmap given */

    return(FAILURE);
    }
  else
    {
    snprintf(ProcBMPtr,sizeof(LocalBM),"%s",LocalBM);
    return(SUCCESS);
    }
  } /* end get_bitmap() */




/**
 * node_satisfies_request
 *
 * @param pnode (I) - the node to check for validity
 * @param ProcBMStr (I) - the bitmap of procs requested
 * @return TRUE - if the node satisfies the bitmap, FALSE otherwise
 * @return BM_ERROR if the bitmap isn't valid
 */
int node_satisfies_request(

  struct pbsnode *pnode,     /* I */
  char           *ProcBMStr) /* I */

  {
  int BMLen;
  int BMIndex;

  struct pbssubn *snp; 

  if (IS_VALID_STR(ProcBMStr) == FALSE)
    return(BM_ERROR);

  /* nodes are exclusive when we're using bitmaps */
  if (pnode->nd_state != INUSE_FREE)
    return(FALSE);

  BMLen = strlen(ProcBMStr);

  /* process in reverse because ProcBMStr[0] referes to core index 0 */
  BMIndex = BMLen-1;

  /* check if the requested processors are available on this node */
  for (snp = pnode->nd_psn;snp && BMIndex >= 0;snp = snp->next)
    {
    /* don't check cores that aren't requested */
    if (ProcBMStr[BMIndex--] != '1')
      continue;

    /* cannot use this node, one of the requested cores is busy */
    if (snp->inuse != INUSE_FREE)
      return(FALSE);
    }

  if (BMIndex >= 0)
    {
    /* this means we didn't finish checking the string -
     * the node doesn't have enough processors */

    return(FALSE);
    }

  /* passed all checks, we're good */
  return(TRUE);
  } /* END node_satisfies_request() */




/**
 * reserve_node
 *
 * @param pnode - node to reserve
 * @param pjob - the job to be added to the node
 * @param hlistptr - a pointer to the host list 
 */

int reserve_node(

  struct pbsnode  *pnode,     /* I/O */
  short            newstate,  /* I */
  job             *pjob,      /* I */
  char            *ProcBMStr, /* I */
  struct howl    **hlistptr)  /* O */

  {
  int BMLen;
  int BMIndex;

  struct pbssubn *snp; 

  if ((pnode == NULL) ||
      (pjob == NULL) ||
      (hlistptr == NULL))
    {
    return(FAILURE);
    }

  BMLen = strlen(ProcBMStr);
  BMIndex = BMLen-1;

  /* now reserve each node */
  for (snp = pnode->nd_psn;snp && BMIndex >= 0;snp = snp->next)
    {
    /* ignore unrequested cores */
    if (ProcBMStr[BMIndex--] != '1')
      continue;

    add_job_to_node(pnode,snp,INUSE_JOB,pjob,exclusive);

    build_host_list(hlistptr,snp,pnode);
    }
  
  /* mark the node as exclusive */
  pnode->nd_state = INUSE_JOB;

  return(SUCCESS);
  }
#endif /* GEOMETRY_REQUESTS */


/**
 * adds this job to the node's list of jobs
 * checks to be sure not to add duplicates
 *
 * conditionally updates the subnode's state
 * decrements the amount of needed nodes
 *
 * @param pnode - the node that the job is running on
 * @param nd_psn - the subnode (processor) that the job is running on
 * @param newstate - the state nodes are transitioning to when used
 * @param pjob - the job that is going to be run
 * @param exclusive - TRUE if jobs are given exclusive node use, FALSE otherwise
 */
int add_job_to_node(

  struct pbsnode *pnode,     /* I/O */
  struct pbssubn *snp,       /* I/O */
  short           newstate,  /* I */
  job            *pjob,      /* I */
  int             exclusive, /* I */
  int             first)

  {
  char *id = "add_job_to_node";
  struct jobinfo *jp;

  /* NOTE:  search existing job array.  add job only if job not already in place */
  if (LOGLEVEL >= 5)
    {
    sprintf(log_buffer, "allocated node %s/%d to job %s (nsnfree=%d)",
      pnode->nd_name,
      snp->index,
      pjob->ji_qs.ji_jobid,
      pnode->nd_nsnfree);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    DBPRT(("%s\n", log_buffer));
    }

  if (exclusive == 2) /* node exclusive job */
    {
    pnode->nd_exclusive = 1;
    }

  for (jp = snp->jobs;jp != NULL;jp = jp->next)
    {
    if (jp->job == pjob)
      break;
    }

  if (jp == NULL)
    {
    /* add job to front of subnode job array */

    jp = (struct jobinfo *)malloc(sizeof(struct jobinfo));
    jp->next = snp->jobs;
    snp->jobs = jp;
    jp->job = pjob;
    jp->order = pnode->nd_order;

    pnode->nd_nsnfree--;            /* reduce free count */
    adjust_resources_use(pnode,jp,first,INCR);

    /* if no free VPs, set node state */
    if (pnode->nd_nsnfree <= 0)
      pnode->nd_state = newstate;

    if (snp->inuse == INUSE_FREE)
      {
      snp->inuse = newstate;

      if (!exclusive)
        pnode->nd_nsnshared++;
      }
    }

  /* decrement the amount of nodes needed */
  --pnode->nd_needed;

  return(SUCCESS);
  }



/**
 * builds the host list (hlist)
 *
 * @param pnode - the node being added to the host list
 * @param hlist - the host list being built
 */ 
int build_host_list(

  struct howl    **hlistptr,  /* O */
  struct pbssubn  *snp,       /* I */
  struct pbsnode  *pnode)     /* I */
  
  {
  struct howl *curr;
  struct howl *prev;
  struct howl *hp;

  /* initialize the pointers */
  curr = (struct howl *)malloc(sizeof(struct howl));
  curr->order = pnode->nd_order;
  curr->name  = pnode->nd_name;
  curr->index = snp->index;

  /* find the proper place in the list */
  for (prev = NULL, hp = *hlistptr;hp;prev = hp, hp = hp->next)
    {
    if (curr->order <= hp->order)
      break;
    }  /* END for (prev) */

  /* set the correct pointers in the list */
  curr->next = hp;

  if (prev == NULL)
    *hlistptr = curr;
  else
    prev->next = curr;

  return(SUCCESS);
  }




/*
 * set_nodes() - Call node_spec() to allocate nodes then set them inuse.
 * Build list of allocated nodes to pass back in rtnlist.
 *      Return: PBS error code
 */

int set_nodes(

  job   *pjob,      /* I */
  char *spec,      /* I */
  char **rtnlist,   /* O */
  char  *FailHost,  /* O (optional,minsize=1024) */
  char  *EMsg)      /* O (optional,minsize=1024) */

  {

  struct howl *hp;
  struct howl *hlist;
  struct howl *nxt;

  int     i;
  short   newstate;

  int     NCount;

  static char *id = "set_nodes";

  struct pbsnode *pnode;

  struct pbssubn *snp;
  char           *nodelist;

  char   ProcBMStr[MAX_BM];

  int    first;

  if (FailHost != NULL)
    FailHost[0] = '\0';

  if (EMsg != NULL)
    EMsg[0] = '\0';

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer, "allocating nodes for job %s with node expression '%.4000s'",
      pjob->ji_qs.ji_jobid,
      spec);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

  ProcBMStr[0] = '\0';
#ifdef GEOMETRY_REQUESTS
  get_bitmap(pjob,sizeof(ProcBMStr),ProcBMStr);
#endif /* GEOMETRY_REQUESTS */

  /* allocate nodes */

  if ((i = node_spec(spec, 1, 1, ProcBMStr, pjob, FailHost, EMsg)) == 0) /* check spec */
    {
    /* no resources located, request failed */

    if (EMsg != NULL)
      {
      sprintf(log_buffer, "could not locate requested resources '%.4000s' (node_spec failed) %s",
        spec,
        EMsg);

      log_record(
        PBSEVENT_JOB,
        PBS_EVENTCLASS_JOB,
        pjob->ji_qs.ji_jobid,
        log_buffer);
      }

    return(PBSE_RESCUNAV);
    }

  if (i < 0)
    {
    /* request failed, corrupt request */

    return(PBSE_UNKNODE);
    }

  /* i indicates number of matching nodes */

  if (exclusive)        /* exclusive is global */
    svr_numnodes -= i;

  hlist = NULL;

  newstate = exclusive ? INUSE_JOB : INUSE_JOBSHARE;

  for (i = 0;i < svr_totnodes;i++)
    {

    pnode = pbsndlist[i];

    if (pnode->nd_state & INUSE_DELETED)
      continue;

    if (pnode->nd_flag != thinking)
      {
      /* node is not considered/eligible for job - see search() */

      /* skip node */

      continue;
      }

    /* within the node, check each subnode */
#ifdef GEOMETRY_REQUESTS
    if (ProcBMStr[0] != '\0')
      {
      /* check node here, a request was given */
      if (node_satisfies_request(pnode,ProcBMStr) == TRUE)
        {
        reserve_node(pnode,newstate,pjob,ProcBMStr,&hlist);
        }

      continue;
      }
#endif /* GEOMETRY_REQUESTS */

    first = 1;
    for (snp = pnode->nd_psn;snp && pnode->nd_needed;snp = snp->next)
      {
      if (exclusive)
        {
        if (snp->inuse != INUSE_FREE)
          continue;
        }
      else
        {
        if ((snp->inuse != INUSE_FREE) && (snp->inuse != INUSE_JOBSHARE))
          continue;
        }

      /* Mark subnode as being IN USE */

      add_job_to_node(pnode,snp,newstate,pjob,exclusive,first);
      first = 0;
  
      build_host_list(&hlist,snp,pnode);
      }  /* END for (snp) */

    }    /* END for (i) */

  if (hlist == NULL)
    {
    if (LOGLEVEL >= 1)
      {
      sprintf(log_buffer, "no nodes can be allocated to job %s",
        pjob->ji_qs.ji_jobid);

      log_record(
        PBSEVENT_SCHED,
        PBS_EVENTCLASS_REQUEST,
        id,
        log_buffer);
      }

    if (EMsg != NULL)
      sprintf(EMsg, "no nodes can be allocated to job");

    return(PBSE_RESCUNAV);
    }  /* END if (hlist == NULL) */

  pjob->ji_qs.ji_svrflags |= JOB_SVFLG_HasNodes;  /* indicate has nodes */

  /* build list of allocated nodes */

  i = 1;  /* first, size list */

  for (hp = hlist;hp != NULL;hp = hp->next)
    {
    i += (strlen(hp->name) + 6);
    }

  nodelist = malloc(++i);

  if (nodelist == NULL)
    {
    sprintf(log_buffer, "no nodes can be allocated to job %s - no memory",
      pjob->ji_qs.ji_jobid);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);

    if (EMsg != NULL)
      sprintf(EMsg,"no nodes can be allocated to job");

    return(PBSE_RESCUNAV);
    }

  *nodelist = '\0';

  /* now copy in name+name+... */

  NCount = 0;

  for (hp = hlist;hp;hp = nxt)
    {
    NCount++;

    sprintf(nodelist + strlen(nodelist), "%s/%d+",
      hp->name,
      hp->index);

    nxt = hp->next;

    free(hp);
    }

  *(nodelist + strlen(nodelist) - 1) = '\0'; /* strip trailing + */

  *rtnlist = nodelist;

  if (LOGLEVEL >= 3)
    {
    snprintf(log_buffer, sizeof(log_buffer), "job %s allocated %d nodes (nodelist=%.4000s)",
      pjob->ji_qs.ji_jobid,
      NCount,
      nodelist);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

  /* SUCCESS */

  return(PBSE_NONE);
  }  /* END set_nodes() */





/*
 * node_avail_complex -
 * *navail is set to number available
 * *nalloc is set to number allocated
 * *nresvd is set to number reserved
 * *ndown  is set to number down/offline
 *      return -1 on failure
 */

int node_avail_complex(

  char *spec,  /* I - node spec */
  int  *navail, /* O - number available */
  int *nalloc, /* O - number allocated */
  int *nresvd, /* O - number reserved  */
  int *ndown)  /* O - number down      */

  {
  int holdnum;
  int ret;

  holdnum = svr_numnodes;

  ret = node_spec(spec, 1, 0, NULL, NULL, NULL, NULL);

  svr_numnodes = holdnum;

  *navail = ret;
  *nalloc = 0;
  *nresvd = 0;
  *ndown  = 0;

  return(ret);
  }  /* END node_avail_complex() */





/*
 * node_avail - report if nodes requested are available
 * Does NOT even consider Time Shared Nodes
 *
 * Return 0 when no error in request and
 *  *navail is set to number available
 *  *nalloc is set to number allocated
 *  *nresvd is set to number reserved
 *  *ndown  is set to number down/offline
 *      !=0 error number when error in request
 */

int node_avail(

  char *spec,  /* I  - node spec */
  int  *navail, /* O - number available */
  int *nalloc, /* O - number allocated */
  int *nresvd, /* O - number reserved  */
  int *ndown)  /* O - number down      */

  {
  char *id = "node_avail";
  int i;
  int j;
  int holdnum;

  struct pbsnode *pn;

  struct  pbssubn *psn;
  char    *pc;

  struct prop *prop = NULL;
  register int xavail;
  register int xalloc;
  register int xresvd;
  register int xdown;
  int          node_req = 1;

  if (spec == NULL)
    {
    log_event(PBSEVENT_ADMIN, PBS_EVENTCLASS_SERVER, id, "no spec");

    return(RM_ERR_NOPARAM);
    }

  pc = spec;

  if ((strchr(spec, (int)'+') == NULL) && (number(&pc, &holdnum) == 1))
    {
    /* A simple node spec - reply with numbers of avaiable, */
    /* allocated, reserved, and down nodes that match the */
    /* the spec, null or simple number means all  */

    xavail = 0;
    xalloc = 0;
    xresvd = 0;
    xdown  = 0;

    /* find number of a specific type of node */

    if (*pc)
      {
      if (proplist(&pc, &prop, &node_req))
        {
        return(RM_ERR_BADPARAM);
        }
      }

    for (i = 0;i < svr_totnodes;i++)
      {
      pn = pbsndlist[i];

      if (pn->nd_state & INUSE_DELETED)
        continue;

      if ((pn->nd_ntype == NTYPE_CLUSTER || pn->nd_ntype == NTYPE_VIRTUAL
          || pn->nd_ntype == NTYPE_CLOUD) && (hasprop(pn, prop, node_req) || hasadprop(pn, prop)))
        {
        if (pn->nd_state & (INUSE_OFFLINE | INUSE_DOWN))
          ++xdown;
        else if (hasppn(pn, node_req, SKIP_ANYINUSE))
          ++xavail;
        else if (hasppn(pn, node_req, SKIP_NONE))
          {
          /* node has enough processors, are they busy or reserved? */

          j = 0;

          for (psn = pn->nd_psn;psn;psn = psn->next)
            {
            if (psn->inuse & INUSE_RESERVE)
              j++;
            }

          if (j >= node_req)
            ++xresvd;
          else
            ++xalloc;
          }
        }
      }    /* END for (i) */

    free_prop(prop);

    *navail = xavail;

    *nalloc = xalloc;

    *nresvd = xresvd;

    *ndown  = xdown;

    return(0);
    }
  else if (number(&pc, &holdnum) == -1)
    {
    /* invalid spec */

    return(RM_ERR_BADPARAM);
    }

  /* not a simple spec - determine if supplied complex */
  /* node spec can be satisified from avail nodes */
  /* navail set to >0 if can be satified now  */
  /*    0 if not now but possible  */
  /*   -l if never possible   */

  node_avail_complex(spec, navail, nalloc, nresvd, ndown);

  return(0);
  }  /* END node_avail() */




/*
 * node_reserve - Reserve nodes
 * Cannot reserve Time Shared Nodes
 *
 * Returns: >0 - reservation succeeded, number of nodes reserved
 *    0 - None or partial reservation
 *   -1 - requested reservation impossible
 */

int node_reserve(

  char       *nspec, /* In     - a node specification */
  resource_t  tag)   /* In/Out - tag for resource if reserved */

  {
  static char    id[] = "node_reserve";
  int   nrd;

  struct pbsnode *pnode;

  struct pbssubn *snp;
  int   ret_val;
  int   i;

  DBPRT(("%s: entered\n",
         id))

  if ((nspec == NULL) || (*nspec == '\0'))
    {
    log_event(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_SERVER,
      id,
      "no spec");

    return(-1);
    }

  if ((ret_val = node_spec(nspec, 0, 0, NULL, NULL, NULL, NULL)) >= 0)
    {
    /*
    ** Zero or more of the needed Nodes are available to be
    ** reserved.
    */

    for (i = 0;i < svr_totnodes;i++)
      {
      pnode = pbsndlist[i];

      if (pnode->nd_state & INUSE_DELETED)
        continue;

      if (pnode->nd_flag != thinking)
        continue;   /* skip this one */

      nrd = 0;

      for (snp = pnode->nd_psn;snp && pnode->nd_needed;snp = snp->next)
        {
        if (snp->inuse == INUSE_FREE)
          {
          DBPRT(("hold %s/%d\n",
                 pnode->nd_name,
                 snp->index))

          snp->inuse |= INUSE_RESERVE;
          snp->allocto = tag;

          pnode->nd_nsnfree--;  /* in reserve, not reached? */

          --pnode->nd_needed;

          ++nrd;
          }
        }

      if (nrd == pnode->nd_nsn)
        pnode->nd_state = INUSE_RESERVE;
      }
    }
  else
    {
    /* could never satisfy the reservation */

    snprintf(log_buffer, sizeof(log_buffer), "can never reserve %s",
             nspec);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

  return(ret_val);
  }  /* END node_reserve() */






/*
 * is_ts_node - does the nodestr specify a single time share node?
 * 0 - yes
 * 1 - no, not a ts node or more than one node (name will not match)
 */

int is_ts_node(

  char *nodestr)

  {

  struct pbsnode *np;
  int  i;

  for (i = 0;i < svr_totnodes;i++)
    {
    np = pbsndmast[i];

    if (((np->nd_state & INUSE_DELETED) == 0) &&
        (np->nd_ntype == NTYPE_TIMESHARED))
      {
      if (!strcmp(nodestr, np->nd_name))
        {
        return(0);
        }
      }
    }

  return(1);
  }  /* END is_ts_node() */





/*
 * find_ts_node - find first up time-shared node
 *
 * returns name of node or null
 */

char *
find_ts_node(void)

  {

  struct pbsnode *np;
  int             i;

  for (i = 0;i < svr_totnodes;i++)
    {
    np = pbsndmast[i];

    if ((np->nd_ntype == NTYPE_TIMESHARED) &&
        ((np->nd_state & (INUSE_DOWN | INUSE_DELETED | INUSE_OFFLINE)) == 0))
      {
      return(np->nd_name);
      }
    }

  return(NULL);
  }  /* END find_ts_node() */

/** Adjust a node resource value
 *
 * @param pattr  Attribute holding the resources
 * @param name   Name of the resource
 * @param value  Value by which to adjust
 * @param first  1 if this the first adjustment on node, 0 if not
 * @param op     Operation, INCR or DECR
 */
static void adjust_resource_value(attribute *pattr, char *name, char *value, int first, enum batch_op op)
  {
  resource_def *defin;
  resource *val;
  resource decoded;
  int ret;

  if (value == NULL)
    return;

  defin = find_resc_def(svr_resc_def,name,svr_resc_size);

  if (defin == NULL) /* not a known resource */
    return;

  /* if this is not a per-proc or per-node resource, ignore */
  if ((defin->rs_flags & (ATR_DFLAG_SELECT_MOM | ATR_DFLAG_SELECT_PROC)) == 0)
    return;

  /* if this is not the first adjustment on node and the resources is not per-proc, ignore */
  if ((defin->rs_flags & ATR_DFLAG_SELECT_PROC) == 0 && first == 0)
    return;

  ret = defin->rs_decode(&decoded.rs_value,0,name,value);

  if (ret != 0) /* could not decode value */
    return;

  val = find_resc_entry(pattr,defin);

  if (val == NULL && op == INCR)
    { /* if increasing the value and the resource is not yet present, add new entry */
    val = add_resource_entry(pattr,defin);

    if (val == NULL)
      return;

    ret = defin->rs_set(&val->rs_value,&decoded.rs_value,SET);
    }
  else if (val != NULL)
    {
    /* if the resulting value is zero, then remove completely */
    if (defin->rs_comp(&val->rs_value,&decoded.rs_value) == 0 && op == DECR)
      {
      defin->rs_free(&val->rs_value);
      }
    else
      {
      ret = defin->rs_set(&val->rs_value,&decoded.rs_value,op);
      }
    }
  }




/** Adjust the resources use on a node
 *
 * @param pnode Node with the resources
 * @param jp Job info
 * @param first Determines if this is the first adjustment for this node
 * @param op Operation to do (increment, decrement)
 */
void adjust_resources_use(struct pbsnode *pnode, struct jobinfo *jp, int first,
       enum batch_op op)
  {
  struct prop *prop = NULL, *iter = NULL;
  char *str, *spec, *token;
  int i,count,num;

  if (jp->job->ji_expanded_spec == NULL)
    return;

  spec = strdup(jp->job->ji_expanded_spec);
  token = spec;

  /* determine the count of nodespec parts */
  for (i = 1; token != NULL; i++)
    {
    token = strchr(token,'+');
    if (token != NULL)
      token++;
    }

  count = i;

  token = spec;

  /* record the starts of the node specs */
  for (i = 1; token != NULL; i++)
    {
    if (i == jp->order)
      {
      str = token;
      }

    token = strchr(token,'+');
    if (token != NULL)
      {
      *token = '\0';
      token++;
      }
    }

  if ((i = number(&str, &num)) == -1) /* get number */
    return;

  if (i == 0)
    {
    /* number exists */
    if (*str == ':')
      {
      /* there are properties */
      (str)++;

      if (proplist(&str, &prop, &num))
        return;
      }
    }
  else
    {
    /* no number */
    if (proplist(&str, &prop, &num))
      return;
    }

  iter = prop; /* iterating through resources in nodespec */
  while (iter != NULL)
    {
    /* adjust the value */
    adjust_resource_value(&pnode->attributes[1],iter->name,iter->value,first,op);
    iter = iter->next;
    }
  }


/*
 * free_nodes - free nodes allocated to a job
 */

void free_nodes(

  job *pjob)  /* I (modified) */

  {
  static char id[] = "free_nodes";

  struct pbssubn *np;

  struct pbsnode *pnode;

  struct jobinfo *jp, *prev;
  int             i;
  int first;

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer, "freeing nodes for job %s",
            pjob->ji_qs.ji_jobid);

    log_record(
      PBSEVENT_SCHED,
      PBS_EVENTCLASS_REQUEST,
      id,
      log_buffer);
    }

  /* examine all nodes in cluster */

  for (i = 0;i < svr_totnodes;i++)
    {
    pnode = pbsndlist[i];

    if (pnode->nd_state & INUSE_DELETED)
      continue;

    /* examine all subnodes in node */

    first = 1;
    for (np = pnode->nd_psn;np != NULL;np = np->next)
      {
      /* examine all jobs allocated to subnode */

      for (prev = NULL, jp = np->jobs;jp != NULL;prev = jp, jp = jp->next)
        {
        if (jp->job != pjob)
          continue;

        if (LOGLEVEL >= 4)
          {
          sprintf(log_buffer, "freeing node %s/%d from job %s (nsnfree=%d)",
                  pnode->nd_name,
                  np->index,
                  pjob->ji_qs.ji_jobid,
                  pnode->nd_nsnfree);

          log_record(
            PBSEVENT_SCHED,
            PBS_EVENTCLASS_REQUEST,
            id,
            log_buffer);
          }

        if (prev == NULL)
          np->jobs = jp->next;
        else
          prev->next = jp->next;

        if (pnode->nd_exclusive == 1) /* if taken exclusively, free */
          pnode->nd_exclusive = 0;

        adjust_resources_use(pnode,jp,first,DECR);
        first = 0;

        free(jp);

        pnode->nd_nsnfree++; /* up count of free */
        if (np->inuse & INUSE_JOBSHARE)
          pnode->nd_nsnshared--;

        if (LOGLEVEL >= 6)
          {
          sprintf(log_buffer, "increased sub-node free count to %d of %d\n",
                  pnode->nd_nsnfree,
                  pnode->nd_nsn);

          log_record(
            PBSEVENT_SCHED,
            PBS_EVENTCLASS_REQUEST,
            id,
            log_buffer);
          }

        /* adjust node state (turn off job-exclusive) */
        pnode->nd_state &= ~INUSE_JOB;

        /* adjust node state (turn off job-shared) */
        if (pnode->nd_nsnshared == 0)
          pnode->nd_state &= ~INUSE_JOBSHARE;

        /* if no jobs are associated with subnode, mark subnode as free */

        if (np->jobs == NULL)
          np->inuse &= ~(INUSE_JOB | INUSE_JOBSHARE);

        break;
        }  /* END for (prev) */
      }    /* END for (np) */
    }      /* END for (i) */

  pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_HasNodes;

  return;
  }  /* END free_nodes() */





/*
 * set_one_old - set a named node as allocated to a job
 */

static void set_one_old(

  char *name,
  job  *pjob,
  int   shared, /* how used flag, either INUSE_JOB or INUSE_JOBSHARE */
  int   exclusivity,
  int   order,
  int   first)

  {
  int  i;
  int  index;

  struct pbsnode *pnode;

  struct pbssubn *snp;

  struct jobinfo *jp;
  char        *pc;

  if ((pc = strchr(name, (int)'/')))
    {
    index = atoi(pc + 1);

    *pc = '\0';
    }
  else
    {
    index = 0;
    }

  for (i = 0;i < svr_totnodes;i++)
    {
    pnode = pbsndmast[i];

    if (strcmp(name, pnode->nd_name) == 0)
      {
      /* Mark node as being IN USE ...  */

      pnode->nd_exclusive = exclusivity;

      if (pnode->nd_ntype == NTYPE_CLUSTER || pnode->nd_ntype == NTYPE_VIRTUAL
          || pnode->nd_ntype == NTYPE_CLOUD)
        {
        for (snp = pnode->nd_psn;snp;snp = snp->next)
          {
          if (snp->index == index)
            {
            snp->inuse = shared;

            jp = (struct jobinfo *)malloc(sizeof(struct jobinfo));

            /* NOTE:  should report failure if jp == NULL (NYI) */

            if (jp != NULL)
              {
              jp->next = snp->jobs;

              snp->jobs = jp;

              jp->job = pjob;
              jp->order = order;
              }

            adjust_resources_use(pnode,jp,first,INCR);

            if (--pnode->nd_nsnfree <= 0)
              pnode->nd_state |= shared;

            return;
            }
          }    /* END for (snp) */
        }
      }
    }          /* END for (i) */

  return;
  }  /* END set_one_old() */





/*
 * set_old_nodes - set "old" nodes as in use - called from pbsd_init()
 * when recovering a job in the running state.
 */

void set_old_nodes(

  job *pjob)  /* I (modified) */

  {
  char *old = NULL, *fold = NULL;
  char *po, *ps;
  char *spec = NULL, *fspec = NULL;
  resource *presc;
  int   shared = INUSE_JOB;
  int   exclusivity = 0;
  int order = 1, remaining = 0;

  if ((pbsndmast != NULL) &&
      (pjob->ji_wattr[(int)JOB_ATR_exec_host].at_flags & ATR_VFLAG_SET))
    {
    /* are the nodes being used shared? Look in "neednodes" */

    presc = find_resc_entry(
              &pjob->ji_wattr[(int)JOB_ATR_resource],
              find_resc_def(svr_resc_def, "neednodes", svr_resc_size));

    if ((presc != NULL) && (presc->rs_value.at_flags & ATR_VFLAG_SET))
      {
      if ((po = strchr(presc->rs_value.at_val.at_str, '#')))
        {
        if (strstr(++po, "shared") != NULL)
          shared = INUSE_JOBSHARE;

        if (strstr(po, "excl") != NULL)
          exclusivity = 1;
        }
      }

    /* reset the jobs expanded nodespec from job attribute */
    if ((pjob->ji_wattr[(int)JOB_ATR_sched_spec].at_flags & ATR_VFLAG_SET) != 0)
      {
      free(pjob->ji_expanded_spec);
      pjob->ji_expanded_spec = nodespec_expand(pjob, pjob->ji_wattr[(int)JOB_ATR_sched_spec].at_val.at_str,&exclusivity);
      }

    /* duplicate the expanded nodespec, so we can work with it */
    if (pjob->ji_expanded_spec != NULL)
      {
      spec = strdup(pjob->ji_expanded_spec);
      fspec = spec;
      ps = spec;
      }

    old = strdup(pjob->ji_wattr[(int)JOB_ATR_exec_host].at_val.at_str);
    fold = old;
    po = old;

    if (old == NULL || spec == NULL)
      {
      /* FAILURE - cannot alloc memory */

      return;
      }

    /* nodes in exec host are in the right order, but we don't know
     * how many belong to each of the nodespec parts
     * we have to cut out the ppn=value and also the number of nodes */

    do /* for each part of the nodespec */
      {
      char *ppn = NULL;
      int ppn_count = 0;

      spec = ps; /* swap for the next part */

      remaining = atoi(spec); /* determine number of nodes requested */
      if (remaining == 0)
        remaining = 1;

      ps = strchr(ps,'+'); /* find next part */
      if (ps != NULL)
        {
        *ps = '\0'; ps++;
        }

      /* determine ppn */
      ppn = strstr(spec,"ppn=");
      if (ppn != NULL) /* there is ppn */
        {
        ppn+=4; /* move beyond ppn= */

        ppn_count = atoi(ppn);
        if (ppn_count == 0) /* should not happen */
          ppn_count = 1;

        remaining *= ppn_count; /* vps are requested for each node */
        }

      do /* for each remaining, eat part from exec host */
        {
        old = po;

        po = strchr(po,'+');
        if (po != NULL)
          {
          *po = '\0'; po++;
          }

        set_one_old(old, pjob, shared, exclusivity, order, (remaining % ppn_count == 0) ? 1 : 0);
        remaining--;
        }
      while (remaining > 0 && po != NULL);

      order++;
      }
    while (ps != NULL);

    /* reset alternatives on nodes */
    reset_alternative_on_node(pjob);

    free(fold);
    free(fspec);
    }  /* END if ((pbsndmast != NULL) && ...) */

  return;
  }  /* END set_old_nodes() */


/* END node_manager.c */

