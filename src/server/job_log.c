#include <pbs_config.h>   /* the master config generated by configure */

#include "pbs_ifl.h"
#include <sys/types.h>
#include <grp.h>
#include <assert.h>
#include <errno.h>
#include <stdio.h>
extern int asprintf(char **, const char *, ...);
#include <stdlib.h>
#include <string.h>
#include <time.h>
#include <ctype.h>
#ifdef HAVE_GLITE_LB
#include <glite/lb/producer.h>
#include <glite/security/glite_gss.h>
#endif

#include "server_limits.h"
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "server.h"
#include "queue.h"
#include "batch_request.h"
#include "pbs_job.h"
#include "pbs_error.h"
#include "pbs_proto.h"

#ifdef PBS_MOM
extern char mom_host[];
#else
extern char server_name[];
#endif

#define zapcr(s) for(char *p = (s); p && *p != '\0' && (p = strchr(p, '\n')) != NULL; *p++ = ' ')

#ifdef HAVE_GLITE_LB
#undef DIRECT_REGISTRATION
#define MOM_USE_INTERLOGD

#if defined(PBS_MOM) && !defined(MOM_USE_INTERLOGD)
#define LB_LOG_EVENT(name) edg_wll_Log ## name
#else
#define LB_LOG_EVENT(name) edg_wll_Log ## name ## File 
#endif

static edg_wll_TagValue *get_job_resources(tlist_head list)
{
	edg_wll_TagValue *tag_list, *tag;
	resource *pres;
	int count;

	for(count = 0, pres = (resource*)GET_NEXT(list);
	    pres != NULL;
	    pres = (resource*)GET_NEXT(pres->rs_link), count++);
	
	tag_list = calloc(count + 1, sizeof(*tag));
	if(tag_list == NULL) return NULL;
	
	for(pres = (resource*)GET_NEXT(list), tag = tag_list;
	    pres != NULL; 
	    pres = (resource*)GET_NEXT(pres->rs_link), tag++) {
		if(pres->rs_value.at_flags & ATR_VFLAG_SET) {
			tlist_head head;
			struct svrattrl *pal;
			int rc;

			/* copy resource name */
			tag->tag = strdup(pres->rs_defin->rs_name);
			/* encode the resource value into svrattrl
			 * structure, which is basically a couple of
			 * strings, and copy out the relevant strings
			 */ 
			CLEAR_HEAD(head);
			rc = pres->rs_defin->rs_encode(&pres->rs_value, &head,
						       "resc_used", pres->rs_defin->rs_name, ATR_ENCODE_SAVE);
			pal = (struct svrattrl*)GET_NEXT(head);
			tag->value = strdup(pal->al_value);
			free_attrlist(&head);

		}
	}
	
	return tag_list;
}

int svr_logjobstate(
	job  *pjob,
	int  newstate,
	int  newsubstate,
	struct batch_request *preq)
{
	static edg_wll_Context ctx;
	static int initialized = 0;
	
	int ret = 0, needs_register = 0;
	glite_jobid_t jobid;
	edg_wll_TagValue *resources;
	char *jobid_s;
	char *seq_no;

#ifdef PBS_MOM
	char *my_name = mom_host;
#else
	char *my_name = server_name;
	/* if this is server and we don't have the LB server, don't log */
	if ((server.sv_attr[SRV_ATR_LBServer].at_flags & ATR_VFLAG_SET) == 0)
		return 0;
#endif

	if(!initialized) {
		edg_wll_gss_initialize();
		edg_wll_InitContext(&ctx);
#ifdef PBS_MOM
		if(pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) {
			edg_wll_SetParam(ctx, EDG_WLL_PARAM_SOURCE, EDG_WLL_SOURCE_PBS_SMOM);
		} else {
			edg_wll_SetParam(ctx, EDG_WLL_PARAM_SOURCE, EDG_WLL_SOURCE_PBS_MOM);
		}
#else
		edg_wll_SetParam(ctx, EDG_WLL_PARAM_SOURCE, EDG_WLL_SOURCE_PBS_SERVER);
#endif
		edg_wll_SetParam(ctx, EDG_WLL_PARAM_INSTANCE, my_name);
		edg_wll_SetParam(ctx, EDG_WLL_PARAM_LEVEL, EDG_WLL_LEVEL_SYSTEM);
		/* TODO: sequence number */
		initialized = 1;
	}

	if ((pjob->ji_wattr[(int)JOB_ATR_lb_jobid].at_flags & ATR_VFLAG_SET) == 0)
	{
#if !defined(PBS_MOM)
		/* lb_jobid not set yet */
		if(strchr(server.sv_attr[SRV_ATR_LBServer].at_val.at_str, ':')) {
			asprintf(&jobid_s, "https://%s/%s", server.sv_attr[SRV_ATR_LBServer].at_val.at_str, pjob->ji_qs.ji_jobid);
		} else {
			asprintf(&jobid_s, "https://%s:%d/%s", server.sv_attr[SRV_ATR_LBServer].at_val.at_str, GLITE_JOBID_DEFAULT_PORT, pjob->ji_qs.ji_jobid);
		}
		job_attr_def[(int)JOB_ATR_lb_jobid].at_decode(
			&pjob->ji_wattr[(int)JOB_ATR_lb_jobid],
			NULL,
			NULL,
			jobid_s);
		needs_register = 1;
#else
		/* MOM only - lb_jobid must be present */
		sprintf(log_buffer, "svr_logjobstate: job has no lb jobid, skipping\n");
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
		return -1;
		
#endif
	}  else {
		jobid_s = strdup(pjob->ji_wattr[(int)JOB_ATR_lb_jobid].at_val.at_str);
	}

        if ((edg_wlc_JobIdParse(jobid_s, &jobid))) {
		sprintf(log_buffer, "svr_logjobstate: error parsing jobid (%s)\n", jobid_s);
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
		free(jobid_s);
		edg_wlc_JobIdFree(jobid);
		return -1;
	}

	free(jobid_s);

#if !defined(DIRECT_REGISTRATION)
	if((pjob->ji_wattr[(int)JOB_ATR_lb_seqno].at_flags & ATR_VFLAG_SET) == 0) {
#if !defined(PBS_MOM)
		seq_no = NULL;
#else
		edg_wlc_JobIdFree(jobid);
		sprintf(log_buffer, "svr_logjobstate: sequence number missing\n");
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
		return -1;
#endif
	} else {
		seq_no = strdup(pjob->ji_wattr[(int)JOB_ATR_lb_seqno].at_val.at_str);
	}

#if defined(PBS_MOM) && !defined(MOM_USE_INTERLOGD)
		if(edg_wll_SetLoggingJob(ctx, jobid, seq_no, EDG_WLL_SEQ_PBS)) {
#else
	if(edg_wll_SetLoggingJobFile(ctx, jobid, seq_no, pjob->ji_wattr[(int)JOB_ATR_job_owner].at_val.at_str, EDG_WLL_SEQ_PBS)) {
#endif
		char    *et,*ed;
		edg_wll_Error(ctx, &et, &ed);
		zapcr(ed); zapcr(et);
		sprintf(log_buffer, "svr_logjobstate: %s (%s)\n", et, ed);
		free(et); free(ed);
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
			free(seq_no);
			edg_wlc_JobIdFree(jobid);
			return -1;
	}
	free(seq_no);
#endif /* DIRECT_REGISTRATION */

	if(needs_register) {
#if defined(DIRECT_REGISTRATION)
		/* hack in job owner into registration event */
		edg_wll_SetParam(ctx, EDG_WLL_PARAM_LBPROXY_USER, pjob->ji_wattr[(int)JOB_ATR_job_owner].at_val.at_str);
		ret = edg_wll_RegisterJob(ctx,
					  jobid,
					  EDG_WLL_REGJOB_PBS,
					  "",   /* string jdl */
					  my_name,
					  0,    /* int nsubjobs */
					  NULL, /* string seed */
					  NULL  /* string wms_dn */
			);

#else
		/* queue request from client  - new job */
		ret = LB_LOG_EVENT(RegJobPBS)(ctx, 
					   "", /* string jdl */
					   my_name, /* string ns */
					   NULL, /* jobid parent */
					   0, /* int nsubjobs */
					   NULL, /* string seed */
					   NULL /* string wms_dn */
			);
#endif
		if(ret) {
			char *errt, *errd;
			
			/* LB logging error */
			edg_wll_Error(ctx, &errt, &errd);
			zapcr(errt); zapcr(errd);
			sprintf(log_buffer, "svr_logjobstate: %s (%s)\n", errt, errd);
			free(errt); free(errd);
			log_event(
				PBSEVENT_ERROR,
				PBS_EVENTCLASS_JOB,
				pjob->ji_qs.ji_jobid,
				log_buffer);
		}
	}


#if defined(DIRECT_REGISTRATION)
	if((pjob->ji_wattr[(int)JOB_ATR_lb_seqno].at_flags & ATR_VFLAG_SET) == 0) {
#if !defined(PBS_MOM)
		seq_no = NULL;
#else
		edg_wlc_JobIdFree(jobid);
		sprintf(log_buffer, "svr_logjobstate: sequence number missing\n");
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
		return -1;
#endif
	} else {
		seq_no = strdup(pjob->ji_wattr[(int)JOB_ATR_lb_seqno].at_val.at_str);
	}

#if defined(PBS_MOM) && !defined(MOM_USE_INTERLOGD)
        if (edg_wll_SetLoggingJob(ctx, jobid, seq_no, EDG_WLL_SEQ_PBS)) {
#else
	if (edg_wll_SetLoggingJobFile(ctx, jobid, seq_no, pjob->ji_wattr[(int)JOB_ATR_job_owner].at_val.at_str, EDG_WLL_SEQ_PBS)) {
#endif
                char    *et,*ed;
                edg_wll_Error(ctx, &et, &ed);
		zapcr(et); zapcr(ed);
		sprintf(log_buffer, "svr_logjobstate: %s (%s)\n", et, ed);
		free(et); free(ed);
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
		free(seq_no);
		edg_wlc_JobIdFree(jobid);
		return -1;
        }
	free(seq_no);
#endif /* DIRECT_REGISTRATION */

        edg_wlc_JobIdFree(jobid);

	switch(newstate) {
	case JOB_STATE_TRANSIT:
		switch(newsubstate) {
		case JOB_SUBSTATE_TRNOUT:
			/* this substate is used in case of transfer to another server */
			ret = LB_LOG_EVENT(PBSTransferSTART)(ctx, 
							  EDG_WLL_SOURCE_PBS_SERVER, /* logsrc destination */
							  pjob->ji_qs.ji_destin, /* string dest_instance */
							  NULL, /* string reason */
							  NULL /* string dest_jobid */
				);
			break;

		case JOB_SUBSTATE_TRNOUTCM:
			/* the server is ready to purge this job */
			ret = LB_LOG_EVENT(PBSTransferOK)(ctx, 
						       EDG_WLL_SOURCE_PBS_SERVER, /* logsrc destination */
						       pjob->ji_qs.ji_destin, /* string dest_instance */
						       NULL, /* string reason */
						       NULL /* string dest_jobid */
				);
			break;

		case JOB_SUBSTATE_TRANSIN:
			/* may be we are returning to this state due to the failure in TRANSICM */
			if(pjob->ji_qs.ji_state == JOB_STATE_TRANSIT && 
			   pjob->ji_qs.ji_substate == JOB_SUBSTATE_TRANSICM) {
				ret = LB_LOG_EVENT(PBSRefused)(ctx,
							    EDG_WLL_SOURCE_PBS_SERVER,
							    preq != NULL ? preq->rq_host : "", /* string from_instance */
							    NULL /* string reason */
					);
			} else {
				/* to MOM: */
				/* to SERVER: */
				ret = LB_LOG_EVENT(PBSTransferSTART)(ctx,
#ifdef PBS_MOM						       
								  EDG_WLL_SOURCE_PBS_MOM, /* destination */
#else						       
								  EDG_WLL_SOURCE_PBS_SERVER, /* destination */
#endif
								  my_name, /* destination instance */
								  NULL, /* string reason */
								  pjob->ji_qs.ji_jobid /* string dest_jobid */
					);	       
			}
			break;
			
		case JOB_SUBSTATE_TRANSICM:
			ret = LB_LOG_EVENT(PBSAccepted)(ctx,
#ifdef PBS_MOM
						     (preq != NULL) && !(preq->rq_fromsvr) ? EDG_WLL_SOURCE_PBS_MOM : EDG_WLL_SOURCE_PBS_SERVER, 
#else
						     (preq != NULL) && !(preq->rq_fromsvr) ? EDG_WLL_SOURCE_PBS_CLIENT : EDG_WLL_SOURCE_PBS_SERVER, 
#endif
						     preq != NULL ? preq->rq_host : "", /* string from_instance */
						     pjob->ji_qs.ji_jobid /* string local_jobid */
				);
			break;
		}
		break;
		
	case JOB_STATE_QUEUED:
		switch(newsubstate) {
		case JOB_SUBSTATE_ABORT:
			if(JOB_STATE_TRANSIT == pjob->ji_qs.ji_state) {
				ret = LB_LOG_EVENT(PBSTransferREFUSED)(ctx,
								    EDG_WLL_SOURCE_PBS_SERVER,
								    pjob->ji_qs.ji_destin,
								    NULL,  /* source */
								    NULL   /* reason */
					);
			} else {
			}
			break;

		case JOB_SUBSTATE_STAGEIN:
			break;

		case JOB_SUBSTATE_QUEUED:
		case JOB_SUBSTATE_PRESTAGEIN:
		case JOB_SUBSTATE_SYNCRES:
		case JOB_SUBSTATE_STAGECMP:
		case JOB_SUBSTATE_CHKPTCMP:
		default:
			if(JOB_STATE_EXITING == pjob->ji_qs.ji_state ||
			   JOB_STATE_COMPLETE == pjob->ji_qs.ji_state) {
				/* job is being rerun */
				ret = LB_LOG_EVENT(PBSRerun)(ctx);
			}
			ret = LB_LOG_EVENT(PBSQueued)(ctx,
						   pjob->ji_qs.ji_queue,
						   pjob->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str,
						   pjob->ji_wattr[(int)JOB_ATR_job_owner].at_val.at_str
				);
			resources = get_job_resources(pjob->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);
			ret = LB_LOG_EVENT(PBSResourceUsageREQUESTED)(ctx, resources);
			edg_wll_FreeTagList(resources);
			free(resources);
			break;
		}
		break;

	case JOB_STATE_HELD:
		switch(newsubstate) {
		case JOB_SUBSTATE_SYNCHOLD:
		case JOB_SUBSTATE_DEPNHOLD:
		case JOB_SUBSTATE_HELD:
		default:
			if(JOB_STATE_EXITING == pjob->ji_qs.ji_state ||
			   JOB_STATE_COMPLETE == pjob->ji_qs.ji_state) {
				/* job is being rerun */
				ret = LB_LOG_EVENT(PBSRerun)(ctx);
			}
			break;
		}
		break;

	case JOB_STATE_WAITING:
		break;

	case JOB_STATE_RUNNING:
		switch(newsubstate) {
		case JOB_SUBSTATE_PRERUN:
#if !defined(PBS_MOM)			
			if(JOB_SUBSTATE_STAGEGO != pjob->ji_qs.ji_substate &&
			   JOB_SUBSTATE_CHKPTGO != pjob->ji_qs.ji_substate) {
				/* job had no checkpoint and no files to stage in, so log RUN event here */
				ret = LB_LOG_EVENT(PBSRun)(ctx,
							preq != NULL ? preq->rq_host : "", /* scheduler, ie. host sending req_runjob */
							pjob->ji_wattr[(int)JOB_ATR_exec_host].at_val.at_str, /* exec host */
							0 /* pid - not known here */
					);
			}
			/* the substate used by server when transferring job to MOM */
			ret = LB_LOG_EVENT(PBSTransferSTART)(ctx, 
							  EDG_WLL_SOURCE_PBS_MOM, /* logsrc destination */
							  pjob->ji_qs.ji_destin, /* string dest_instance */
							  NULL, /* string reason */
							  NULL /* string dest_jobid */
				);
#else 
			/* on MOM this is called on commit req from server just before job execution */
#endif
			break;
			
		case JOB_SUBSTATE_STARTING:
			/* this is for MOM only */
			break;
			
		case JOB_SUBSTATE_SUSPEND:
			/* this is for MOM only */
			break;
			
		case JOB_SUBSTATE_RUNNING:
#ifdef PBS_MOM
			/* job is running in its own process */
			ret = LB_LOG_EVENT(PBSRun)(ctx,
						"",
						pjob->ji_wattr[(int)JOB_ATR_exec_host].at_val.at_str,
						*(pid_t*)preq);
#else
			/* job has been sent to MOM */
			ret = LB_LOG_EVENT(PBSTransferOK)(ctx,
						       EDG_WLL_SOURCE_PBS_MOM, /* logsrc destination */
						       pjob->ji_qs.ji_destin, /* string dest_instance */
						       NULL, /* string reason */
						       NULL /* string dest_jobid */
				);
#endif
			break;
			
		case JOB_SUBSTATE_ABORT:
			ret = LB_LOG_EVENT(PBSAbort)(ctx);
			break;

		case JOB_SUBSTATE_RERUN:
			ret = LB_LOG_EVENT(PBSRerun)(ctx);
			break;

		case JOB_SUBSTATE_RERUN1:
			/* MOM requests job obit and indicates to retry, job payload has not been started */
			ret = LB_LOG_EVENT(PBSRerun)(ctx);
			break;

		case JOB_SUBSTATE_SYNCRES:
			/* This is an arbitrary state/substate combination that should never occur within PBS itself.
			   It is used in LB-MOM internally to request logging of job consumed resources. */
			resources = get_job_resources(pjob->ji_wattr[(int)JOB_ATR_resc_used].at_val.at_list);
			ret = LB_LOG_EVENT(PBSResourceUsageUSED)(ctx, resources);
			edg_wll_FreeTagList(resources);
			free(resources);
			break;

		case JOB_SUBSTATE_STAGEGO:
		case JOB_SUBSTATE_CHKPTGO:
		default:
			ret = LB_LOG_EVENT(PBSRun)(ctx,
						preq != NULL ? preq->rq_host : "", /* scheduler, ie. host sending req_runjob */
						pjob->ji_wattr[(int)JOB_ATR_exec_host].at_val.at_str, /* exec host */
						0 /* pid - not known here */
				);
			break;
		}

		break;

	case JOB_STATE_EXITING:
		switch(newsubstate) {

		case JOB_SUBSTATE_EXITING:
			ret = LB_LOG_EVENT(PBSDone)(ctx, 
						 pjob->ji_qs.ji_un.ji_exect.ji_exitstat
				);
			break;

		case JOB_SUBSTATE_RETURNSTD:
		case JOB_SUBSTATE_STAGEOUT:
		case JOB_SUBSTATE_STAGEDEL:
			/* job exit processing phases */
			break;

		case JOB_SUBSTATE_EXITED:
			/* job is done */
			/* edg_wll_LogPBSDone(ctx, pjob->ji_un.ji_exect.ji_exitstat); */
			resources = get_job_resources(pjob->ji_wattr[(int)JOB_ATR_resc_used].at_val.at_list);
			ret = LB_LOG_EVENT(PBSResourceUsageUSED)(ctx, resources);
			edg_wll_FreeTagList(resources);
			free(resources);
			break;
			
		case JOB_SUBSTATE_ABORT:
			ret = LB_LOG_EVENT(PBSAbort)(ctx);
			break;

		case JOB_SUBSTATE_RERUN1:
		case JOB_SUBSTATE_RERUN2:
			break;

		case JOB_SUBSTATE_RERUN3:
			/* job is running on not responding MOM, forcibly rerun */
			break;

		default: 
			break;
		}
		break;

	case JOB_STATE_COMPLETE:
		break;
		
	default:
		break;
	}
		
	if(ret) {
		char *errt, *errd;
		
		/* LB logging error */
		edg_wll_Error(ctx, &errt, &errd);
		zapcr(errt); zapcr(errd);
		sprintf(log_buffer, "svr_logjobstate: %s (%s)\n", errt, errd);
		free(errt); free(errd);
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
		
	}

	if(JOB_STATE_RUNNING == newstate &&
	   JOB_SUBSTATE_SYNCRES == newsubstate) {
		/* log nothing, this is internal */
		ret = 0;
	} else {
		/* log the job internal state change */
		ret = LB_LOG_EVENT(PBSInternalStateChange)(ctx,
							pjob->ji_qs.ji_state,
							pjob->ji_qs.ji_substate,
							newstate, 
							newsubstate
			);
	}	

	if(ret) {
		char *errt, *errd;
		
		/* LB logging error */
		edg_wll_Error(ctx, &errt, &errd);
		zapcr(errt); zapcr(errd);
		sprintf(log_buffer, "svr_logjobstate: %s (%s)\n", errt, errd);
		free(errt); free(errd);
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
	}


	/* stuff updated sequence number back into job attributes */
	seq_no = edg_wll_GetSequenceCode(ctx);
	if(seq_no == NULL) {
		char *errt, *errd;
		
		edg_wll_Error(ctx, &errt, &errd);
		zapcr(errt); zapcr(errd);
		sprintf(log_buffer, "svr_logjobstate: %s (%s)\n", errt, errd);
		free(errt); free(errd);
		log_event(
			PBSEVENT_ERROR,
			PBS_EVENTCLASS_JOB,
			pjob->ji_qs.ji_jobid,
			log_buffer);
		return -1;
	}
	job_attr_def[(int)JOB_ATR_lb_seqno].at_decode(
		&pjob->ji_wattr[(int)JOB_ATR_lb_seqno],
		NULL,
		NULL,
		seq_no);
	free(seq_no);

	return 0;
}
#endif



