/* this file contains functions for manipulating job arrays

  included functions:

  is_array() determine if jobnum is actually an array identifyer

 */

#include <pbs_config.h>   /* the master config generated by configure */

#include <errno.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <fcntl.h>
#include <unistd.h>


#include "pbs_ifl.h"
#include "log.h"
#include "list_link.h"
#include "attribute.h"
#include "server_limits.h"
#include "job.h"
#include "log.h"
/* #include "array.h" */

#ifndef TRUE
#define TRUE 1
#define FALSE 0
#endif

/* global data items used */

/* list of job arrays */

extern tlist_head svr_jobarrays;
extern char *path_arrays;

/* search job array list to determine if id is a job array */
int is_array(char *id)
  {

  array_job_list *pajl;
  
  
    
  pajl = (array_job_list*)GET_NEXT(svr_jobarrays);  
  while (pajl != NULL)
    {
    if (strcmp(pajl->ai_qs.parent_id, id) == 0)
      {
      return TRUE;
      }
    pajl = (array_job_list*)GET_NEXT(pajl->all_arrays);
    }
  
  return FALSE;
  }
  
/* return a server's array info struct corresponding to an array id */
array_job_list *get_array(char *id)
  {
  array_job_list *pajl;
   
    
  pajl = (array_job_list*)GET_NEXT(svr_jobarrays);  
  while (pajl != NULL)
    {
    if (strcmp(pajl->ai_qs.parent_id, id) == 0)
      {
      return pajl;
      }
    pajl = (array_job_list*)GET_NEXT(pajl->all_arrays);
    }
    
  return (array_job_list*)NULL;
  }
  
  
int array_save(array_job_list *pajl)

  { 
  int fds;
  int openflags;
  char namebuf[MAXPATHLEN];
  
  strcpy(namebuf, path_arrays);
  strcat(namebuf, pajl->ai_qs.fileprefix);
  strcat(namebuf, ARRAY_FILE_SUFFIX);
  
  
  openflags =  O_WRONLY | O_SYNC | O_CREAT;
  fds = open(namebuf, openflags, 0600);
  
  if (fds < 0)
    {
    
    return -1;
    }
    
    
  write(fds,  &(pajl->ai_qs), sizeof(pajl->ai_qs));
    
  close(fds);
  
  return 0;
  }
  
  
void get_parent_id(char *job_id, char *parent_id)
  {
  char *c;
  char *pid;
  
  c = job_id;
  *parent_id = '\0';
  pid = parent_id;
  
  /* copy until the '-' */
  while (*c != '-' && *c != '\0')
    {
    *pid = *c;
    c++;
    pid++;
    } 
    
  /* skip the until the first '.' */
  while (*c != '.' && *c != '\0')
    {
    c++;
    }
    
  /* copy the rest of the id */
  *pid = '\0';
  strcat(pid, c);


  }  


array_job_list *recover_array_struct(char *path)
{
   extern tlist_head svr_jobarrays;
   array_job_list *pajl;
   int fd;
   
   
   pajl = (array_job_list*)malloc(sizeof(array_job_list));
   
   if (pajl == NULL)
     {
     return NULL;
     }
     
   CLEAR_LINK(pajl->all_arrays);
   CLEAR_HEAD(pajl->array_alljobs);
	 
   fd = open(path, O_RDONLY,0);
   
   if (read(fd, &(pajl->ai_qs), sizeof(pajl->ai_qs)) != sizeof(pajl->ai_qs))
     {
     sprintf(log_buffer,"unable to read %s", path);

     log_err(errno,"pbsd_init",log_buffer);

     free(pajl);
     return(NULL);
     }
     
   close(fd);
	 
   append_link(&svr_jobarrays, &pajl->all_arrays, (void*)pajl);
   
   return pajl;

}

int delete_array_struct(array_job_list *pajl)
  {
 
  char namebuf[MAXPATHLEN + 1];
  
   
  delete_link(&pajl->all_arrays);
  
  strcpy(namebuf, path_arrays);
  strcat(namebuf, pajl->ai_qs.fileprefix);
  strcat(namebuf, ARRAY_FILE_SUFFIX);
  
  free(pajl);
  
  unlink(namebuf);
  
  return TRUE;
  }
