/*
*         OpenPBS (Portable Batch System) v2.3 Software License
*
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
*
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
*
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
*
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
*
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
*
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
*
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
*
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
*
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
*
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
*
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
*
* 7. DISCLAIMER OF WARRANTY
*
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
*
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
*
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/
/*
 * req_quejob.c
 *
 * Functions relating to the Queue Job Batch Request sequence, including
 * Queue Job, Job Script, Ready to Commit, and Commit.
 *
 * Included functions are:
 * req_quejob()
 * req_jobcredential()
 * req_jobscript()
 * req_rdycommit()
 * req_commit()
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include <stdio.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <sys/param.h>
#include <errno.h>
#include <fcntl.h>
#include <netinet/in.h>
#include <unistd.h>
#include <ctype.h>
#include <string.h>
#include "libpbs.h"
#include "server_limits.h"
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "server.h"
#include "credential.h"
#include "batch_request.h"
#include "pbs_job.h"
#include "queue.h"
#include "net_connect.h"
#include "pbs_error.h"
#include "log.h"
#include "svrfunc.h"
#include "csv.h"
#include "cloud.h"

#include "work_task.h"
extern void  job_clone_wt A_((struct work_task *));
extern int setup_array_struct(job *pjob);

#ifdef GSSAPI
#include "pbsgss.h"
#endif

/* External Functions Called: */

extern int  reply_jid A_((char *));
extern void start_exec A_((job *));
extern int  svr_authorize_jobreq A_((struct batch_request *, job *));
extern int  svr_chkque A_((job *, pbs_queue *, char *, int, char *));
extern int  job_route A_((job *));
extern int node_avail_complex(char *, int *, int *, int *, int*);
extern int  assign_hosts (job *, char *, int, char *, char *);
void regenerate_total_resources(job *);

/* Global Data Items: */

extern char *path_spool;

extern struct server server;
extern char  server_name[];
extern int   queue_rank;
extern tlist_head svr_jobarrays;

#ifdef GSSAPI
extern struct connection svr_conn[PBS_NET_MAX_CONNECTIONS];
#endif /* GSSAPI */

extern const char *PJobSubState[];

/* sync w/enum job_file TJobFileType[]) */

const char *TJobFileType[] =
  {
  "jobscript",
  "stdin",
  "stdout",
  "stderr",
  "checkpoint",
  NULL
  };

extern int  resc_access_perm;
extern tlist_head svr_alljobs;
extern tlist_head svr_newjobs;
extern attribute_def job_attr_def[];
extern char *path_jobs;
extern char *pbs_o_host;
extern char *msg_script_open;
extern char *msg_script_write;
extern char *msg_init_abt;

extern char *msg_jobnew;
extern time_t time_now;
extern int    LOGLEVEL;

extern  char *msg_daemonname;



/* Private Functions in this file */

static job *locate_new_job A_((int, char *));
int svr_startjob(job *, struct batch_request *, char *, char *);

#ifdef PNOT
static int user_account_verify A_((char *, char *));
static char *user_account_default A_((char *));
static int user_account_read_user A_((char *));
#endif /* PNOT */

static char *pbs_o_que = "PBS_O_QUEUE=";

static int filter_job_replaceppn(resource_def *d_nodes, job* pj)
  {
  resource *nodes;
  /* is node resource present? */
  if ((nodes = find_resc_entry(&pj->ji_wattr[(int)JOB_ATR_resource],d_nodes)) != 0)
    {
    /* go through the old nodestr and construct a new one */
    char *nodestr, *newnodestr, *p;

    nodestr = nodes->rs_value.at_val.at_str;
    newnodestr = malloc(strlen(nodestr)+1);
    if (newnodestr == NULL)
      return 1;

    memset(newnodestr,0,strlen(nodestr)+1);

    while ((p = strstr(nodestr,"ncpus")) != NULL)
      {
      strncat(newnodestr,nodestr,p-nodestr); /* copy the necesary number of characters */
      strcat(newnodestr,"ppn");
      nodestr = p + strlen("ncpus"); /* move past the ncpus */
      }

    /* concat the rest */
    strcat(newnodestr,nodestr);

    replace_attr_string(&nodes->rs_value,newnodestr);
    }

  return 0;
  }

static int filter_job(job *pj)
  {
  /* find ncpus in the resource list (nodespec only) and replace */
  if (pj->ji_wattr[(int)JOB_ATR_resource].at_flags & ATR_VFLAG_SET)
    {
    // check all resources for values
    resource *jbrc = (resource *)GET_NEXT(pj->ji_wattr[(int)JOB_ATR_resource].at_val.at_list);
    while (jbrc != NULL)
      {
      if ((jbrc->rs_value.at_flags & ATR_VFLAG_SET) == 0)
        return -1;
      jbrc = (resource*)GET_NEXT(jbrc->rs_link);
      }

    // imply -l place=scratch_pool for -l scratch=shared
    resource_def *d_scratch;
    if ((d_scratch = find_resc_def(svr_resc_def, "scratch", svr_resc_size)) != 0)
      {
      resource *scratch;
      if ((scratch = find_resc_entry(&pj->ji_wattr[(int)JOB_ATR_resource],d_scratch)) != 0)
        {
        if (strstr(scratch->rs_value.at_val.at_str,"shared") != NULL)
          {
          resource_def *place_def;
          resource *place_val;
          if ((place_def = find_resc_def(svr_resc_def,"place",svr_resc_size)) != 0)
          if ((place_val = find_resc_entry(&pj->ji_wattr[(int)JOB_ATR_resource],place_def)) == 0)
          if ((place_val = add_resource_entry(&pj->ji_wattr[(int)JOB_ATR_resource],place_def)) != 0)
            {
            replace_attr_string(&place_val->rs_value,strdup("scratch_pool"));
            }
          }
        }
      }

    // replace ncpus with ppn
    resource_def *d_nodes;

    if ((d_nodes = find_resc_def(svr_resc_def,"nodes",svr_resc_size)) != 0)
      {
      if (filter_job_replaceppn(d_nodes,pj) != 0) { return 1; }

      // add -l place=infiniband if infiniband property is present
      resource *nodes;
      if ((nodes = find_resc_entry(&pj->ji_wattr[(int)JOB_ATR_resource],d_nodes)) != 0)
        {


        if (strstr(nodes->rs_value.at_val.at_str,"infiniband") != NULL)
          {
          resource_def *place_def;
          resource *place_val;
          if ((place_def = find_resc_def(svr_resc_def,"place",svr_resc_size)) != 0)
          if ((place_val = find_resc_entry(&pj->ji_wattr[(int)JOB_ATR_resource],place_def)) == 0)
          if ((place_val = add_resource_entry(&pj->ji_wattr[(int)JOB_ATR_resource],place_def)) != 0)
            {
            replace_attr_string(&place_val->rs_value,strdup("infiniband"));
            }
          }

        // add #cgroup if -W cgroup=true is present
        if ((pj->ji_wattr[(int)JOB_ATR_cgroup].at_flags & ATR_VFLAG_SET) &&
            (pj->ji_wattr[(int)JOB_ATR_cgroup].at_val.at_long > 0))
          {
          char * nodespec = nodes->rs_value.at_val.at_str;
          char * newnodes = malloc(strlen(nodes->rs_value.at_val.at_str)+strlen("#cgroup")+1);
          if (newnodes != NULL)
            {
            sprintf(newnodes,"%s%s",nodes->rs_value.at_val.at_str,"#cgroup");
            replace_attr_string(&nodes->rs_value,newnodes);
            }
          }

        // remove ignored properties
        if ((server.sv_attr[(int)SRV_ATR_ignore_properties].at_flags & ATR_VFLAG_SET) &&
            (server.sv_attr[(int)SRV_ATR_ignore_properties].at_val.at_arst->as_usedptr > 0))
          {
          for (int i = 0; i < server.sv_attr[(int)SRV_ATR_ignore_properties].at_val.at_arst->as_usedptr; ++i)
            {
            char *prop = server.sv_attr[(int)SRV_ATR_ignore_properties].at_val.at_arst->as_string[i];
            char *nodestr = nodes->rs_value.at_val.at_str;
            int len = strlen(prop);
            char *pos;
            char *iter = nodestr;
            while ((pos = strstr(iter,prop)) != NULL)
              {
              //determine whether this is a real match :
              // start of string, or preceeded by a delimiter
              // followed by end of string or a delimiter
              if (!((pos == nodestr || pos[-1] == ':' || pos[-1] == '+' || pos[-1] == '#') &&
                  (pos[len] == '\0' || pos[len] == ':' || pos[len] == '+' || pos[len] == '#')))
                {
                // not a real match, move on
                iter += len;
                continue;
                }

              // this is a real match


              // for trailing properties, just mark a new end of the string
              if (pos[len] == '\0')
                {
                // do not leave the node string completely empty
                if (pos == nodestr)
                  {
                  nodestr[0] = '1';
                  nodestr[1] = '\0';
                  break;
                  }
                else // there is a delimiter before our string
                  {
                  // remove the delimiter as well
                  --pos;
                  *pos = '\0';
                  }
                }
              // if we are not at the end of nodespec, we must have
              // a delimiter tat the end of the property
              else if (pos[len] == ':' || pos[len] == '+' || pos[len] == '#' )
                {
                char *trail = pos+len;
                if (pos == nodestr)
                  {
                  // do not copy the delimiter
                  memmove(pos,trail+1,strlen(trail+1)+1);
                  }
                else if (pos[-1] == ':' || pos[-1] == '+' || pos[-1] == '#')
                  {
                  --pos;
                  memmove(pos,trail,strlen(trail)+1);
                  }
                }
              }
            }
          }
        }
      }

    if ((d_nodes = find_resc_def(svr_resc_def,"neednodes",svr_resc_size)) != 0)
      if (filter_job_replaceppn(d_nodes,pj) != 0) { return 1; }
    }

  return 0;
  }

/** Construct new jobid according to server settings
 *
 *  Increment server next job number attribute accordingly.
 *
 *  @param jidbuf Pointer to buffer of at least \c PBS_MAXSVRJOBID + 1 size
 *  @returns 0 on success 1 on failure
 */
int get_next_jobid(char *jidbuf)
  {
  char host_server[PBS_MAXSERVERNAME + 1];
  int  server_suffix = TRUE;

  memset(host_server, 0, sizeof(host_server));

  if ((server.sv_attr[SRV_ATR_display_job_server_suffix].at_flags & ATR_VFLAG_SET) &&
      (server.sv_attr[SRV_ATR_display_job_server_suffix].at_val.at_long == FALSE))
    server_suffix = FALSE;

  if ((server.sv_attr[SRV_ATR_job_suffix_alias].at_flags & ATR_VFLAG_SET) &&
      (server_suffix == TRUE))
    {
    char *svrnm;

    if (get_fullhostname(pbs_default(), host_server, PBS_MAXSERVERNAME, NULL) == 0)
      {
      svrnm = host_server;
      }
    else
      {
      svrnm = server_name;
      }

    snprintf(jidbuf,PBS_MAXSVRJOBID + 1,"%d.%s.%s",
      server.sv_qs.sv_jobidnumber,
      svrnm,
      server.sv_attr[SRV_ATR_job_suffix_alias].at_val.at_str);
    }
  else if (server.sv_attr[SRV_ATR_job_suffix_alias].at_flags & ATR_VFLAG_SET)
    {
    snprintf(jidbuf,PBS_MAXSVRJOBID + 1,"%d.%s",
      server.sv_qs.sv_jobidnumber,
      server.sv_attr[SRV_ATR_job_suffix_alias].at_val.at_str);
    }
  else if (server_suffix == TRUE)
    {
    char *svrnm;

    if (get_fullhostname(pbs_default(), host_server, PBS_MAXSERVERNAME, NULL) == 0)
      {
      svrnm = host_server;
      }
    else
      {
      svrnm = server_name;
      }

    snprintf(jidbuf,PBS_MAXSVRJOBID + 1,"%d.%s",
      server.sv_qs.sv_jobidnumber,
      svrnm);
    }
  else
    {
    snprintf(jidbuf,PBS_MAXSVRJOBID + 1,"%d",
      server.sv_qs.sv_jobidnumber);
    }

  /* having updated sv_jobidnumber, must save server struct */

  if (++server.sv_qs.sv_jobidnumber > PBS_SEQNUMTOP)
    server.sv_qs.sv_jobidnumber = 0; /* wrap it */

  /* Make the current job number visible in qmgr print server commnad. */
  server.sv_attr[(int)SRV_ATR_NextJobNumber].at_val.at_long = server.sv_qs.sv_jobidnumber;
  server.sv_attr[(int)SRV_ATR_NextJobNumber].at_flags |= ATR_VFLAG_SET | ATR_VFLAG_MODIFY;

  if (svr_save(&server, SVR_SAVE_QUICK))
    {
    return 1;
    }

  return 0;
  }

int create_job_file(char *namebuf, char *basename)
  {
  int fds;
  char *pc;
  char* id = "create_job_file";

  do
    {
    strcpy(namebuf, path_jobs);      /* base path for jobs */
    strcat(namebuf, basename);       /* the concerned job basename */
    strcat(namebuf, JOB_FILE_SUFFIX); /* sufix for job files */

    if ((fds = open(namebuf, O_CREAT | O_EXCL | O_WRONLY, 0600)) < 0)
      { /* couldn't create file */

      if (errno == EEXIST) /* jobfile with the same name already exists */
        {
        /* try to construct a new jobfile name, that doesn't yet exist */
        pc = basename + strlen(basename) - 1;

        /* find a character that can be incremented */
        while (!(isalnum(pc[0]) && isalnum(pc[0]+1)) && pc > basename)
          pc--;

        if (pc == basename)
          {
          log_err(errno,id,"cannot construct unique named jobfile");
          return 1;
          }

        pc[0]++;
        }
      else /* other system error */
        {
        log_err(errno,id,"cannot create job file");
        return 1;
        }
      }
    }
  while (fds < 0);
  fsync(fds);
  close(fds);

  return 0;
  }


/*
 * req_quejob - Queue Job Batch Request processing routine
 *  NOTE:  calls svr_chkque() to validate queue access
 *
 */

void req_quejob(

  struct batch_request *preq) /* ptr to the decoded request   */

  {
  char          *id = "req_quejob";

  char   basename[PBS_JOBBASE + 1];
  int   created_here = 0;
  int   index;
  char  *jid;
  char   namebuf[MAXPATHLEN + 1];
  attribute_def *pdef;
  job  *pj;
  svrattrl *psatl;
  int   rc;
  int   sock = preq->rq_conn;

  int   i;
  char   buf[256];
  char   jidbuf[PBS_MAXSVRJOBID + 1];
  pbs_queue *pque;
  char  *qname;
  attribute  tempattr;
  char           EMsg[1024];

  /* set basic (user) level access permission */

  resc_access_perm = ATR_DFLAG_USWR | ATR_DFLAG_Creat;


  /*
   * if the job id is supplied, the request had better be
   * from another server
   */

  if (preq->rq_fromsvr)
    {
    /* from another server - accept the extra attributes */

    resc_access_perm |= ATR_DFLAG_MGWR | ATR_DFLAG_SvWR;

    jid = preq->rq_ind.rq_queuejob.rq_jid;
    }
  else if (preq->rq_ind.rq_queuejob.rq_jid[0] != '\0')
    {
    /* FAILURE */

    /* a job id is not allowed from a client */

    log_err(errno, id, "job id not allowed from client");

    req_reject(PBSE_IVALREQ, 0, preq, NULL, "job not allowed from client");

    return;
    }
  else
    {
    created_here = JOB_SVFLG_HERE;
    if (get_next_jobid(jidbuf) != 0)
      {
      /* FAILURE */
      req_reject(PBSE_INTERNAL, 0, preq, NULL, NULL);

      return;
      }

    jid = jidbuf;
    }

  /* does job already exist, check both old and new jobs */

  if ((pj = find_job(jid)) == NULL)
    {
    pj = (job *)GET_NEXT(svr_newjobs);

    while (pj != NULL)
      {
      if (!strcmp(pj->ji_qs.ji_jobid, jid))
        break;

      pj = (job *)GET_NEXT(pj->ji_alljobs);
      }
    }

  if (pj != NULL)
    {
    /* server will reject queue request if job already exists */

    log_err(errno, id, "cannot queue new job, job already exists");

    req_reject(PBSE_JOBEXIST, 0, preq, NULL, NULL);

    return;
    }

  /* find requested queue, is it there? */

  qname = preq->rq_ind.rq_queuejob.rq_destin;

  if ((*qname == '\0') || (*qname == '@'))
    {
    /* use default queue */

    pque = get_dfltque();

    rc   = PBSE_QUENODFLT;
    }
  else
    {
    /* else find the named queue */

    pque = find_queuebyname(preq->rq_ind.rq_queuejob.rq_destin);

    rc   = PBSE_UNKQUE;
    }

  if (pque == NULL)
    {
    /* FAILURE */

    log_err(-1, id, "requested queue not found");

    req_reject(rc, 0, preq, NULL, "cannot locate queue"); /* not there   */

    return;
    }

  /*
   * make up job file name, it is based on the jobid, however the
   * minimun acceptable file name limit is only 14 character in POSIX,
   * so we may have to "hash" the name slightly
   */

  strncpy(basename, jid, PBS_JOBBASE);

  basename[PBS_JOBBASE] = '\0';

  if (create_job_file(namebuf,basename) != 0)
    {
    req_reject(PBSE_INTERNAL, 0, preq, NULL, "cannot create job file");
    return;
    }

  /* create the job structure */

  if ((pj = job_alloc()) == NULL)
    {
    /* FAILURE */

    log_err(errno, id, "cannot alloc new job");

    unlink(namebuf);

    req_reject(PBSE_SYSTEM, 0, preq, NULL, "cannot alloc new job structure");

    return;
    }

  strcpy(pj->ji_qs.ji_jobid, jid);

  strcpy(pj->ji_qs.ji_fileprefix, basename);

  pj->ji_modified       = 1;
  pj->ji_qs.ji_svrflags = created_here;
  pj->ji_qs.ji_un_type  = JOB_UNION_TYPE_NEW;

  /* decode attributes from request into job structure */

  psatl = (svrattrl *)GET_NEXT(preq->rq_ind.rq_queuejob.rq_attr);

  while (psatl != NULL)
    {
    /* identify the attribute by name */

    index = find_attr(job_attr_def, psatl->al_name, JOB_ATR_LAST);

    if (index < 0)
      {
      /* FAILURE */

      /* didn`t recognize the name */

      index = JOB_ATR_UNKN; /* keep as "unknown" for now */
      }

    pdef = &job_attr_def[index];

    /* Is attribute not writeable by manager or by a server? */

    if ((pdef->at_flags & resc_access_perm) == 0)
      {
      /* FAILURE */

      job_purge(pj);

      reply_badattr(PBSE_ATTRRO, 1, psatl, preq);

      return;
      }

    /* decode attribute */

    rc = pdef->at_decode(
           &pj->ji_wattr[index],
           psatl->al_name,
           psatl->al_resc,
           psatl->al_value);

    if (rc != 0)
      {
      if (rc == PBSE_UNKRESC)
        {
        /* check for RM extension */

        /* NYI */

        /* unknown resources not allowed in Exec queue */

        if (pque->qu_qs.qu_type == QTYPE_Execution)
          {
          /* FAILURE */

          job_purge(pj);

          reply_badattr(rc, 1, psatl, preq);

          return;
          }
        }
      else
        {
        /* FAILURE */

        /* any other error is fatal */

        job_purge(pj);

        reply_badattr(rc, 1, psatl, preq);

        return;
        }
      }    /* END if (rc != 0) */

    psatl = (svrattrl *)GET_NEXT(psatl->al_link);
    }      /* END while (psatl != NULL) */

  /* perform any at_action routine declared for the attributes */

  for (i = 0;i < JOB_ATR_LAST;++i)
    {
    pdef = &job_attr_def[i];

    if ((pj->ji_wattr[i].at_flags & ATR_VFLAG_SET) && (pdef->at_action))
      {
      rc = pdef->at_action(&pj->ji_wattr[i], pj, ATR_ACTION_NEW);

      if (rc)
        {
        job_purge(pj);

        req_reject(rc, i, preq, NULL, "cannot execute attribute action");

        return;
        }
      }
    }    /* END for (i) */

  /*
   * Now that the attributes have been decoded, we can setup some
   * additional parameters and perform a few more checks.
   *
   * First, set some items based on who created the job...
   */

#ifdef GSSAPI
  /* save gssapi/krb5 creds for this job */
  if (svr_conn[preq->rq_conn].cn_authen == PBS_NET_CONN_GSSAPIAUTH) {
      sprintf(log_buffer,"saving creds.  conn is %d, princ %s",
          preq->rq_conn, svr_conn[preq->rq_conn].principal);
      log_event(PBSEVENT_DEBUG,
            PBS_EVENTCLASS_SERVER,"req_quejob",log_buffer);

      (void)job_attr_def[(int)JOB_SITE_ATR_krb_princ].at_decode(
	&pj->ji_wattr[(int)JOB_SITE_ATR_krb_princ],
        NULL, NULL, svr_conn[preq->rq_conn].principal);

   if (server.sv_attr[SRV_ATR_krb_realm_submit_acl].at_flags & ATR_VFLAG_SET)
     {
     if (!acl_check(&server.sv_attr[SRV_ATR_krb_realm_submit_acl],svr_conn[preq->rq_conn].principal,ACL_Host))
       {
       job_purge(pj);
       req_reject(PBSE_KERBEROS_ACL, 0, preq, NULL, NULL);
       return;
       }
     }

#if 0
      /* verify match between effective user and kerberos principal */
      if (pj->ji_wattr[(int)JOB_ATR_euser].at_flags & ATR_VFLAG_SET)
      if (strncmp(pj->ji_wattr[(int)JOB_ATR_euser].at_val.at_str,
      		      pj->ji_wattr[(int)JOB_SITE_ATR_krb_princ].at_val.at_str,
      		      strlen(pj->ji_wattr[(int)JOB_ATR_euser].at_val.at_str)) != 0)
        {
      	  job_purge(pj);

      	  req_reject(PBSE_KERBEROS_USER, 0, preq, NULL, NULL);
          return;
        }
#endif
  }
#endif /* GSSAPI */

  if (created_here)
    {
    /* created here */

    /* check that job has a jobname */

    if ((pj->ji_wattr[(int)JOB_ATR_jobname].at_flags & ATR_VFLAG_SET) == 0)
      {
      if (is_cloud_job(pj)) /* cloud jobs need job names */
        {
        job_purge(pj);

        req_reject(PBSE_BADATVAL, 0, preq, NULL, "job name is required for cloud jobs");

        return;
        }

      job_attr_def[(int)JOB_ATR_jobname].at_decode(
        &pj->ji_wattr[(int)JOB_ATR_jobname],
        NULL,
        NULL,
        "none");
      }

    /* check value of priority */

    if (pj->ji_wattr[(int)JOB_ATR_priority].at_flags & ATR_VFLAG_SET)
      {
      if ((pj->ji_wattr[(int)JOB_ATR_priority].at_val.at_long < -1024) ||
          (pj->ji_wattr[(int)JOB_ATR_priority].at_val.at_long > 1024))
        {
        job_purge(pj);

        req_reject(PBSE_BADATVAL, 0, preq, NULL, "invalid job priority");

        return;
        }
      }

    /* set job owner attribute to user@host */

    job_attr_def[(int)JOB_ATR_job_owner].at_free(
      &pj->ji_wattr[(int)JOB_ATR_job_owner]);

    strcpy(buf, preq->rq_user);

    strcat(buf, "@");

    strcat(buf, preq->rq_host);

    job_attr_def[(int)JOB_ATR_job_owner].at_decode(
      &pj->ji_wattr[(int)JOB_ATR_job_owner],
      NULL,
      NULL,
      buf);

    /* set create time */

    pj->ji_wattr[(int)JOB_ATR_ctime].at_val.at_long = (long)time_now;

    pj->ji_wattr[(int)JOB_ATR_ctime].at_flags |= ATR_VFLAG_SET;

    /* set hop count = 1 */

    pj->ji_wattr[(int)JOB_ATR_hopcount].at_val.at_long = 1;

    pj->ji_wattr[(int)JOB_ATR_hopcount].at_flags |= ATR_VFLAG_SET;

    /* Interactive jobs are necessarily not rerunable */

    if ((pj->ji_wattr[(int)JOB_ATR_interactive].at_flags & ATR_VFLAG_SET) &&
        pj->ji_wattr[(int)JOB_ATR_interactive].at_val.at_long)
      {
      pj->ji_wattr[(int)JOB_ATR_rerunable].at_val.at_long = 0;
      pj->ji_wattr[(int)JOB_ATR_rerunable].at_flags |= ATR_VFLAG_SET;
      }

    /* need to set certain environmental variables per POSIX */

    clear_attr(&tempattr, &job_attr_def[(int)JOB_ATR_variables]);

    strcpy(buf, pbs_o_que);

    strcat(buf, pque->qu_qs.qu_name);

    if (get_variable(pj, pbs_o_host) == NULL)
      {
      strcat(buf, ",");
      strcat(buf, pbs_o_host);
      strcat(buf, "=");
      strcat(buf, preq->rq_host);
      }

    job_attr_def[(int)JOB_ATR_variables].at_decode(
        &tempattr,
        NULL,
        NULL,
        buf);

    job_attr_def[(int)JOB_ATR_variables].at_set(
      &pj->ji_wattr[(int)JOB_ATR_variables],
      &tempattr,
      INCR);

    job_attr_def[(int)JOB_ATR_variables].at_free(&tempattr);

    /* if JOB_ATR_outpath/JOB_ATR_errpath not set, set default */

    if (!(pj->ji_wattr[(int)JOB_ATR_outpath].at_flags & ATR_VFLAG_SET) ||
        (((pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str[strlen(pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str) - 1] == ':'))))
      {
      pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str =
        prefix_std_file(pj, (int)'o');

      pj->ji_wattr[(int)JOB_ATR_outpath].at_flags |= ATR_VFLAG_SET;
      }
    /*
     * if the output path was specified and ends with a '/'
     * then append the standard file name
     */
    else if ((pj->ji_wattr[(int)JOB_ATR_outpath].at_flags & ATR_VFLAG_SET) &&
        (((pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str[strlen(pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str) - 1] == '/'))))
      {
        pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str[strlen(pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str) - 1] = '\0';

        replace_attr_string(
          &pj->ji_wattr[(int)JOB_ATR_outpath],
          (add_std_filename(pj,
          pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str,
          (int)'o')));
      }

    if (!(pj->ji_wattr[(int)JOB_ATR_errpath].at_flags & ATR_VFLAG_SET) ||
        (((pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str[strlen(pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str) - 1] == ':'))))
      {
      pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str =
        prefix_std_file(pj, (int)'e');

      pj->ji_wattr[(int)JOB_ATR_errpath].at_flags |= ATR_VFLAG_SET;
      }
    /*
     * if the error path was specified and ends with a '/'
     * then append the standard file name
     */
    else if ((pj->ji_wattr[(int)JOB_ATR_errpath].at_flags & ATR_VFLAG_SET) &&
        (((pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str[strlen(pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str) - 1] == '/'))))
      {
        pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str[strlen(pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str) - 1] = '\0';

        replace_attr_string(
          &pj->ji_wattr[(int)JOB_ATR_errpath],
          (add_std_filename(pj,
          pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str,
          (int)'e')));
      }

    if ((pj->ji_wattr[(int)JOB_ATR_outpath].at_val.at_str == NULL) ||
        (pj->ji_wattr[(int)JOB_ATR_errpath].at_val.at_str == NULL))
      {
      job_purge(pj);

      req_reject(PBSE_NOATTR, 0, preq, NULL, "no output/error file specified");

      return;
      }

    /* If queue has checkpoint directory name specified, propagate it to the job. */

    if (!(pj->ji_wattr[(int)JOB_ATR_checkpoint_dir].at_flags & ATR_VFLAG_SET))
      {
      attribute *pattr;
      char *vp;

      pattr = &pj->ji_wattr[(int)JOB_ATR_checkpoint];

      if ((pattr->at_flags & ATR_VFLAG_SET) &&
          (vp = csv_find_value(pattr->at_val.at_str, "dir")))
        {
        clear_attr(
          &pj->ji_wattr[(int)JOB_ATR_checkpoint_dir],
          &job_attr_def[(int)JOB_ATR_checkpoint_dir]);

        job_attr_def[(int)JOB_ATR_checkpoint_dir].at_decode(
          &pj->ji_wattr[(int)JOB_ATR_checkpoint_dir],
          NULL,
          NULL,
          vp);
        }
      else if ((pque->qu_attr[(int)QE_ATR_checkpoint_dir].at_flags & ATR_VFLAG_SET) &&
               (pque->qu_attr[(int)QE_ATR_checkpoint_dir].at_val.at_str))
        {
        job_attr_def[(int)JOB_ATR_checkpoint_dir].at_set(
          &pj->ji_wattr[(int)JOB_ATR_checkpoint_dir],
          &pque->qu_attr[(int)QE_ATR_checkpoint_dir],
          SET);
        }
      else if ((server.sv_attr[(int)SRV_ATR_checkpoint_dir].at_flags & ATR_VFLAG_SET) &&
               (server.sv_attr[(int)SRV_ATR_checkpoint_dir].at_val.at_str))
        {
        job_attr_def[(int)JOB_ATR_checkpoint_dir].at_set(
          &pj->ji_wattr[(int)JOB_ATR_checkpoint_dir],
          &server.sv_attr[(int)SRV_ATR_checkpoint_dir],
          SET);
        }
      }

#ifdef PNOT
    /*************************************************************
     * Argonne National Laboratory Account/Project enforcement patch
     *     Dec 2000, Sep 2004, JP Navarro navarro@mcs.anl.gov
     * Verify the specified account (project) is valid for the user
     * If none is specified, assign the user's default if allowed
     * Else return error: valid user account is required
     *************************************************************/

    if (pj->ji_wattr[(int)JOB_ATR_account].at_flags & ATR_VFLAG_SET)
      {
      /* account specified, reject if it's not valid for user */

      if (user_account_verify(
            preq->rq_user,
            pj->ji_wattr[(int)JOB_ATR_account].at_val.at_str) == 0)
        {
        job_purge(pj);

        req_reject(PBSE_BADACCT, 0, preq, NULL, "invalid account");

        return;
        }
      }
    else
      {
      /* account not specified, get default value */

      job_attr_def[(int)JOB_ATR_account].at_decode(
        &pj->ji_wattr[(int)JOB_ATR_account],
        NULL,
        NULL,
        (char *)user_account_default(preq->rq_user));

      if (pj->ji_wattr[(int)JOB_ATR_account].at_val.at_str == 0)
        {
        /* no default found */

        job_purge(pj);

        req_reject(PBSE_BADACCT, 0, preq, NULL, "no default account available");

        return;
        }
      }

#endif /* PNOT */
    }  /* END if (created_here) */
  else
    {
    /* job was created elsewhere and moved here */

    /* make sure job_owner is set, error if not */

    if (!(pj->ji_wattr[(int)JOB_ATR_job_owner].at_flags & ATR_VFLAG_SET))
      {
      job_purge(pj);

      log_err(errno, "req_quejob", "job owner not set");

      req_reject(PBSE_IVALREQ, 0, preq, NULL, "no job owner specified");

      return;
      }

    /* increment hop count */

    if (++pj->ji_wattr[(int)JOB_ATR_hopcount].at_val.at_long > PBS_MAX_HOPCOUNT)
      {
      job_purge(pj);

      req_reject(PBSE_HOPCOUNT, 0, preq, NULL, "max job hop reached");

      return;
      }
    }

  /* set up at_server attribute for status */

  job_attr_def[(int)JOB_ATR_at_server].at_decode(
    &pj->ji_wattr[(int)JOB_ATR_at_server],
    NULL,
    NULL,
    server_name);

  /* filter/modify the received job */
  int ret = filter_job(pj);
  if (ret != 0)
    {
    job_purge(pj);
    if (ret == 1)
      req_reject(PBSE_SYSTEM, 0, preq, NULL, "Couldn't allocate memory for filtered nodespec");
    else if (ret == -1)
      req_reject(PBSE_SYSTEM, 0, preq, NULL, "Empty resources are not allowed in job submission.");
    return;
    }

  /* Generate the resources total job attribute
   *
   * This attribute contains all counted resources
   * from both the nodespec request and resource requests.
   */
  regenerate_total_resources(pj);

  /*
   * See if the job is qualified to go into the requested queue.
   * Note, if an execution queue, then ji_qs.ji_un.ji_exect is set up
   *
   * svr_chkque() is called way down here because it needs to have the
   * job structure and attributes already set up.
   */

  if ((rc = svr_chkque(pj, pque, preq->rq_host, MOVE_TYPE_Move, EMsg)))
    {
    job_purge(pj);

    req_reject(rc, 0, preq, NULL, EMsg);

    return;
    }

  /* If this is a cloud create job, check if the requested name is unique */
  if (is_cloud_job(pj) && find_job_by_name(pj->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str))
    {
    job_purge(pj);
    req_reject(PBSE_CLOUD_NAME,0,preq,NULL,NULL);
    return;
    }

  /* "internal_" prefix in job name is reserved for system jobs */
  if (strncmp(pj->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str,"internal_",strlen("internal_")) == 0)
    {
    job_purge(pj);
    req_reject(PBSE_CLOUD_NAME,0,preq,NULL,NULL);
    return;
    }

  /* FIXME: if EMsg[0] != '\0', send a warning email to the user */

  strcpy(pj->ji_qs.ji_queue, pque->qu_qs.qu_name);

  pj->ji_wattr[(int)JOB_ATR_substate].at_val.at_long = JOB_SUBSTATE_TRANSIN;

  pj->ji_wattr[(int)JOB_ATR_substate].at_flags |= ATR_VFLAG_SET;

  /* set remaining job structure elements */

  pj->ji_qs.ji_state =    JOB_STATE_TRANSIT;

  pj->ji_qs.ji_substate = JOB_SUBSTATE_TRANSIN;

  pj->ji_wattr[(int)JOB_ATR_mtime].at_val.at_long = (long)time_now;

  pj->ji_wattr[(int)JOB_ATR_mtime].at_flags |= ATR_VFLAG_SET;

  pj->ji_qs.ji_un_type = JOB_UNION_TYPE_NEW;

  pj->ji_qs.ji_un.ji_newt.ji_fromsock = sock;

  pj->ji_qs.ji_un.ji_newt.ji_fromaddr = get_connectaddr(sock);

  pj->ji_qs.ji_un.ji_newt.ji_scriptsz = 0;

  pj->ji_expanded_spec = NULL;

  /* acknowledge the request with the job id */

  if (reply_jobid(preq, pj->ji_qs.ji_jobid, BATCH_REPLY_CHOICE_Queue) != 0)
    {
    /* reply failed, purge the job and close the connection */

    close_conn(sock);

    job_purge(pj);

    return;
    }

  /* link job into server's new jobs list request  */

  append_link(&svr_newjobs, &pj->ji_alljobs, pj);

#ifdef HAVE_GLITE_LB
  svr_logjobstate(pj, JOB_STATE_TRANSIT, JOB_SUBSTATE_TRANSIN, preq);
#endif

  return;
  }  /* END req_quejob() */





/*
 * req_jobcredential - receive a set of credentials to be used by the job
 *
 * THIS IS JUST A PLACE HOLDER FOR NOW
 * It does nothing but acknowledge the request
 */

void req_jobcredential(

  struct batch_request *preq)  /* ptr to the decoded request   */

  {
  job *pj;

  pj = locate_new_job(preq->rq_conn, NULL);

  if (pj == NULL)
    {
    req_reject(PBSE_IVALREQ, 0, preq, NULL, NULL);

    return;
    }

  if (svr_authorize_jobreq(preq, pj) == -1)
    {
    req_reject(PBSE_PERM, 0, preq, NULL, "job request not authorized");

    return;
    }

  reply_ack(preq);

  return;
  }  /* END req_jobcredential() */




/*
 * req_jobscript - receive job script section
 *
 * Each section is appended to the file
 */

void req_jobscript(

  struct batch_request *preq) /* ptr to the decoded request*/

  {
  char *id = "req_jobscript";

  int  fds;
  char  namebuf[MAXPATHLEN];
  job *pj;
  int  filemode = 0600;

  errno = 0;

  pj = locate_new_job(preq->rq_conn, preq->rq_ind.rq_jobfile.rq_jobid);

  if (pj == NULL)
    {
    log_err(errno, id, "cannot locate new job");

    req_reject(PBSE_IVALREQ, 0, preq, NULL, NULL);

    return;
    }

  /* what is the difference between JOB_SUBSTATE_TRANSIN and TRANSICM? */

  if (pj->ji_qs.ji_substate != JOB_SUBSTATE_TRANSIN)
    {
    if (errno == 0)
      {
      sprintf(log_buffer, "job %s in unexpected state '%s'",
              pj->ji_qs.ji_jobid,
              PJobSubState[pj->ji_qs.ji_substate]);
      }
    else
      {
      sprintf(log_buffer, "job %s in unexpected state '%s' (errno=%d - %s)",
              pj->ji_qs.ji_jobid,
              PJobSubState[pj->ji_qs.ji_substate],
              errno,
              strerror(errno));
      }

    log_err(errno, id, log_buffer);

    req_reject(PBSE_IVALREQ, 0, preq, NULL, log_buffer);

    return;
    }

  if (svr_authorize_jobreq(preq, pj) == -1)
    {
    /* FAILURE */

    log_err(errno, id, "cannot authorize request");

    req_reject(PBSE_PERM, 0, preq, NULL, "cannot receive job script");

    return;
    }

  strcpy(namebuf, path_jobs);

  strcat(namebuf, pj->ji_qs.ji_fileprefix);
  strcat(namebuf, JOB_SCRIPT_SUFFIX);

  if (pj->ji_qs.ji_un.ji_newt.ji_scriptsz == 0)
    {
    /* NOTE:  fail is job script already exists */

    fds = open(namebuf, O_WRONLY | O_CREAT | O_EXCL | O_Sync, filemode);
    }
  else
    {
    fds = open(namebuf, O_WRONLY | O_APPEND | O_Sync, filemode);
    }

  if (fds < 0)
    {
    char tmpLine[1024];

    snprintf(tmpLine, sizeof(tmpLine), "cannot open '%s' errno=%d - %s",
             namebuf,
             errno,
             strerror(errno));

    /* FAILURE */

    /* NOTE: log_err may modify errno */

    log_err(errno, id, msg_script_open);

    req_reject(PBSE_INTERNAL, 0, preq, NULL, tmpLine);

    return;
    }

  if (write(
        fds,
        preq->rq_ind.rq_jobfile.rq_data,
        (unsigned)preq->rq_ind.rq_jobfile.rq_size) != preq->rq_ind.rq_jobfile.rq_size)
    {
    /* FAILURE */

    log_err(errno, id, msg_script_write);

    req_reject(PBSE_INTERNAL, 0, preq, NULL, "cannot write job command file");

    close(fds);

    return;
    }

  close(fds);

  pj->ji_qs.ji_un.ji_newt.ji_scriptsz += preq->rq_ind.rq_jobfile.rq_size;

  /* job has a script file */

  pj->ji_qs.ji_svrflags =
    (pj->ji_qs.ji_svrflags & ~JOB_SVFLG_CHECKPOINT_FILE) | JOB_SVFLG_SCRIPT;

  /* SUCCESS */

  reply_ack(preq);

  return;
  }  /* END req_jobscript() */




/* the following is for the server only, MOM has her own version below */

/*
 * req_mvjobfile - receive a job file
 * This request is used to move a file associated with a job, typically
 * the standard output or error, between a server and a server or from
 * a mom back to a server.  For a server, the destination is always
 * within the spool directory.
 */

void req_mvjobfile(  /* NOTE:  routine for server only - mom code follows this routine */

  struct batch_request *preq) /* ptr to the decoded request   */

  {
  int  fds;
  char  namebuf[MAXPATHLEN];
  job *pj;

  pj = locate_new_job(preq->rq_conn, NULL);

  if (pj == NULL)
    pj = find_job(preq->rq_ind.rq_jobfile.rq_jobid);

  if ((preq->rq_fromsvr == 0) || (pj == NULL))
    {
    snprintf(log_buffer, 1024, "cannot find job %s",
             preq->rq_ind.rq_jobfile.rq_jobid);

    log_err(errno, "req_mvjobfile", log_buffer);

    req_reject(PBSE_IVALREQ, 0, preq, NULL, NULL);

    return;
    }

  strcpy(namebuf, path_spool);

  strcat(namebuf, pj->ji_qs.ji_fileprefix);

  switch ((enum job_file)preq->rq_ind.rq_jobfile.rq_type)
    {

    case StdOut:

      strcat(namebuf, JOB_STDOUT_SUFFIX);

      break;

    case StdErr:

      strcat(namebuf, JOB_STDERR_SUFFIX);

      break;

    case Checkpoint:

      strcat(namebuf, JOB_CHECKPOINT_SUFFIX);

      break;

    default:

      log_err(errno, "req_mvjobfile", "unexpected move type");

      req_reject(PBSE_IVALREQ, 0, preq, NULL, NULL);

      return;

      /*NOTREACHED*/

      break;
    }

  if (preq->rq_ind.rq_jobfile.rq_sequence == 0)
    {
    unlink(namebuf);
    fds = open(namebuf, O_WRONLY | O_CREAT | O_EXCL | O_Sync, 0600);
    }
  else
    fds = open(namebuf, O_WRONLY | O_APPEND | O_Sync, 0600);

  if (fds < 0)
    {
    log_err(errno, "req_mvjobfile", msg_script_open);

    req_reject(PBSE_INTERNAL, 0, preq, NULL, NULL);

    return;
    }

  if (write(
        fds,
        preq->rq_ind.rq_jobfile.rq_data,
        (unsigned)preq->rq_ind.rq_jobfile.rq_size) != preq->rq_ind.rq_jobfile.rq_size)
    {
    log_err(errno, "req_jobfile", msg_script_write);

    req_reject(PBSE_SYSTEM, 0, preq, NULL, NULL);

    close(fds);

    return;
    }

  close(fds);

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer, "successfully moved file '%s' for job '%s'",
            namebuf,
            preq->rq_ind.rq_jobfile.rq_jobid);

    log_record(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
      log_buffer);
    }

  reply_ack(preq);

  return;
  }  /* END req_mvjobfile() */




/*
 * req_rdytocommit - Ready To Commit Batch Request
 *
 * Set substate to JOB_SUBSTATE_TRANSICM and
 * record job to permanent storage, i.e. written to the job save file
 *      (called by both pbs_server and pbs_mom)
 */

void req_rdytocommit(

  struct batch_request *preq)  /* I */

  {
  job *pj;
  int  sock = preq->rq_conn;

  int  OrigState;
  int  OrigSState;
  char OrigSChar;
  long OrigFlags;

  char namebuf[MAXPATHLEN+1];

  pj = locate_new_job(sock, preq->rq_ind.rq_rdytocommit);

  if (LOGLEVEL >= 6)
    {
    log_record(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
      "ready to commit job");
    }

  if (pj == NULL)
    {
    log_err(errno, "req_rdytocommit", "unknown job id");

    req_reject(PBSE_UNKJOBID, 0, preq, NULL, NULL);

    /* FAILURE */

    return;
    }

  if (pj->ji_qs.ji_substate != JOB_SUBSTATE_TRANSIN)
    {
    log_err(errno, "req_rdytocommit", "cannot commit job in unexpected state");

    req_reject(PBSE_IVALREQ, 0, preq, NULL, NULL);

    /* FAILURE */

    return;
    }

  if (svr_authorize_jobreq(preq, pj) == -1)
    {
    req_reject(PBSE_PERM, 0, preq, NULL, "cannot authorize jobreq");

    /* FAILURE */

    return;
    }

  OrigState  = pj->ji_qs.ji_state;

  OrigSState = pj->ji_qs.ji_substate;
  OrigSChar  = pj->ji_wattr[(int)JOB_ATR_state].at_val.at_char;
  OrigFlags  = pj->ji_wattr[(int)JOB_ATR_state].at_flags;

  pj->ji_qs.ji_state    = JOB_STATE_TRANSIT;
  pj->ji_qs.ji_substate = JOB_SUBSTATE_TRANSICM;
  pj->ji_wattr[(int)JOB_ATR_state].at_val.at_char = 'T';
  pj->ji_wattr[(int)JOB_ATR_state].at_flags |= ATR_VFLAG_SET;

  if (pj->ji_wattr[(int)JOB_ATR_job_array_request].at_flags & ATR_VFLAG_SET)
    {
    pj->ji_isparent = TRUE;

    strcpy(namebuf, path_jobs);
    strcat(namebuf, pj->ji_qs.ji_fileprefix);
    strcat(namebuf, JOB_FILE_SUFFIX);
    unlink(namebuf);

    }

  if (job_save(pj, SAVEJOB_NEW) == -1)
    {
    char tmpLine[1024];

    sprintf(tmpLine, "cannot save job - errno=%d - %s",
            errno,
            strerror(errno));

    log_err(errno, "req_rdytocommit", tmpLine);

    /* commit failed, backoff state changes */

    pj->ji_qs.ji_state    = OrigState;
    pj->ji_qs.ji_substate = OrigSState;
    pj->ji_wattr[(int)JOB_ATR_state].at_val.at_char = OrigSChar;
    pj->ji_wattr[(int)JOB_ATR_state].at_flags = OrigFlags;

    req_reject(PBSE_SYSTEM, 0, preq, NULL, tmpLine);

#ifdef HAVE_GLITE_LB
    svr_logjobstate(pj, OrigState, OrigSState, preq);
#endif

    /* FAILURE */

    return;
    }

#ifdef HAVE_GLITE_LB
  svr_logjobstate(pj, JOB_STATE_TRANSIT, JOB_SUBSTATE_TRANSICM, preq);
#endif

  /* acknowledge the request with the job id */

  if (reply_jobid(preq, pj->ji_qs.ji_jobid, BATCH_REPLY_CHOICE_RdytoCom) != 0)
    {
    /* reply failed, purge the job and close the connection */

    sprintf(log_buffer, "cannot report jobid - errno=%d - %s",
            errno,
            strerror(errno));

    log_err(errno, "req_rdytocommit", log_buffer);

    close_conn(sock);

    job_purge(pj);

    /* FAILURE */

    return;
    }

  if (LOGLEVEL >= 6)
    {
    log_record(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
      "ready to commit job completed");
    }

  return;
  }  /* END req_rdytocommit() */




/*
 * req_commit - commit ownership of job
 *
 * Set state of job to JOB_STATE_QUEUED (or Held or Waiting) and
 * enqueue the job into its destination queue.
 */

void req_commit(

  struct batch_request *preq)  /* I */

  {
  job   *pj;

  int    newstate;
  int    newsub;
  pbs_queue *pque;
  int    rc;

#ifdef AUTORUN_JOBS

  struct batch_request *preq_run = '\0';
  attribute *pattr;
  int nodes_avail = -1;
  int dummy;
  char *spec = NULL;
  char *rq_destin = NULL;
#endif /* AUTORUN_JOBS */

#ifdef QUICKCOMMIT
  int  OrigState;
  int  OrigSState;
  char OrigSChar;
  long OrigFlags;

  char namebuf[MAXPATHLEN+1];
#endif /* QUICKCOMMIT */

  pj = locate_new_job(preq->rq_conn, preq->rq_ind.rq_commit);

  if (LOGLEVEL >= 6)
    {
    log_record(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
      "committing job");
    }

  if (pj == NULL)
    {
    req_reject(PBSE_UNKJOBID, 0, preq, NULL, NULL);

    return;
    }

#ifdef QUICKCOMMIT
  if (pj->ji_qs.ji_substate != JOB_SUBSTATE_TRANSIN)
    {
    log_err(errno, "req_commit", "cannot commit job in unexpected state");

    req_reject(PBSE_IVALREQ, 0, preq, NULL, NULL);

    /* FAILURE */

    return;
    }

  OrigState  = pj->ji_qs.ji_state;

  OrigSState = pj->ji_qs.ji_substate;
  OrigSChar  = pj->ji_wattr[(int)JOB_ATR_state].at_val.at_char;
  OrigFlags  = pj->ji_wattr[(int)JOB_ATR_state].at_flags;

  pj->ji_qs.ji_state    = JOB_STATE_TRANSIT;
  pj->ji_qs.ji_substate = JOB_SUBSTATE_TRANSICM;
  pj->ji_wattr[(int)JOB_ATR_state].at_val.at_char = 'T';
  pj->ji_wattr[(int)JOB_ATR_state].at_flags |= ATR_VFLAG_SET;

  if (pj->ji_wattr[(int)JOB_ATR_job_array_request].at_flags & ATR_VFLAG_SET)
    {
    pj->ji_isparent = TRUE;

    strcpy(namebuf, path_jobs);
    strcat(namebuf, pj->ji_qs.ji_fileprefix);
    strcat(namebuf, JOB_FILE_SUFFIX);
    unlink(namebuf);

    }

#endif /* QUICKCOMMIT */

  if (pj->ji_qs.ji_substate != JOB_SUBSTATE_TRANSICM)
    {
    log_err(errno, "req_commit", "cannot commit job in unexpected state");

    req_reject(PBSE_IVALREQ, 0, preq, NULL, NULL);

    return;
    }

  if (svr_authorize_jobreq(preq, pj) == -1)
    {
    req_reject(PBSE_PERM, 0, preq, NULL, NULL);

    if (LOGLEVEL >= 6)
      {
      log_record(
        PBSEVENT_JOB,
        PBS_EVENTCLASS_JOB,
        (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
        "no permission to start job");
      }

    return;
    }

  /* remove job from the server new job list, set state, and enqueue it */

  delete_link(&pj->ji_alljobs);

  /* job array, setup cloning work task and reply with placeholder job id
     *** job array under development */
  if (pj->ji_wattr[(int)JOB_ATR_job_array_request].at_flags & ATR_VFLAG_SET)
    {
    if (setup_array_struct(pj))
      {
      req_reject(PBSE_BAD_ARRAY_REQ, 0, preq, NULL, NULL);
      return;
      }

    reply_jobid(preq, pj->ji_qs.ji_jobid, BATCH_REPLY_CHOICE_Commit);

    return;
    }  /* end if (pj->ji_wattr[(int)JOB_ATR_job_array_request].at_flags & ATR_VFLAG_SET) */

  svr_evaljobstate(pj, &newstate, &newsub, 1);
#ifdef HAVE_GLITE_LB
  svr_logjobstate(pj, newstate, newsub, preq);
#endif
  svr_setjobstate(pj, newstate, newsub);


  /* set the queue rank attribute */

  pj->ji_wattr[(int)JOB_ATR_qrank].at_val.at_long = ++queue_rank;

  pj->ji_wattr[(int)JOB_ATR_qrank].at_flags |= ATR_VFLAG_SET;

  if ((rc = svr_enquejob(pj,0)))
    {
    job_purge(pj);

    req_reject(rc, 0, preq, NULL, NULL);

    if (LOGLEVEL >= 6)
      {
      log_record(
        PBSEVENT_JOB,
        PBS_EVENTCLASS_JOB,
        (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
        "cannot queue job");
      }

    return;
    }

  if (job_save(pj, SAVEJOB_FULL) != 0)
    {
    job_purge(pj);

    req_reject(PBSE_SYSTEM, 0, preq, NULL, NULL);

    if (LOGLEVEL >= 6)
      {
      log_record(
        PBSEVENT_JOB,
        PBS_EVENTCLASS_JOB,
        (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
        "cannot save job");
      }

    return;
    }

  /* move and run request */
  if (preq->rq_extend != NULL)
    {
    if (assign_hosts(pj, preq->rq_extend, 1, NULL, NULL) != 0)
      {
      job_purge(pj);
      req_reject(PBSE_SYSTEM, 0, preq, NULL, NULL);
      return;
      }

    if (svr_startjob(pj, NULL, NULL, NULL) != 0)
      {
      job_purge(pj);
      req_reject(PBSE_SYSTEM, 0, preq, NULL, NULL); /* failed to run */
      return;
      }
    }

  /*
   * if the job went into a Route (push) queue that has been started,
   * try once to route it to give immediate feedback as a courtsey
   * to the user.
   */

  pque = pj->ji_qhdr;

  if ((preq->rq_fromsvr == 0) &&
      (pque->qu_qs.qu_type == QTYPE_RoutePush) &&
      (pque->qu_attr[(int)QA_ATR_Started].at_val.at_long != 0))
    {
    if ((rc = job_route(pj)))
      {
      job_purge(pj);

      req_reject(rc, 0, preq, NULL, NULL);

      if (LOGLEVEL >= 6)
        {
        log_record(
          PBSEVENT_JOB,
          PBS_EVENTCLASS_JOB,
          (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
          "job route job");
        }

      /* FAILURE */

      return;
      }

    if (pj == NULL)
      return;
    }

#ifdef AUTORUN_JOBS
  /* If we are auto running jobs with start_count = 0 then the
   * branch_request needs re creation since reply_jobid will free
   * the passed in one
  */
  pattr = &pj->ji_wattr[(int)JOB_ATR_start_count];

  spec = PBS_DEFAULT_NODE;

  node_avail_complex(spec, &nodes_avail, &dummy, &dummy, &dummy);

  if ((pattr->at_val.at_long == 0) && (nodes_avail > 0))
    {
    /* Create a new batch request and fill it in */
    preq_run = alloc_br(PBS_BATCH_AsyrunJob);
    preq_run->rq_perm = preq->rq_perm | ATR_DFLAG_OPWR;
    preq_run->rq_ind.rq_run.rq_resch = 0;
    preq_run->rq_ind.rq_run.rq_destin = rq_destin;
    preq_run->rq_fromsvr = preq->rq_fromsvr;
    preq_run->rq_extsz = preq->rq_extsz;
    preq_run->rq_noreply = TRUE; /* set for no replies */
    memcpy(preq_run->rq_user, preq->rq_user, PBS_MAXUSER + 1);
    memcpy(preq_run->rq_host, preq->rq_host, PBS_MAXHOSTNAME + 1);
    memcpy(preq_run->rq_ind.rq_run.rq_jid, preq->rq_ind.rq_rdytocommit,
           PBS_MAXSVRJOBID + 1);

    }

#endif

  /* need to format message first, before request goes away */

  sprintf(log_buffer, msg_jobnew,
          preq->rq_user, preq->rq_host,
          pj->ji_wattr[(int)JOB_ATR_job_owner].at_val.at_str,
          pj->ji_wattr[(int)JOB_ATR_jobname].at_val.at_str,
          pj->ji_qhdr->qu_qs.qu_name);

  /* acknowledge the request with the job id */

  reply_jobid(preq, pj->ji_qs.ji_jobid, BATCH_REPLY_CHOICE_Commit);


  LOG_EVENT(
    PBSEVENT_JOB,
    PBS_EVENTCLASS_JOB,
    pj->ji_qs.ji_jobid,
    log_buffer);

  if ((pj->ji_qs.ji_svrflags & JOB_SVFLG_HERE) == 0)
    {
    /* notify creator where job is */

    issue_track(pj);
    }

#ifdef AUTORUN_JOBS
  /* If we are auto running jobs with start_count = 0 then the
   * branch_request was re created. Now we run the job if any nodes
   * are available
  */

  if ((pattr->at_val.at_long == 0) && (nodes_avail > 0))
    {
    if (LOGLEVEL >= 7)
      {
      sprintf(log_buffer, "Trying to AUTORUN job %s",
              pj->ji_qs.ji_jobid);
      log_record(
        PBSEVENT_JOB,
        PBS_EVENTCLASS_JOB,
        (pj != NULL) ? pj->ji_qs.ji_jobid : "NULL",
        log_buffer);
      }

    req_runjob(preq_run);
    }

#endif /* AUTORUN_JOBS */

  return;
  }  /* END req_commit() */


/*
 * locate_new_job - locate a "new" job which has been set up req_quejob on
 * the servers new job list.
 *
 * This function is used by the sub-requests which make up the global
 * "Queue Job Request" to locate the job structure.
 *
 * If the jobid is specified (will be for rdytocommit and commit, but not
 * for script), we search for a matching jobid.
 *
 * The job must (also) match the socket specified and the host associated
 * with the socket unless ji_fromsock == -1, then its a recovery situation.
 */
/* FIXME: why bother checking for matching sock if a jobid is supplied?  Seems
 * to me that a reconnect immediately invalidates fromsock.
 */

static job *locate_new_job(

  int   sock,   /* I */
  char *jobid)  /* I (optional) */

  {
  job *pj;

  pj = (job *)GET_NEXT(svr_newjobs);

  while (pj != NULL)
    {
    if ((pj->ji_qs.ji_un.ji_newt.ji_fromsock == -1) ||
        ((pj->ji_qs.ji_un.ji_newt.ji_fromsock == sock) &&
         (pj->ji_qs.ji_un.ji_newt.ji_fromaddr == get_connectaddr(sock))))
      {
      if ((jobid != NULL) && (*jobid != '\0'))
        {
        if (!strncmp(pj->ji_qs.ji_jobid, jobid, PBS_MAXSVRJOBID))
          {
          /* requested job located */

          break;
          }
        }
      else if (pj->ji_qs.ji_un.ji_newt.ji_fromsock == -1)
        {
        /* empty job slot located */

        break;
        }
      else
        {
        /* matching job slot located */

        break;
        }
      }    /* END if ((pj->ji_qs.ji_un.ji_newt.ji_fromsock == -1) || ...) */

    pj = (job *)GET_NEXT(pj->ji_alljobs);
    }  /* END while(pj != NULL) */

  /* return job slot located (NULL on FAILURE) */

  return(pj);
  }  /* END locate_new_job() */




/*
 * City Tools patch
 */

#define UserAcctMax  12

struct
  {
  int  ActCnt;                          /* How many projects */
  int  ActMax;                          /* Max allowed in this struct */
  char ActRaw[80];                      /* The raw project data */
  char ActDat[80];                      /* ActRaw with \0 as necessary */
  char *ActAdr[UserAcctMax];            /* Pointers to ActDat items */
  } UserAcct =

  {
  0, UserAcctMax,
  "", "",
    {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0}
  };   /* UserAcctMax values */



#ifdef PNOT
int user_account_verify(

  char *arguser,
  char *argaccount)

  {
  int  i;
  int  rc = 0; /* 0 = failure, 1 = success */

  if (!user_account_read_user(arguser))
    {
    sprintf(log_buffer, "user_account_verify(%s, %s) -> USER NOT FOUND",
            arguser,
            argaccount);

    goto user_account_verify_done;
    }

  for (i = 0;i < UserAcct.ActCnt;++i)
    {
    if (strcmp(argaccount, UserAcct.ActAdr[i]) == 0)
      {
      sprintf(log_buffer, "user_account_verify(%s, %s) -> SUCCESS",
              arguser,
              argaccount);

      rc = 1;

      goto user_account_verify_done;
      }
    }    /* END for (i) */

  sprintf(log_buffer, "user_account_verify(%s, %s) -> FAILED",
          arguser,
          argaccount);

user_account_verify_done:

  log_event(
    PBSEVENT_JOB | PBSEVENT_SECURITY,
    PBS_EVENTCLASS_SERVER,
    msg_daemonname,
    log_buffer);

  return(rc);
  }




char *user_account_default(

  char *arguser)

  {
  char *rc = 0; /* 0 = failure, <address> = success */

  if (!user_account_read_user(arguser))
    {
    sprintf(log_buffer, "user_account_default(%s) = USER NOT FOUND",
            arguser);

    goto user_account_default_done;
    }

  if (UserAcct.ActCnt < 1)
    {
    sprintf(log_buffer, "user_account_default(%s) = NO PROJECT FOUND",
            arguser);

    goto user_account_default_done;
    }

  rc = UserAcct.ActAdr[0];

  sprintf(log_buffer, "user_account_default(%s) = %s",
          arguser,
          rc);

user_account_default_done:

  log_event(
    PBSEVENT_JOB | PBSEVENT_SECURITY,
    PBS_EVENTCLASS_SERVER,
    msg_daemonname,
    log_buffer);

  return(rc);
  }  /* END user_account_default() */




/*
 * Given a username, returns that user's accounts from the user->account file
 * Returns 0 if username isn't found
 */

#define AcctScanUser  0
#define AcctScanAcct  1
#define AcctScanLine -1
#define AcctFile "/usr/local/etc/usertg/project-by-user-torque.map"

int user_account_read_user(

  char *arguser)

  {
  char  proj_file[] = AcctFile;
  int   fd;
  char  s_buf[128*1024];
  int   readsize;
  int   scanmode = AcctScanUser;
  int   i, j;
  char  *ci;
  char  *cj;

  int   arguserlen;

  arguserlen = strlen(arguser);

  if ((fd = open(proj_file, O_RDONLY, 0)) < 0)
    {
    return(0);
    }

  if (lseek(fd, (off_t)0, SEEK_SET) != 0)
    {
    close(fd);

    return(0);
    }

  readsize = read(fd, s_buf, sizeof(s_buf));

  close(fd);

  if ((readsize < 1) || (readsize > sizeof(s_buf)))
    {
    /* bail if not sane */

    return(0);
    }

  for (i = 0;i < readsize;++i)
    {
    /* First, handle comments and whitespace */

    if (scanmode == AcctScanLine)
      {
      /* Looking for new line */

      if (s_buf[i] == '\n')        /* Found it */
        scanmode = AcctScanUser;

      continue;
      }

    if (isspace(s_buf[i]))            /* Skip spaces */
      continue;

    if (s_buf[i] == '#')
      {
      /* Comment found */

      scanmode = AcctScanLine;

      continue;
      }

    /* Next, handle user and account scanning */

    if (scanmode == AcctScanUser)
      {
      if ((i + arguserlen) > readsize) /* Past the end */
        {
        return(0);
        }

      if (strncmp(&s_buf[i], arguser, arguserlen))
        {
        scanmode = AcctScanLine;   /* Not arguser, next line */

        continue;
        }

      if (isspace(s_buf[i + arguserlen]) ||
          s_buf[i + arguserlen] == ':')
        {
        i += arguserlen;            /* Is arguser */

        scanmode = AcctScanAcct;
        }
      else
        {
        /* Whatever, ignore it */

        scanmode = AcctScanLine;

        continue;
        }
      }
    else
      {
      /* scanmode == AcctScanAcct */

      if ((s_buf[i] == ':') || isspace(s_buf[i]))
        continue;

      for (j = i;j < readsize;j++)
        {
        if (isspace(s_buf[j]))
          {
          strncpy(UserAcct.ActRaw, &s_buf[i], j - i);
          UserAcct.ActRaw[j-i] = '\0';
          goto have_account;
          }
        }

      return(0);
      }
    }    /* END for (i) */

  return(0);                             /* Never found it */

have_account:

  if (strlen(UserAcct.ActRaw) < 1)       /* Nothing found */
    {
    return(0);
    }

  strcpy(UserAcct.ActDat, UserAcct.ActRaw);

  UserAcct.ActCnt = 0;
  UserAcct.ActMax = UserAcctMax;

  for (ci = &UserAcct.ActDat[0];*ci != '\0';ci++)
    {
    if (isspace(*ci) || (*ci == ','))
      continue;

    for (cj = ci + 1;!isspace(*cj) && (*cj != ',') && (*cj != '\0');cj++)
      {
      /* NO-OP */
      }

    *cj = '\0';

    UserAcct.ActAdr[UserAcct.ActCnt++] = ci;

    ci = cj;
    }

  return(1);
  }  /* END user_account_read_user() */

#endif /* PNOT */


/* END req_quejob.c() */

