/*
*         OpenPBS (Portable Batch System) v2.3 Software License
* 
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
* 
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
* 
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
* 
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
* 
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
* 
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
* 
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
* 
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
* 
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
* 
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
* 
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information 
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
* 
* 7. DISCLAIMER OF WARRANTY
* 
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
* 
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/
/*
 * Functions which provide basic operation on the job structure
 *
 * Included public functions are:
 *
 *   job_abt	  abort (remove from server) a job
 *   job_alloc    allocate job struct and initialize defaults
 *   job_free	  free space allocated to the job structure and its
 *		  childern structures.
 *   job_purge	  purge job from server
 *
 *   job_clone    clones a job (for use with job_arrays)
 *   job_clone_wt work task for cloning a job
 *
 * Include private function:
 *   job_init_wattr() initialize job working attribute array to "unspecified"
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include <sys/types.h>
#include <sys/param.h>
#include <sys/stat.h>
#include <ctype.h>
#include <errno.h>
#include <assert.h>

#ifndef SIGKILL
#include <signal.h>
#endif
#if __STDC__ != 1
#include <memory.h>
#endif

#include <fcntl.h>
#include <stdio.h>
#include <unistd.h>
#include <dirent.h>
#include <stdlib.h>
#include <string.h>
#include "pbs_ifl.h"
#include "list_link.h"
#include "work_task.h"
#include "attribute.h"
#include "resource.h"
#include "server_limits.h"
#include "server.h"
#include "queue.h"
#include "job.h"
#include "log.h"
#include "pbs_error.h"
#include "svrfunc.h"
#include "acct.h"
#include "net_connect.h"
#include "portability.h"

int conn_qsub(char *,long);


/* External functions */

#ifdef PBS_MOM
#if IBM_SP2==2		/* IBM SP PSSP 3.1 */
void unload_sp_switch A_((job *pjob));
#endif			/* IBM SP */
#endif	/*  PBS_MOM */

/* Local Private Functions */

static void job_init_wattr A_((job *));

/* Global Data items */

#ifndef PBS_MOM
extern struct server   server;
extern int queue_rank;
#else
extern gid_t pbsgroup;
#endif	/* PBS_MOM */
extern char *msg_abt_err;
extern char *path_jobs;
extern char *path_spool;
extern char *path_aux;
extern char  server_name[];
extern time_t time_now;
extern int   LOGLEVEL;

extern tlist_head svr_newjobs;
extern tlist_head svr_alljobs;


#ifdef PBS_MOM
void nodes_free A_((job *));
int TTmpDirName A_((job *,char *));


void tasks_free(

  job *pj)

  {
  task	*tp = (task *)GET_NEXT(pj->ji_tasks);
  obitent	*op;
  infoent *ip;

  while (tp != NULL) 
    {
    op = (obitent *)GET_NEXT(tp->ti_obits);

    while (op != NULL) 
      {
      delete_link(&op->oe_next);

      free(op);

      op = (obitent *)GET_NEXT(tp->ti_obits);
      }  /* END while (op != NULL) */

    ip = (infoent *)GET_NEXT(tp->ti_info);

    while (ip != NULL) 
      {
      delete_link(&ip->ie_next);

      free(ip->ie_name);
      free(ip->ie_info);
      free(ip);

      ip = (infoent *)GET_NEXT(tp->ti_info);
      }

    close_conn(tp->ti_fd);

    delete_link(&tp->ti_jobtask);

    free(tp);

    tp = (task *)GET_NEXT(pj->ji_tasks);
    }  /* END while (tp != NULL) */

  return;
  }  /* END tasks_free() */





/*
 * remtree - remove a tree (or single file)
 *
 *	returns	 0 on success
 *		-1 on failure
 */

int remtree(

  char *dirname)

  {
	static	char	id[] = "remtree";
	DIR		*dir;
	struct dirent	*pdir;
	char		namebuf[MAXPATHLEN], *filnam;
	int		i;
	int		rtnv = 0;
#if defined(HAVE_STRUCT_STAT64) && defined(HAVE_STAT64)
	struct stat64	sb;
#else
	struct stat	sb;
#endif

#if defined(HAVE_STRUCT_STAT64) && defined(HAVE_STAT64)
	if (lstat64(dirname, &sb) == -1) {
#else
	if (lstat(dirname, &sb) == -1) {
#endif
		if (errno != ENOENT)
			log_err(errno, id, "stat");
		return -1;
	}
	if (S_ISDIR(sb.st_mode)) {
	    if ((dir = opendir(dirname)) == NULL) {
		if (errno != ENOENT)
			log_err(errno, id, "opendir");
		return -1;
	    }

	    (void)strcpy(namebuf, dirname);
	    (void)strcat(namebuf, "/");
	    i = strlen(namebuf);
	    filnam = &namebuf[i];

	    while ((pdir = readdir(dir)) != NULL) {
		if ( pdir->d_name[0] == '.' &&
		    (pdir->d_name[1] == '\0' || pdir->d_name[1] == '.'))
			continue;

		(void)strcpy(filnam, pdir->d_name);

#if defined(HAVE_STRUCT_STAT64) && defined(HAVE_STAT64)
		if (lstat64(namebuf, &sb) == -1) {
#else
		if (lstat(namebuf, &sb) == -1) {
#endif
			log_err(errno, id, "stat");
			rtnv = -1;
			continue;
		}
		if (S_ISDIR(sb.st_mode)) {
			rtnv = remtree(namebuf);
		} else if (unlink(namebuf) < 0) {
			if (errno != ENOENT) {
			    sprintf(log_buffer, "unlink failed on %s", namebuf);
			    log_err(errno, id, log_buffer);
			    rtnv = -1;
			}
		}
	    }
	    (void)closedir(dir);
	    if (rmdir(dirname) < 0) {
		if ((errno != ENOENT) && (errno != EINVAL)) {
			sprintf(log_buffer, "rmdir failed on %s", dirname);
			log_err(errno, id, log_buffer);
			rtnv = -1;
		}
	    }
	} else if (unlink(dirname) < 0) {
		sprintf(log_buffer, "unlink failed on %s", dirname);
		log_err(errno, id, log_buffer);
		rtnv = -1;
	}

  return(rtnv);
  }  /* END remtree() */


#else	/* PBS_MOM */


void send_qsub_delmsg(job *pjob, char *text)
  {
  char *phost;
  attribute            *pattri;
  int qsub_sock;


    phost = arst_string("PBS_O_HOST",&pjob->ji_wattr[(int)JOB_ATR_variables]);

    if ((phost == NULL) || ((phost = strchr(phost,'=')) == NULL))
      {
      return;
      }

    pattri = &pjob->ji_wattr[(int)JOB_ATR_interactive];

    qsub_sock = conn_qsub(phost + 1,pattri->at_val.at_long);

    if (qsub_sock < 0)
      {
      return;
      }

    write(qsub_sock,"PBS: ",5);
    write(qsub_sock,text,strlen(text));

    close(qsub_sock);
  }


/*
 * job_abt - abort a job
 *
 *	The job removed from the system and a mail message is sent
 *	to the job owner.
 */

/* NOTE:  this routine is called under the following conditions:  ??? */

int job_abt(

  job  **pjobp, /* I (modified/freed) */
  char  *text)  /* I (optional) */

  {
  char *myid = "job_abt";
  int	old_state;
  int	old_substate;
  int	rc = 0;

  job *pjob = *pjobp;

  void job_purge A_((job *));

  /* save old state and update state to Exiting */

  old_state = pjob->ji_qs.ji_state;
  old_substate = pjob->ji_qs.ji_substate;

  /* notify user of abort if notification was requested */

  if (text != NULL) 
    {	
    /* req_delete sends own mail and acct record */

    account_record(PBS_ACCT_ABT,pjob,"");
    svr_mailowner(pjob,MAIL_ABORT,MAIL_NORMAL,text);

    if ((pjob->ji_qs.ji_state == JOB_STATE_QUEUED) &&
        ((pjob->ji_wattr[(int)JOB_ATR_interactive].at_flags & ATR_VFLAG_SET) &&
         pjob->ji_wattr[(int)JOB_ATR_interactive].at_val.at_long))
      {
      /* interactive and not yet running... send a note to qsub */

      send_qsub_delmsg(pjob,text);
      }
    }

  if (old_state == JOB_STATE_RUNNING) 
    {
    svr_setjobstate(pjob,JOB_STATE_RUNNING,JOB_SUBSTATE_ABORT);

    if ((rc = issue_signal(pjob,"SIGKILL",release_req,0)) != 0) 
      {
      sprintf(log_buffer,msg_abt_err, 
        pjob->ji_qs.ji_jobid,old_substate);

      log_err(-1,myid,log_buffer);

      if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) == 0) 
        {
        /* notify creator that job is exited */

        pjob->ji_wattr[(int)JOB_ATR_state].at_val.at_char = 'E';
   
        issue_track(pjob);
        }

      if (pjob->ji_wattr[(int)JOB_ATR_depend].at_flags & ATR_VFLAG_SET)
        {
        depend_on_term(pjob);
        }

      job_purge(pjob);

      *pjobp = NULL;
      }
    } 
  else if ((old_state == JOB_STATE_TRANSIT) && 
           (old_substate == JOB_SUBSTATE_TRNOUT)) 
    {
    /* I don't know of a case where this could happen */
  
    sprintf(log_buffer, msg_abt_err, 
      pjob->ji_qs.ji_jobid, 
      old_substate);

    log_err(-1,myid,log_buffer);
    } 
  else 
    {
    svr_setjobstate(pjob,JOB_STATE_EXITING,JOB_SUBSTATE_ABORT);

    if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) == 0) 
      {
      /* notify creator that job is exited */

      issue_track(pjob);
      }

    if (pjob->ji_wattr[(int)JOB_ATR_depend].at_flags & ATR_VFLAG_SET)
      {
      depend_on_term(pjob);
      }

    job_purge(pjob);

    *pjobp = NULL;
    }

  return(rc);
  }  /* END job_abt() */

#endif	/* else PBS_MOM */


/*
 * conn_qsub - connect to the qsub that submitted this interactive job
 * return >= 0 on SUCCESS, < 0 on FAILURE
 * (this was moved from resmom/mom_inter.c)
 */



int conn_qsub(

  char *hostname,
  long  port)

  {
  pbs_net_t hostaddr;
  int s;

  int flags;

  if ((hostaddr = get_hostaddr(hostname)) == (pbs_net_t)0)
    {
    return(-1);
    }

  s = client_to_svr(hostaddr,(unsigned int)port,0);

  /* NOTE:  client_to_svr() can return 0 for SUCCESS */

  /* assume SUCCESS requires s > 0 (USC) was 'if (s >= 0)' */
  /* above comment not enabled */

  if (s < 0)
    {
    /* FAILURE */

    return(-1);
    }

  /* this socket should be blocking */

  flags = fcntl(s,F_GETFL);

  flags &= ~O_NONBLOCK;

  fcntl(s,F_SETFL,flags);

  return(s);
  }  /* END conn_qsub() */




/*
 * job_alloc - allocate space for a job structure and initialize working
 *	attribute to "unset"
 *
 *	Returns: pointer to structure or null is space not available.
 */

job *job_alloc()

  {
  job *pj;

  pj = (job *)calloc(1,sizeof(job));

  if (pj == NULL) 
    {
    log_err(errno,"job_alloc","no memory");

    return(NULL);
    }

  CLEAR_LINK(pj->ji_alljobs);
  CLEAR_LINK(pj->ji_jobque);

#ifdef	PBS_MOM
  CLEAR_HEAD(pj->ji_tasks);
  pj->ji_taskid = TM_NULL_TASK + 1;
  pj->ji_numnodes = 0;
  pj->ji_numvnod  = 0;
  pj->ji_hosts = NULL;
  pj->ji_vnods = NULL;
  pj->ji_resources = NULL;
  pj->ji_obit = TM_NULL_EVENT;
  pj->ji_preq = NULL;
  pj->ji_nodekill = TM_ERROR_NODE;
  pj->ji_flags = 0;
  pj->ji_globid = NULL;
  pj->ji_stdout = 0;
  pj->ji_stderr = 0;
#else	/* SERVER */
  CLEAR_HEAD(pj->ji_svrtask);
  CLEAR_HEAD(pj->ji_rejectdest);
#endif  /* else PBS_MOM */

  pj->ji_momhandle = -1;		/* mark mom connection invalid */

  /* set the working attributes to "unspecified" */

  job_init_wattr(pj);

  return(pj);
  }  /* END job_alloc() */





/*
 * job_free - free job structure and its various sub-structures
 */

void job_free(

  job *pj)  /* I (modified) */

  {
  int			 i;

#ifndef PBS_MOM
  struct work_task	*pwt;
  badplace		*bp;
#endif /* PBS_MOM */

  if (LOGLEVEL >= 8)
    {
    sprintf(log_buffer,"freeing job");

    log_record(PBSEVENT_DEBUG,
      PBS_EVENTCLASS_JOB,
      pj->ji_qs.ji_jobid,
      log_buffer);
    }

  /* remove any malloc working attribute space */

  for (i = 0;i < (int)JOB_ATR_LAST;i++) 
    {
    job_attr_def[i].at_free(&pj->ji_wattr[i]);
    }

#ifndef PBS_MOM

  /* delete any work task entries associated with the job */

  while ((pwt = (struct work_task *)GET_NEXT(pj->ji_svrtask)) != NULL) 
    {
    delete_task(pwt);
    }

  /* free any bad destination structs */

  bp = (badplace *)GET_NEXT(pj->ji_rejectdest);

  while (bp != NULL) 
    {
    delete_link(&bp->bp_link);

    free(bp);

    bp = (badplace *)GET_NEXT(pj->ji_rejectdest);
    }

#else
 
  if (pj->ji_grpcache)
    free(pj->ji_grpcache);

  assert(pj->ji_preq == NULL);

  nodes_free(pj);
  tasks_free(pj);

  if (pj->ji_resources)
    free(pj->ji_resources);

  if (pj->ji_globid)
    free(pj->ji_globid);

#endif	/* PBS_MOM */

  /* now free the main structure */

  free((char *)pj);

  return;
  }  /* END job_free() */
  

#ifndef PBS_MOM

/*
 * job_clone - create a clone of a job for use with job arrays
 *   pj is the job to clone, and taksid is the job array id of the 
 *   newly cloned job
 */
job *job_clone(
  job *poldjob,
  int taskid
  )
  
  {

  static char   id[] = "job_clone";

  job		*pnewjob;
  attribute	tempattr;

  char		*oldid;
  char		*hostname;
  char		basename[PBS_JOBBASE+1];
  char		namebuf[MAXPATHLEN + 1];
  char		copybuf[4096];
  char		buf[256];
  char		*pc;
  int		fds;
  int		fds_source;

  int 		i;
  int		rc;

  pnewjob = job_alloc();

  if (pnewjob == NULL)
    {
    log_err(errno,id,"no memory");

    return(NULL);
    }

  job_init_wattr(pnewjob);
 
  /* new job structure is allocated, 
     now we need to copy the old job, but modify based on taskid */

  pnewjob->ji_alljobs = poldjob->ji_alljobs;	/* links to all jobs in server */
  pnewjob->ji_jobque = poldjob->ji_jobque;	/* SVR: links to jobs in same queue */
  pnewjob->ji_modified = 1;			/* struct changed, needs to be saved */
  pnewjob->ji_svrtask = poldjob->ji_svrtask;	/* links to svr work_task list */
  pnewjob->ji_qhdr = poldjob->ji_qhdr;		/* current queue header */
  CLEAR_HEAD(pnewjob->ji_rejectdest);		/* list of rejected destinations */
	
	
  /* copy the fixed size quick save information */
  memcpy(&pnewjob->ji_qs, &poldjob->ji_qs, sizeof(struct jobfix));

  /* pnewjob->ji_qs.ji_arrayid = taskid; */

  /* find the job id for the cloned job */
  oldid = strdup(poldjob->ji_qs.ji_jobid);
  if (oldid == NULL)
    {
    log_err(errno,id,"no memory");
    job_free(pnewjob);
    return(NULL);
    }

  hostname = index(oldid, '.');
  *(hostname++) = '\0';

  pnewjob->ji_qs.ji_jobid[PBS_MAXSVRJOBID] = '\0';
  snprintf(pnewjob->ji_qs.ji_jobid,PBS_MAXSVRJOBID,"%s-%d.%s",
           oldid,taskid,hostname);
  free(oldid);
  /* update the job filename
   * We could optimize the sub-jobs to all use the same file. We would need a 
   * way to track the number of tasks still using the job file so we know when
   * to delete it.  
   */

  /*
   * make up new job file name, it is based on the jobid, however the
   * minimun acceptable file name limit is only 14 character in POSIX, 
   * so we may have to "hash" the name slightly (if we are running on 
   * an ancient system). This code was lifted from req_quejob.  If we 
   * use the same job file, than all off this can be removed, since the 
   * job file name is copied over with the quick save info.
   */

  strncpy(basename, pnewjob->ji_qs.ji_jobid, PBS_JOBBASE);
  basename[PBS_JOBBASE] = '\0';

  do {
    strcpy(namebuf,path_jobs);
    strcat(namebuf,basename);
    strcat(namebuf,JOB_FILE_SUFFIX);

    fds = open(namebuf,O_CREAT|O_EXCL|O_WRONLY,0600);

    if (fds < 0) 
      {
      if (errno == EEXIST) 
        {
        pc = basename + strlen(basename) - 1;

        while (!isprint((int)*pc)) 
          {
          pc--;

          if (pc <= basename) 
            {
            /* FAILURE */

            log_err(errno,id,"job file is corrupt");
            job_free(pnewjob);
            return NULL;
            }
          }

        (*pc)++;
        } 
      else 
        {
        /* FAILURE */

        log_err(errno,id,"cannot create job file");
        job_free(pnewjob);
        return NULL;
        }
      }
    } while (fds < 0);
  close(fds);
  strcpy(pnewjob->ji_qs.ji_fileprefix,basename);

  /* end making new job file name now we need to copy the contents of the old 
     file into the file for this cloned job */
 /* strcpy(namebuf,path_jobs);
  strcat(namebuf,basename);
  strcat(namebuf,JOB_SCRIPT_SUFFIX);
  fds = open(namebuf,O_WRONLY);
  if (fds < 0)
    {
    log_err(errno,id,"cannot create job script");
    job_free(pnewjob);
    return NULL;
    }
    
  strcpy(namebuf,path_jobs);
  strcat(namebuf,poldjob->ji_qs.ji_fileprefix);
  strcat(namebuf,JOB_SCRIPT_SUFFIX);
  fds_source = open(namebuf,O_RDONLY);
  if (fds_source < 0)
    {
    log_err(errno,id,"cannot copy job script");
    job_free(pnewjob);
    return NULL;
    }
    
  rc = read(fds_source, copybuf, 4096);
  while (rc > 0)
    {
      write(fds, copybuf, rc);
      rc = read(fds_source, copybuf, 4096);
    }
  
  close(fds);
  close(fds_source);
*/
  /* copy job attributes. some of these are going to have to be modified 
     but many aren't set yet */
  for (i = 0; i < JOB_ATR_LAST; i++)
    {
    if(poldjob->ji_wattr[i].at_flags & ATR_VFLAG_SET)
      {
      job_attr_def[i].at_set(&(pnewjob->ji_wattr[i]),
                             &(poldjob->ji_wattr[i]),SET);
      }
    }


  /* set JOB_ATR_job_array_id */
  pnewjob->ji_wattr[(int)JOB_ATR_job_array_id].at_val.at_long = taskid;
  pnewjob->ji_wattr[(int)JOB_ATR_job_array_id].at_flags |= ATR_VFLAG_SET;
  
  /* set PBS_ARRAYID var */
  clear_attr(&tempattr,&job_attr_def[(int)JOB_ATR_variables]);
  sprintf(buf,",PBS_ARRAYID=%d",taskid);

  job_attr_def[(int)JOB_ATR_variables].at_decode(&tempattr,
      NULL, 
      NULL, 
      buf);

  job_attr_def[(int)JOB_ATR_variables].at_set(
    &pnewjob->ji_wattr[(int)JOB_ATR_variables],
    &tempattr, 
    INCR);  

  

  return pnewjob;
  } /* END job_clone() */

/*
 * job_clone_wt - worktask to clone jobs for job array
 */
void job_clone_wt(

struct work_task *ptask)
  {
  static char id[] = "job_clone_wt";
  job *pjob;
  job *pjobclone;
  struct work_task *new_task;
  int i;
  int startindex;
  int newstate;
  int newsub;
  int rc;
  
  
  pjob = (job*)(ptask->wt_parm1);
  startindex = ptask->wt_aux;
  
  /* do the clones in batches of 256 */
  
  
  for (i=startindex; 
       i<startindex+256 
       && i < pjob->ji_wattr[(int)JOB_ATR_job_array_size].at_val.at_long;
       i++)
    {
    pjobclone = job_clone(pjob, i);
    if (pjobclone == NULL)
      {
      log_err(-1, id, "unable to clone job in job_clone_wt");
      }

    svr_evaljobstate(pjobclone,&newstate,&newsub,1);
    svr_setjobstate(pjobclone,newstate,newsub);
    pjobclone->ji_wattr[(int)JOB_ATR_qrank].at_val.at_long = ++queue_rank;
    pjobclone->ji_wattr[(int)JOB_ATR_qrank].at_flags |= ATR_VFLAG_SET;
    
    if ((rc = svr_enquejob(pjobclone))) 
      {
      job_purge(pjobclone);
      }
      
    if (job_save(pjobclone,SAVEJOB_FULL) != 0) 
      {
      job_purge(pjobclone);
      }
    
    }
  
  if (i < pjob->ji_wattr[(int)JOB_ATR_job_array_size].at_val.at_long)
    {
    new_task = set_task(WORK_Timed,time_now,job_clone_wt,ptask->wt_parm1);
    new_task->wt_aux = startindex+256;
    }
  } /* end job_clone_tw */
  
  

#endif /* end ifndef PBS_MOM */

/*
 * job_init_wattr - initialize job working attribute array
 *	set the types and the "unspecified value" flag
 */
static void job_init_wattr(

  job *pj)

  {
  int i;

  for (i = 0;i < (int)JOB_ATR_LAST;i++) 
    {
    clear_attr(&pj->ji_wattr[i],&job_attr_def[i]);
    }

  return;
  }   /* END job_init_wattr() */ 





/*
 * job_purge - purge job from system
 *
 * The job is dequeued; the job control file, script file and any spooled
 * output files are unlinked, and the job structure is freed.
 * If we are MOM, the task files and checkpoint files are also
 * removed.
 */

void job_purge(

  job *pjob)

  {
  static char   id[] = "job_purge";

  char          namebuf[MAXPATHLEN + 1];
  extern char  *msg_err_purgejob;
#ifdef PBS_MOM
  int           rc;
  extern void MOMCheckRestart A_((void));
#ifdef PENABLE_LINUX26_CPUSETS 
  char                 cpuset_name[MAXPATHLEN + 1];
#endif
#endif

#ifdef PBS_MOM

  if (pjob->ji_flags & MOM_HAS_TMPDIR)
    {
    if (TTmpDirName(pjob,namebuf))
      {
      sprintf(log_buffer,"removing transient job directory %s",
        namebuf);
      
      log_record(PBSEVENT_DEBUG,
        PBS_EVENTCLASS_JOB,
        pjob->ji_qs.ji_jobid,
        log_buffer);
      
      if ((setegid(pjob->ji_qs.ji_un.ji_momt.ji_exgid) == -1) ||
          (seteuid(pjob->ji_qs.ji_un.ji_momt.ji_exuid) == -1))
        {
        /* FAILURE */
 
        return;
        }

      rc = remtree(namebuf);

      seteuid(0);
      setegid(pbsgroup);

      if ((rc != 0) && (LOGLEVEL >= 5))
        {
        sprintf(log_buffer,
          "recursive remove of job transient tmpdir %s failed",
          namebuf);
    
        log_err(errno, "recursive (r)rmdir",log_buffer);
        }
         
      pjob->ji_flags &= ~MOM_HAS_TMPDIR;
      }
    }

#ifdef PENABLE_LINUX26_CPUSETS 

    /* Delete the cpuset for the job. */
    sprintf (cpuset_name, "torque/%s", pjob->ji_qs.ji_jobid);
    cpuset_delete(cpuset_name);

#endif /* PENABLE_CPUSETS */

  /* delete the nodefile if still hanging around */

  if (pjob->ji_flags & MOM_HAS_NODEFILE)
    {
    char file[MAXPATHLEN + 1];

    sprintf(file,"%s/%s",
      path_aux,
      pjob->ji_qs.ji_jobid);

    unlink(file);

    pjob->ji_flags &= ~MOM_HAS_NODEFILE;
    }

  delete_link(&pjob->ji_jobque);
  delete_link(&pjob->ji_alljobs);

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer,"removing job");

    log_record(PBSEVENT_DEBUG,
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid,
      log_buffer);
    }
#else /* PBS_MOM */

  /* server only */

  if ((pjob->ji_qs.ji_substate != JOB_SUBSTATE_TRANSIN) &&
      (pjob->ji_qs.ji_substate != JOB_SUBSTATE_TRANSICM))
    {
    svr_dequejob(pjob);
    }

#endif  /* PBS_MOM */

  strcpy(namebuf,path_jobs);	/* delete script file */
  strcat(namebuf,pjob->ji_qs.ji_fileprefix);
  strcat(namebuf,JOB_SCRIPT_SUFFIX);

  if (unlink(namebuf) < 0)
    {
    if (errno != ENOENT)
      log_err(errno,id,msg_err_purgejob);
    }
  else if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer,"removed job script");

    log_record(PBSEVENT_DEBUG,
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid,
      log_buffer);
    }

#ifdef PBS_MOM
#if IBM_SP2==2        /* IBM SP PSSP 3.1 */
  unload_sp_switch(pjob);
#endif			/* IBM SP */
  strcpy(namebuf,path_jobs);      /* job directory path */
  strcat(namebuf,pjob->ji_qs.ji_fileprefix);
  strcat(namebuf,JOB_TASKDIR_SUFFIX);
  remtree(namebuf);

#if MOM_CHECKPOINT == 1
  {
  extern char *path_checkpoint;

  strcpy(namebuf,path_checkpoint);	/* delete any checkpoint file */
  strcat(namebuf,pjob->ji_qs.ji_fileprefix);
  strcat(namebuf,JOB_CKPT_SUFFIX);
  remtree(namebuf);
  }
#endif	/* MOM_CHECKPOINT */
#else	/* PBS_MOM */
  strcpy(namebuf,path_spool);	/* delete any spooled stdout */
  strcat(namebuf,pjob->ji_qs.ji_fileprefix);
  strcat(namebuf,JOB_STDOUT_SUFFIX);

  if (unlink(namebuf) < 0) 
    {
    if (errno != ENOENT)
      log_err(errno,id,msg_err_purgejob);
    }
  else if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer,"removed job stdout");

    log_record(PBSEVENT_DEBUG,
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid,
      log_buffer);
    }

  strcpy(namebuf,path_spool);	/* delete any spooled stderr */
  strcat(namebuf,pjob->ji_qs.ji_fileprefix);
  strcat(namebuf,JOB_STDERR_SUFFIX);

  if (unlink(namebuf) < 0) 
    {
    if (errno != ENOENT)
      log_err(errno,id,msg_err_purgejob);
    }
  else if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer,"removed job stderr");

    log_record(PBSEVENT_DEBUG,
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid,
      log_buffer);
    }
#endif	/* PBS_MOM */

  strcpy(namebuf,path_jobs);	/* delete job file */
  strcat(namebuf,pjob->ji_qs.ji_fileprefix);
  strcat(namebuf,JOB_FILE_SUFFIX);

  if (unlink(namebuf) < 0)
    {
    if (errno != ENOENT)
      log_err(errno,id,msg_err_purgejob);
    }
  else if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer,"removed job file");

    log_record(PBSEVENT_DEBUG,
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid,
      log_buffer);
    }

  job_free(pjob);

#ifdef PBS_MOM
  /* if no jobs are left, check if MOM should be restarted */

  if (((job *)GET_NEXT(svr_alljobs)) == NULL)
    MOMCheckRestart();
#endif	/* PBS_MOM */

  return;
  }  /* END job_purge() */





/*
 * find_job() - find job by jobid
 *
 *	Search list of all server jobs for one with same job id
 *	Return NULL if not found or pointer to job struct if found
 */

job *find_job(

  char *jobid)

  {
  char *at;
  job  *pj;

  if ((at = strchr(jobid,(int)'@')) != NULL)
    *at = '\0';	/* strip off @server_name */

  pj = (job *)GET_NEXT(svr_alljobs);

  while (pj != NULL) 
    {
    if (!strcmp(jobid,pj->ji_qs.ji_jobid))
      break;

    pj = (job *)GET_NEXT(pj->ji_alljobs);
    }

  if (at)
    *at = '@';	/* restore @server_name */

  return(pj);  /* may be NULL */
  }   /* END find_job() */ 

/* END job_func.c */

