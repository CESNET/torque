/*#include <pbs_config.h>*/   /* the master config generated by configure */
/*
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>


#include <sys/types.h>
#include <fcntl.h>
#include <netdb.h>

#include <stdlib.h>

#include "portability.h"
#include "list_link.h"
#include "attribute.h"
#include "server_limits.h"
#include "job.h"
#include "pbs_nodes.h"
#include "reservation.h"
#include "queue.h"
#include "log.h"
#include "pbs_ifl.h"*/
#include <sys/stat.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <ctype.h>
#include "portability.h"
#include "list_link.h"
#include "attribute.h"
#include "resource.h"
#include "site_pbs_cache.h"

/*
 * site_check_u - site_user_has_account()
 * default implementation can be {return 1;}
 */

#define ACCOUNTS "/var/local/perun-pbs/pbs_pre"

static config_line_s *accounts_lines[10240]; /* FIX ME - dynamicaly allocated? */
static time_t accounts_last_modification = 0;
static int accounts_last_line = -1;

int check_and_read_config(char *filename, config_line_s **lines,
    time_t *last_modification, int *last_line)
  {
  struct stat statbuf;
  int lineno;
  char buf[4096];
  FILE *f;
  char *c, *z;

  if (stat(filename, &statbuf))
    {
    perror(filename);
    *last_line = -1;
    *last_modification = 0;
    return -1;
    }
  if (statbuf.st_ctime != *last_modification)
    {
    f = fopen(filename, "r");
    if (f == NULL)
      {
      *last_line = -1;
      *last_modification = 0;
      /* fprintf(stderr,"file %s not found\n",ACCOUNTS); */
      return -1;
      }

    /* clean previous lines */
    lineno = 0;
    while (lines[lineno])
      {
      if (lines[lineno]->key)
        free(lines[lineno]->key);
      if (lines[lineno]->first)
        free(lines[lineno]->first);
      if (lines[lineno]->second)
        free(lines[lineno]->second);
      free(lines[lineno]);
      lines[lineno] = NULL;
      lineno++;
      }

    /* read new lines */
    lineno = 0;
    while (fgets(buf, 4096, f) != NULL)
      {
      /* expected format of line
       * key: host1 host2 & cluster1 cluster2
       */
      for (z = buf; isspace(*z); z++)
        ;
      if (*z == '#')
        continue;
      c = strchr(z, ':');
      if (c == NULL)
        continue;
      *c = '\0';
      for (c++; isspace(*c); c++)
        ;
      lines[lineno] = (config_line_s *) malloc(sizeof(config_line_s));
      lines[lineno]->key = strdup(z);
      z = strchr(c, '&');
      if (z)
        {
        *z = '\0';
        for (z++; isspace(*z); z++)
          ;
        lines[lineno]->second = strdup(z);
        z = strchr(lines[lineno]->second, '\n');
        if (z != NULL)
          *z = '\0';
        }
      else
        lines[lineno]->second = NULL;
      lines[lineno]->first = strdup(c);
      c = strchr(lines[lineno]->first, '\n');
      if (c != NULL)
        *c = '\0';
      /* fprintf(stderr,"line %d: user %s\n  hosts %s\n  clusters %s\n",
       * lineno,lines[lineno]->user,lines[lineno]->hosts,
       * lines[lineno]->clusters);
       */
      lineno++;
      }

    lines[lineno] = NULL;
    fclose(f);
    *last_modification = statbuf.st_ctime;
    *last_line = -1;
    }
  return 0;
  }

static int check_user(char *user, char *host, char *cluster, int lineno)
  {
  if ((accounts_lines[lineno]) && (accounts_lines[lineno]->key) && strcmp(user,
      accounts_lines[lineno]->key) == 0)
    {
    accounts_last_line = lineno;

    if (accounts_lines[lineno]->first && (strstr(accounts_lines[lineno]->first,
        host)))
      {
      return CHECK_OK;
      }
    else if (cluster && accounts_lines[lineno]->second && (strstr(
        accounts_lines[lineno]->second, cluster)))
      {
      return CHECK_OK;
      }
    else
      {
      return CHECK_NO;
      }
    }
  return CHECK_USER;
  }

int site_user_has_account(char *user, char *host, char *cluster)
  {
  int ret;
  int lineno;

  ret = check_and_read_config(ACCOUNTS, accounts_lines,
      &accounts_last_modification, &accounts_last_line);
  if (ret == -1)
    return CHECK_OK; /* for testing mode, when file not present */
  /* file not found, unreadable, ... switch test off*/

  if (accounts_last_line != -1)
    {
    /* there is good chance that the same user is checked */
    ret = check_user(user, host, cluster, accounts_last_line);
    if (ret != CHECK_USER)
      return ret;
    }

  /* check all lines */
  lineno = 0;
  while (accounts_lines[lineno] != NULL)
    {
    ret = check_user(user, host, cluster, lineno);
    if (ret != CHECK_USER)
      return ret;
    lineno++;
    }

  ret = CHECK_NO; /* user not found on any line */
  return ret;
  }

