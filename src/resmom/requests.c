/*
*         OpenPBS (Portable Batch System) v2.3 Software License
* 
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
* 
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
* 
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
* 
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
* 
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
* 
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
* 
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
* 
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
* 
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
* 
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
* 
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information 
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
* 
* 7. DISCLAIMER OF WARRANTY
* 
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
* 
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/
#include <pbs_config.h>   /* the master config generated by configure */

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <grp.h>
#include <limits.h>
#include <pwd.h>
#include <signal.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <assert.h>
#include <dirent.h>
#include <sys/stat.h>
#include <sys/wait.h>
#include "dis.h"
#include "libpbs.h"
#include "pbs_error.h"
#include "server_limits.h"
#include "list_link.h"
#include "credential.h"
#include "attribute.h"
#include "resource.h"
#include "job.h"
#include "batch_request.h"
#include "mom_mach.h"
#include "mom_func.h"
#include "log.h"
#ifdef _CRAY
#include <sys/category.h>
#endif

/* External Global Data Items */

extern unsigned int	default_server_port;
extern int		exiting_tasks;
extern list_head	svr_alljobs;
extern char		mom_host[];
extern char		*msg_err_unlink;
extern char		*path_checkpoint;
extern char		*path_spool;
extern char		*path_undeliv;
extern attribute_def	job_attr_def[];
extern char		*msg_jobmod;
extern char		*msg_manager;
extern time_t		time_now;
extern int		resc_access_perm;	/* see encode_resc() */
						/* in attr_fn_resc.c */

extern char             MOMUNameMissing[];

/* Local Data Items */

static uid_t  useruid;
static gid_t  usergid;
static int    ngroup;
static int   *groups;
static char  *output_retained = "Output retained on that host in: ";
static char   rcperr[MAXPATHLEN];	/* file to contain rcp error */

extern char PBSNodeMsgBuf[1024];
extern int  LOGLEVEL;



/* prototypes */

char *__get_variable(job *,char *);

/* loaded in mom_mach.h */

/* END prototypes */


char *__get_variable(

  job  *pjob,     /* I */
  char *variable) /* I */

  {
  char *pc;

  if (pjob == NULL)
    {
    return(NULL);
    }

  pc = arst_string(
         variable,
         &pjob->ji_wattr[(int)JOB_ATR_variables]);

  if (pc != NULL)
    {
    if ((pc = strchr(pc,(int)'=')) != NULL)
      pc++;
    }

  return(pc);
  }  /* END __get_variable() */





/*
 * fork_to_user - fork mom and go to user's home directory
 *		  also sets up the global useruid and usergid in the child
 *
 *	WARNING: valid only if called when preq points to a cpyfiles structure
 */

static pid_t fork_to_user(

  struct batch_request *preq,   /* I */
  int                   SetUID, /* I (boolean) */
  char                 *HDir,   /* O (job/user home directory) */
  char                 *EMsg)   /* I (optional,minsize=1024) */

  {
  char           *id = "fork_to_user";

  struct group   *grpp;
  pid_t           pid;
  job            *pjob;
  struct passwd  *pwdp;
  static int      fgrp[NGROUPS_MAX];

  char           *idir;

  char           *hdir;

  char            tmpLine[1024];

  struct stat     sb;

  /* initialize */

  if (EMsg != NULL)
    EMsg[0] = '\0';

  if ((pjob = find_job(preq->rq_ind.rq_cpyfile.rq_jobid)) &&
      (pjob->ji_grpcache != 0))
    {
    /* use information cached in the job structure */

    useruid = pjob->ji_qs.ji_un.ji_momt.ji_exuid;
    usergid = pjob->ji_qs.ji_un.ji_momt.ji_exgid;
    ngroup  = pjob->ji_grpcache->gc_ngroup;
    groups  = pjob->ji_grpcache->gc_groups;

    if ((idir = __get_variable(pjob,"PBS_O_INITDIR")) != NULL)
      {
      hdir = idir;
      }
    else
      {
      hdir = pjob->ji_grpcache->gc_homedir;
      }
    }
  else
    {
    if ((pwdp = getpwnam(preq->rq_ind.rq_cpyfile.rq_user)) == NULL)
      {
      if (MOMUNameMissing[0] == '\0')
        strncpy(MOMUNameMissing,preq->rq_ind.rq_cpyfile.rq_user,64);

      sprintf(tmpLine,"cannot find user '%s' in password file",
        preq->rq_ind.rq_cpyfile.rq_user);

      if (EMsg != NULL)
        strncpy(EMsg,tmpLine,1024);

      log_err(errno,id,tmpLine);

      return(-PBSE_BADUSER);
      }

    useruid = pwdp->pw_uid;

    if (preq->rq_ind.rq_cpyfile.rq_group[0] == '\0')
      {
      usergid = pwdp->pw_gid;   /* default to login group */
      }
    else if ((grpp = getgrnam(preq->rq_ind.rq_cpyfile.rq_group)) != NULL)
      {
      usergid = grpp->gr_gid;
      }
    else
      {
      sprintf(tmpLine,"cannot find group for user '%s' in password file",
        preq->rq_ind.rq_cpyfile.rq_user);

      if (EMsg != NULL)
        strncpy(EMsg,tmpLine,1024);

      log_err(errno,id,tmpLine);

      return(-PBSE_BADUSER);
      }

    ngroup = init_groups(pwdp->pw_name,usergid,NGROUPS_MAX,fgrp);

    if (ngroup < 0)
      ngroup = 0;

    groups = fgrp;

    /* determine user`s home directory */

    if ((pjob != NULL) && ((idir = __get_variable(pjob,"PBS_O_INITDIR")) != NULL))
      {
      hdir = idir;
      }
    else
      {
      hdir = pwdp->pw_dir;
      }
    }    /* END if ((pjob = find_job(preq->rq_ind.rq_cpyfile.rq_jobid)) && ...) */

  if (hdir == NULL)
    {
    /* FAILURE */

    log_err(PBSE_UNKRESC,id,"cannot determine home directory");

    if (EMsg != NULL)
      strncpy(EMsg,"cannot determine home directory",1024);

    return(-PBSE_UNKRESC);
    }

  /* check user home directory as root and log failures */

  /* NOTE: root may not be able to see user home directory due to root_squash 
           permissions but routine will test and log what is detected. Some 
           issues will be logged by the parent but TORQUE will only fail if the
           problems persist in the child after the setuid() call */

  if (stat(hdir,&sb) != 0)
    {
    sprintf(tmpLine,"invalid home directory '%s' specified, errno=%d (%s)",
      hdir,
      errno,
      strerror(errno));

    if (LOGLEVEL >= 2)
      { 
      log_err(errno,id,tmpLine);
      }

    if (EMsg != NULL)
      strncpy(EMsg,tmpLine,1024);

    /* NOTE:  warn only, root may not be able to stat directory */

    /* return(-PBSE_UNKRESC); */
    }
  else if (!S_ISDIR(sb.st_mode))
    {
    sprintf(tmpLine,"invalid home directory '%s' specified, not a directory",
      hdir);

    log_err(PBSE_UNKRESC,id,tmpLine);
      
    if (EMsg != NULL)
      strncpy(EMsg,tmpLine,1024);

    return(-PBSE_UNKRESC); 
    }

  if (LOGLEVEL >= 1)
    { 
    sprintf(tmpLine,"forking to user, uid: %ld  gid: %ld  homedir: '%s'",
      (long)useruid,
      (long)usergid,
      hdir);
 
    log_record(
      PBSEVENT_ADMIN,
      PBS_EVENTCLASS_FILE,
      (pjob != NULL) ? pjob->ji_qs.ji_jobid : "N/A",
      tmpLine);
    }

  if (HDir != NULL)
    strcpy(HDir,hdir);

  pid = fork_me(preq->rq_conn);

  if (pid < 0)
    {
    /* fork failed */

    sprintf(tmpLine,"forked failed, errno=%d (%s)",
      errno,
      strerror(errno));

    log_err(-1,id,tmpLine);

    if (EMsg != NULL)
      strncpy(EMsg,tmpLine,1024);

    return(-PBSE_SYSTEM);
    }

  if (pid > 0)  
    {
    /* parent - note leave connection open */

    free_br(preq);

    return(pid);
    } 

  /* the child */

  /* NOTE:  writing to log as child may cause corruption */

#ifdef _CRAY

  if ((pjob = find_job(preq->rq_ind.rq_cpyfile.rq_jobid)) &&
      (pjob->ji_grpcache != 0)) 
    {
    /* set account id */

    if (pjob->ji_wattr[(int)JOB_ATR_account].at_flags & ATR_VFLAG_SET) 
      {
      acctid(0,nam2acid(pjob->ji_wattr[(int)JOB_ATR_account].at_val.at_str));
      }
    } 

#endif /* _CRAY */

  /* NOTE:  only chdir now if SetUID is TRUE */

  if (SetUID == TRUE)
    {
    setgroups(ngroup,(gid_t *)groups);

    setgid(usergid);
    setuid(useruid);   /* run as the user */

    if (chdir(hdir) == -1)
      {
      /* cannot change directory to user home dir (or 'INITDIR' if specified) */

      return(-PBSE_UNKRESC);
      }
    }

  return(pid);
  }  /* END fork_to_user() */





/*
 * add_bad_list -  add bad file message to bad file list
 */

static void add_bad_list(

  char **pbl,
  char  *newtext,
  int    nl)

  {
  int   needed = 0;
  char *pnew;

  if (*pbl != NULL) 
    {
    needed += strlen(*pbl) + strlen(newtext) + nl + 1;

    pnew = realloc(*pbl,needed);
    } 
  else 
    {
    needed += strlen(newtext) + nl + 1;

    pnew = malloc(needed);

    if (pnew != NULL)
      *pnew = '\0';
    }

  if (pnew == NULL)
    {
    /* cannot allocate memory - FAILURE */

    return;
    }

  *pbl = pnew;

  while (nl--)				/* prefix new-lines */
    strcat(*pbl,"\n");

  strcat(*pbl,newtext);

  return;
  }  /* END add_bad_list() */





#define RT_BLK_SZ 4096 

static int return_file(

  job	        *pjob,
  enum job_file  which,
  int	         sock)

  {
  int		      amt;
  char		      buf[RT_BLK_SZ];
  int		      fds;
  char		     *filename;
  struct batch_request *prq;
  int		      rc = 0;
  int		      seq = 0;

  filename = std_file_name(pjob,which,&amt); /* amt is place holder */

  fds = open(filename,O_RDONLY,0);

  if (fds < 0)
    {
    return(0);
    }

  prq = alloc_br(PBS_BATCH_MvJobFile);

  if (prq == NULL)
    {
    /* no memory */

    return(PBSE_SYSTEM);
    }

  strcpy(prq->rq_host,mom_host);
  strcpy(prq->rq_ind.rq_jobfile.rq_jobid,pjob->ji_qs.ji_jobid);

  while ((amt = read(fds,buf,RT_BLK_SZ)) > 0) 
    {
    /* prq->rq_ind.rq_jobfile.rq_sequence = seq++; */
    /* prq->rq_ind.rq_jobfile.rq_type = (int)which; */
    /* prq->rq_ind.rq_jobfile.rq_size = amt; */
    /* prq->rq_ind.rq_jobfile.rq_data = buf; */

    DIS_tcp_setup(sock);

    if ((rc = encode_DIS_ReqHdr(sock,PBS_BATCH_MvJobFile,pbs_current_user)) ||
        (rc = encode_DIS_JobFile(sock,seq++,buf,amt,pjob->ji_qs.ji_jobid,which)) ||
        (rc = encode_DIS_ReqExtend(sock,NULL))) 
      {
      break;
      }
		
    DIS_tcp_wflush(sock);

    if ((DIS_reply_read(sock,&prq->rq_reply) != 0) ||
        (prq->rq_reply.brp_code != 0)) 
      {
      close(fds);

      rc = -1;

      break;
      }
    }

  free_br(prq);

  close(fds);

  if (rc == 0) 
    unlink(filename);

  return(rc);
  }  /* END return_file() */





/*
 * wchost_match - wild card host name match
 *
 *	return	1 if can"idate" matches master name
 *		0 if not a match
 *	master name may be wild carded at beginning
 */

static int wchost_match(

  const char *can,    /* I candidate */
  const char *master) /* I */

  {
  const char *pc;
  const char *pm;

  /* FORMAT:   master = [*]<SUFFIX>, candidate = <STRING><SUFFIX> */

  /* start at end and work backwards */

  pc = can + strlen(can) - 1;

  pm = master + strlen(master) - 1;

  while ((pc > can) && (pm > master)) 
    {
    if (*pc != *pm)
      {
      /* no match */

      return(0);
      }

    pc--;
    pm--;
    }

  /* comparison of one or both reached the start of the string */

  if (pm == master) 
    {
    if (*pm == '*')
      {
      /* reached master wild card, all candidates match */

      return(1);
      }

    if ((pc == can) && (*pc == *pm))
      {
      /* start of candidate reached, always match */

      /* NOTE: this seems wrong (CRI)  ie, can=dog.com master=*.bigdog.com */

      return(1);
      }
    }

  /* no match */

  return(0);
  }  /* END wchost_match() */





static int told_to_cp(

  char  *host,    /* I */
  char  *oldpath, /* I */
  char **newpath) /* O */

  {
  int    i;
  int    nh;

  static char newp[MAXPATHLEN + 1];
  extern struct cphosts *pcphosts;

  for (nh = 0;nh < cphosts_num;nh++) 
    {
    if (wchost_match(host,(pcphosts + nh)->cph_hosts)) 
      {
      i = strlen((pcphosts + nh)->cph_from);

      if (strncmp((pcphosts + nh)->cph_from,oldpath,i) == 0) 
        {
        strcpy(newp,(pcphosts + nh)->cph_to);

        strcat(newp,oldpath + i);
       
        *newpath = newp;

        /* success */

        return(1);
        }
      }
    }

   /* failure */

  return(0);
  }  /* END told_to_cp() */





/*
 * local_or_remote() - is the specified path to a local or remote file
 *	checks to see if there is a hostname which matches this host
 *
 *	returns: 1 if remote and 0 if local
 *	also updates the path pointer to just the path name if local
 */

static int local_or_remote(

  char **path)  /* I */

  {
  int   len;
  char *pcolon;

  pcolon = strchr(*path,(int)':');

  if (pcolon == NULL)
    {
    /* local file */

    return(0);
    }

  *pcolon = '\0';

  len = strlen(*path);

  if ((strcmp("localhost",*path) == 0) ||
     ((strncmp(mom_host,*path,len) == 0) && 
     ((mom_host[len] == '\0') || (mom_host[len] == '.')))) 
    {
    /* we have a host match, file is local */

    *pcolon = ':';

    *path = pcolon + 1;

    /* local file */

    return(0);
    } 
  else if (told_to_cp(*path,pcolon + 1,path)) 
    {
    /* path updated in told_to_cp() */

    /* local file */

    return(0);
    } 

  /* remote file */

  *pcolon = ':';

  return(1);
  }  /* END local_or_remote() */






/*
 * is_file_same() - are two paths pointing to the same file
 *	returns: 1 if are the same
 *		 0 if not the same (or cannot tell)
 */

static int is_file_same(file1, file2)
	char *file1;
	char *file2;
{
	struct stat sb1, sb2;

	if ((stat(file1, &sb1) == 0) && (stat(file2, &sb2) == 0)) {

		if ( !memcmp(&sb1.st_dev, &sb2.st_dev, sizeof(dev_t)) && 
		     !memcmp(&sb1.st_ino, &sb2.st_ino, sizeof(ino_t)) )
			return 1;

	}
	return 0;
}





void req_deletejob(

  struct batch_request *preq)

  {
  job *pjob;

  pjob = find_job(preq->rq_ind.rq_delete.rq_objname);

  if (pjob != NULL) 
    {
    /* assume success? */

    mom_deljob(pjob);

    reply_ack(preq);
    } 
  else 
    {
    req_reject(PBSE_UNKJOBID,0,preq,mom_host,"cannot locate job to delete");
    }

  return;
  }





/*
 * req_holdjob - checkpoint and terminate job
 */

void req_holdjob(

  struct batch_request *preq)

  {
#if MOM_CHECKPOINT == 1

  int  rc;
  job *pjob;

  /* If checkpoint supported, do it and terminate the job */
  /* otherwise, return PBSE_NOSUP				*/

  pjob = find_job(preq->rq_ind.rq_hold.rq_orig.rq_objname);

  if (pjob == NULL) 
    {
    rc = PBSE_UNKJOBID;
    } 
  else 
    {
    if ((rc = start_checkpoint(pjob,1,preq)) != 0)
      req_reject(rc,0,preq,mom_host,"cannot checkpoint job");    /* unable to start chkpt */
    }

  /* note, normally the reply to the server is in start_checkpoint() */

#else	/* MOM_CHECKPOINT */

  req_reject(PBSE_NOSUP,0,preq,mom_host,"checkpointing not supported");

#endif	/* MOM_CHECKPOINT */

  return;
  }




/*
 *	Write text into a job's output file,
 *	Return a PBS error code.
 */

int message_job(

  job            *pjob,
  enum	job_file  jft,  /* I */
  char           *text)

  {
  char		*pstr = NULL;
  int		len;
  int		fds;

  if (pjob == NULL)
    {
    return(PBSE_UNKJOBID);
    }

  /* must be Mother Superior for this to make sense */

  if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) == 0)
    {
    log_err(errno,"message_job","cannot message job, not mother superior");

    return(PBSE_MOMREJECT);
    }

  len = is_joined(pjob);

  if (len == -1)
    jft = StdErr;	/* only have stderr open */
  else if (len == 1)
    jft = StdOut;	/* only have stdout open */

  if ((fds = open_std_file(
        pjob,
        jft,
        O_WRONLY|O_APPEND, 
        pjob->ji_qs.ji_un.ji_momt.ji_exgid)) < 0)
    {
    sprintf(log_buffer,"cannot open %s file for job '%s' (msg: '%.64s')",
      (jft == StdErr) ? "stderr" : "stdout",
      pjob->ji_qs.ji_jobid,
      text);

    log_err(errno,"message_job",log_buffer);

    return(PBSE_MOMREJECT);
    }

  len = strlen(text);

  if (text[len - 1] != '\n') 
    {
    if ((pstr = malloc(len + 2)) == NULL)
      {
      return(PBSE_INTERNAL);
      }

    strcpy(pstr,text);

    pstr[len++] = '\n';	/* append new-line */

    text = pstr;
    }

  write(fds,text,len);

  close(fds);

  if (pstr != NULL)
    free(pstr);

  /* SUCCESS */

  return(PBSE_NONE);
  }  /* END message_job() */





/*
 * req_messagejob - Append message to job's output/error file
 */

void req_messagejob(

  struct batch_request *preq)

  {
  int   ret = 0;
  job  *pjob;

  pjob = find_job(preq->rq_ind.rq_message.rq_jid);

  if ((preq->rq_ind.rq_message.rq_file == PBS_BATCH_FileOpt_Default) ||
      (preq->rq_ind.rq_message.rq_file & PBS_BATCH_FileOpt_OFlg)) 
    {
    ret = message_job(pjob,StdOut,preq->rq_ind.rq_message.rq_text);
    }

  if ((preq->rq_ind.rq_message.rq_file & PBS_BATCH_FileOpt_EFlg) &&
      (ret == 0)) 
    {
    ret = message_job(pjob,StdErr,preq->rq_ind.rq_message.rq_text);
    }

  if (ret == PBSE_NONE)
    {
    /* message request successful */

    reply_ack(preq);
    }
  else
    {
    req_reject(ret,0,preq,mom_host,"cannot add message to job output/error buffer");
    }

  return;
  }  /* END req_messagejob() */





/*
 * req_modifyjob - service the Modify Job Request
 *
 *	This request modifies a job's attributes.
 */

void req_modifyjob(

  struct batch_request *preq)

  {
  int		 bad = 0;
  int		 i;
  attribute	 newattr[(int)JOB_ATR_LAST];
  attribute	*pattr;
  job		*pjob;
  svrattrl	*plist;
  int		 rc;

  char tmpLine[1024];

  pjob = find_job(preq->rq_ind.rq_modify.rq_objname);

  if (pjob == NULL) 
    {
    sprintf(tmpLine,"modify job failed, unknown job %s",
      preq->rq_ind.rq_modify.rq_objname);

    req_reject(PBSE_UNKJOBID,0,preq,mom_host,tmpLine);

    return;
    }

  plist = (svrattrl *)GET_NEXT(preq->rq_ind.rq_modify.rq_attr);

  if (plist == NULL) 
    {
    /* nothing to do */

    reply_ack(preq);

    /* SUCCESS */

    return;
    }

  /* modify the jobs attributes */

  bad = 0;

  pattr = pjob->ji_wattr;

  /* call attr_atomic_set to decode and set a copy of the attributes */

  rc = attr_atomic_set(
      plist, 
      pattr, 
      newattr, 
      job_attr_def, 
      JOB_ATR_LAST,
      -1, 
      ATR_DFLAG_MGWR | ATR_DFLAG_MOM, 
      &bad);

  if (rc != 0) 
    {
    /* leave old values, free the new ones */
 
    for (i = 0;i < JOB_ATR_LAST;i++)
      {
      job_attr_def[i].at_free(newattr + i);
      }

    /* cannot set attributes, return FAILURE */

    req_reject(rc,0,preq,mom_host,"cannot set attributes");

    return;
    }

  /* OK, now copy the new values into the job attribute array */

  for (i = 0;i < JOB_ATR_LAST;i++) 
    {
    if (newattr[i].at_flags & ATR_VFLAG_MODIFY) 
      {
      if (job_attr_def[i].at_action)  
        job_attr_def[i].at_action(&newattr[i],pjob,ATR_ACTION_ALTER);

      job_attr_def[i].at_free(pattr+i);

      if ((newattr[i].at_type == ATR_TYPE_LIST) ||
          (newattr[i].at_type == ATR_TYPE_RESC)) 
        {
        list_move(&newattr[i].at_val.at_list,&(pattr+i)->at_val.at_list);
        } 
      else 
        {
        *(pattr + i) = newattr[i];
        }

      (pattr + i)->at_flags = newattr[i].at_flags;
      }
    }

  /* note, the newattr[] attributes are on the stack, they goaway auto */

  if (rc == 0)
    {
    rc = mom_set_limits(pjob,SET_LIMIT_ALTER);
    }

  if (rc != 0) 
    {
    req_reject(rc,bad,preq,mom_host,"cannot set limits");

    return;
    }

  job_save(pjob,SAVEJOB_FULL);

  sprintf(log_buffer,msg_manager,
    msg_jobmod,
    preq->rq_user, 
    preq->rq_host);

  LOG_EVENT(
    PBSEVENT_JOB,  
    PBS_EVENTCLASS_JOB, 
    pjob->ji_qs.ji_jobid,
    log_buffer);

  /* SUCCESS */

  reply_ack(preq);

  return;
  }  /* END req_modifyjob() */




void req_shutdown(

  struct batch_request *preq)

  {
  req_reject(PBSE_NOSUP, 0, preq,NULL,NULL);

  return;
  }




#ifdef _CRAY

/*
 * cray_susp_resum - special cray suspend/resume function
 */

static void cray_susp_resum(

  job                  *pjob,
  int                   which,
  struct batch_request *preq)

  {
  int 	 i;
  int	 ct;
  task	*ptask;
  pid_t  pid;
  long	 sess;
  int	 sock;

  sock = preq->rq_conn;

  pid = fork_me(sock);

  if (pid > 0) 
    {
    /* record pid in job for when child terminates */

    pjob->ji_momsubt = pid;

    if (which == 1) 
      {
      pjob->ji_mompost = post_suspend;

      /* save stop time for adjusting walltime */

      pjob->ji_momstat = time_now;
      } 
    else 
      {
      pjob->ji_mompost = post_resume;
      }

    free_br(preq);

    return;
    } 
  else if (pid == -1) 
    {
    /* fork failed - still the main mom */

    log_err(-1,id,"cannot fork child for cray suspend");

    req_reject(PBSE_SYSTEM,errno,preq,NULL,NULL);

    return;
    }

  /* child of MOM, cannot update job struct */

  for (ptask = (task *)GET_NEXT(pjob->ji_tasks);
       ptask != NULL;
       ptask = (task *)GET_NEXT(ptask->ti_jobtask)) 
    {
    sess = ptask->ti_qs.ti_sid;

    for (ct = 0;ct < 3;ct++)  
      {
      i = (which == 1) ?  suspend(C_JOB,sess) : resume(C_JOB,sess);

      if (i == 0)
        break;

      if ((errno != EAGAIN) && (errno != EINTR))
        break;
      }

    if (i == -1) 
      {
      /* error */

      req_reject(PBSE_SYSTEM,errno,preq,NULL,NULL);

      exit(1);
      }
    }

  reply_ack(preq);

  exit(0);
  }

#endif	/* _CRAY */



int MUSleep(

  long SleepDuration) /* I (in us) */

  {
  struct timeval timeout;

  timeout.tv_sec  = SleepDuration / 1000000;
  timeout.tv_usec = SleepDuration % 1000000;

  select(0,(fd_set *)NULL,(fd_set *)NULL,(fd_set *)NULL,&timeout);

  return(0);
  }  /* END MUSleep() */



static void resume_suspend( 

  job                  *pjob,
  int                   susp,  /* I */
  struct batch_request *preq)

  {
  task *tp;

  int   stat = 0;
  int   savederr = 0;

  /* First we need to send SIGTSTP to let reasonable mpi daemons stop
     their subprocesses, then we send SIGSTOP to stop all other types
     of processes.  This is split into two loops instead of doing them
     right after each other because one needs a delay between the
     SIGTSTP and SIGSTOP to give the mpi daemon time to stop all its
     tasks.  Inserting a delay for each task would produce a very long
     delay for jobs with large number of tasks.

     So, to summarize, we send all tasks SIGTSTP, then we wait for 1
     second, then we send all tasks SIGSTOP.  Hopefully this should
     cover all cases.  The delay should rather be configurable but I
     don't have a clue how, nor time, to do that.
 
     Fortunately only one SIGCONT is needed to resume.
   */

  for (tp = (task *)GET_NEXT(pjob->ji_tasks);tp != NULL;tp = (task *)GET_NEXT(tp->ti_jobtask)) 
    {
    if (susp != 0)
      {
      /* NOTE:  for suspend, changed signals to SIGTSTP for MPI jobs - NORWAY */

      /* stat = kill_task(tp,SIGSTOP); */

      stat = kill_task(tp,SIGTSTP);
      }
    else
      {
      stat = kill_task(tp,SIGCONT);
      }

    if (stat < 0) 
      {
      /* couldn't send signal, don't signal more tasks */

      savederr = errno;

      break;
      }
    }    /* END for (tp) */

  if ((susp != 0) && (stat >= 0))
    {
    MUSleep(50000);
 
    for (tp = (task *)GET_NEXT(pjob->ji_tasks);tp != NULL;tp = (task *)GET_NEXT(tp->ti_jobtask)) 
      {
      stat = kill_task(tp,SIGSTOP);

      if (stat < 0) 
        {
        /* couldn't send signal, don't signal more tasks */

        savederr = errno;

        break;
        }
      }    /* END for (tp) */
    }      /* END if  ((susp != 0) && (stat >= 0)) */

  /* We're done sending signals, let's adjust some statuses */

  if (stat < 0) 
    {
    /* We couldn't signal all the tasks, signal them back to their old state */
    
    for (tp = (task *)GET_NEXT(pjob->ji_tasks);tp != NULL;tp = (task *)GET_NEXT(tp->ti_jobtask)) 
      {
      if (susp)
        {
	stat = kill_task(tp,SIGCONT);
        }
      else
        {
        /* NOTE:  for suspend, changed signals to SIGTSTP for MPI jobs - NORWAY */

	/* stat = kill_task(tp,SIGSTOP); */

        stat = kill_task(tp,SIGTSTP);
        }
      }  /* END for (tp) */

    /* the same two signal exercise as above */

    if (susp != 0)
      {
      MUSleep(50000);

      for (tp = (task *)GET_NEXT(pjob->ji_tasks);tp != NULL;tp = (task *)GET_NEXT(tp->ti_jobtask)) 
        {
        stat = kill_task(tp,SIGSTOP);
        }  /* END for (tp) */
      }

    /* suspend/resume failued - report failure */

    req_reject(PBSE_SYSTEM,savederr,preq,NULL,NULL);      
    }  /* END if (stat < 0) */ 
  else 
    {
    if (susp != 0) 
      {
      /* Successfully suspended, let's update status */
      /* This is needed for calculating correct walltime */

      pjob->ji_momstat = time_now;
      
      pjob->ji_qs.ji_substate = JOB_SUBSTATE_SUSPEND;
      pjob->ji_qs.ji_svrflags |= JOB_SVFLG_Suspend;
      } 
    else 
      {
      pjob->ji_qs.ji_substate = JOB_SUBSTATE_RUNNING;

      /* Ok, we resumed'em, we have set ji_momstat to the time we suspended the
	 job.  We use this to compute a new start-time for the job, so that
	 walltime is computed correctly elsewhere */
      
      if (pjob->ji_qs.ji_svrflags & JOB_SVFLG_Suspend) 
        {
	/* If it's suspended, update the start time */

	pjob->ji_qs.ji_stime =  pjob->ji_qs.ji_stime - pjob->ji_momstat + time_now;
        }

      /* Clear the Suspend bit */

      pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_Suspend;
      }

    /* Tell them we did it */

    reply_ack(preq);
    }  /* else (stat < 0) */
 
  return;
  }  /* END resume_suspend() */





/*
 * req_signaljob - issue (kill) a specified signal to a job
 *	Signal may be either a numeric string or a signal name
 *	with or without the "SIG" prefix.
 */

void req_signaljob(

  struct batch_request *preq)

  {
  job            *pjob;
  int             sig;
  char           *sname;
  struct sig_tbl *psigt;
  extern struct sig_tbl sig_tbl[];

  pjob = find_job(preq->rq_ind.rq_signal.rq_jid);

  if (pjob == NULL) 
    {
    req_reject(PBSE_UNKJOBID,0,preq,NULL,NULL);

    return;
    }

  sname = preq->rq_ind.rq_signal.rq_signame;

  DBPRT(("req_signaljob: Sending %s\n", 
    sname))

  if (strcmp(sname,SIG_SUSPEND) == 0) 
    {
    if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING) 
      {
      req_reject(PBSE_BADSTATE,0,preq,NULL,NULL);
      } 
    else 
      {
#ifdef _CRAY	/* suspend/resume on Cray only */
      cray_susp_resum(pjob,1,preq);
#else
      resume_suspend(pjob,1,preq);
#endif	/* _CRAY */
      }

    return;
    } 
  else if (strcmp(sname,SIG_RESUME) == 0) 
    {
    if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_SUSPEND) 
      {
      LOG_EVENT(
        PBSEVENT_JOB, 
        PBS_EVENTCLASS_JOB,
        pjob->ji_qs.ji_jobid,
        "resume request on job that is not suspended");
      }

#ifdef _CRAY
    cray_susp_resum(pjob,0,preq);
#else
    resume_suspend(pjob,0,preq);
#endif	/* _CRAY */

    return;
    }

  if (isdigit((int)*sname))
    {
    sig = atoi(sname);
    }
  else 
    {
    if (!strncmp("SIG",sname,3))
      sname += 3;

    psigt = sig_tbl;

    while (psigt->sig_name) 
      {
      if (!strcmp(sname,psigt->sig_name)) 
        break;

      psigt++;
      }

    sig = psigt->sig_val;
    }

  if (sig < 0) 
    {
    req_reject(PBSE_UNKSIG,0,preq,NULL,NULL);

    return;
    }
			
  if ((kill_job(pjob,sig) == 0) && (sig == 0)) 
    {
    /* SIGNUL and no procs found, force job to exiting */
    /* force issue of (another) job obit */

    sprintf(log_buffer,"Job recycled into exiting on SIGNULL from substate %d",
      pjob->ji_qs.ji_substate);

    LOG_EVENT(
      PBSEVENT_ERROR, 
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid, 
      log_buffer);

    pjob->ji_qs.ji_substate = JOB_SUBSTATE_EXITING;

    exiting_tasks = 1;
    }

  if ((sig == SIGKILL) && (pjob->ji_qs.ji_substate == JOB_SUBSTATE_EXITING)) 
    {
    /* force issue of (another) job obit */

    sprintf(log_buffer,"Job recycled into exiting on SIGKILL from substate %d",
      pjob->ji_qs.ji_substate);

    LOG_EVENT(
      PBSEVENT_ERROR, 
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid, 
      log_buffer);

    pjob->ji_qs.ji_substate = JOB_SUBSTATE_EXITING;

    exiting_tasks = 1;
    }

  reply_ack(preq);

  return;
  }  /* END req_signaljob() */




static enum job_atr mom_rtn_list[] = {
	JOB_ATR_errpath,
	JOB_ATR_outpath,
	JOB_ATR_session_id,
	JOB_ATR_altid,
	(enum job_atr) -1
};


void encode_used(

  job       *pjob,
  list_head *phead)

  {
  unsigned long		lnum;
  int			i;
  attribute		*at;
  attribute_def		*ad;
  resource		*rs;

  at = &pjob->ji_wattr[JOB_ATR_resc_used];
  ad = &job_attr_def[JOB_ATR_resc_used];

  if ((at->at_flags & ATR_VFLAG_SET) == 0)
    {
    return;
    }

  for (rs = (resource *)GET_NEXT(at->at_val.at_list);rs != NULL;rs = (resource *)GET_NEXT(rs->rs_link)) 
    {
    resource_def *rd = rs->rs_defin;
    attribute     val;
    int           rc;

    if ((rd->rs_flags & resc_access_perm) == 0)
      continue;

    val = rs->rs_value;	/* copy resource attribute */

    /* count up sisterhood too */

    if (pjob->ji_resources != NULL) 
      {
      lnum = 0;

      if (!strcmp(rd->rs_name,"cput")) 
        {
        for (i = 0;i < pjob->ji_numnodes - 1;i++) 
          {
          lnum += pjob->ji_resources[i].nr_cput;
          }
        }
      else if (!strcmp(rd->rs_name,"mem")) 
        {
        for (i = 0;i < pjob->ji_numnodes - 1;i++) 
          {
          lnum += pjob->ji_resources[i].nr_mem;
          }
        }
      else if (!strcmp(rd->rs_name,"vmem"))
        {
        for (i = 0;i < pjob->ji_numnodes - 1;i++)
          {
          lnum += pjob->ji_resources[i].nr_vmem;
          }
        }

      val.at_val.at_long += lnum;
      }

    rc = rd->rs_encode(
      &val, 
      phead,
      ad->at_name, 
      rd->rs_name,
      ATR_ENCODE_CLIENT);

    if (rc < 0)
      break;
    }  /* END for (rs) */

  return;
  }  /* END encode_used() */




/*
 * req_stat_job - return the status of one (if id is specified) or all
 *	jobs (if id is the null string).
 */

void req_stat_job(

  struct batch_request *preq)

  {
  int			all;
  char			*name;
  job			*pjob;
  int			index;
  int			nth = 0;
  struct batch_reply	*preply = &preq->rq_reply;
  struct brp_status	*pstat;
  attribute		*at;
  attribute_def		*ad;

  /*
   * first, validate the name of the requested object, either
   * a single job or all jobs
   */

  name = preq->rq_ind.rq_status.rq_id;

  if ((*name == '\0') || (*name == '@')) 
    {
    all = 1;

    pjob = (job *)GET_NEXT(svr_alljobs);
    } 
  else 
    {
    all = 0;

    pjob = find_job(name);

    if (pjob == NULL) 
      {
      req_reject(PBSE_UNKJOBID, 0, preq,NULL,NULL);

      return;
      }
    }

  preply->brp_choice = BATCH_REPLY_CHOICE_Status;

  CLEAR_HEAD(preply->brp_un.brp_status);

  /* pass user-client privilege to encode_resc() */

  resc_access_perm = preq->rq_perm & ATR_DFLAG_RDACC;

  for (;pjob;pjob = all ? (job *)GET_NEXT(pjob->ji_alljobs) : NULL) 
    {
    if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) == 0)
      continue;	/* not Mother Superior */

    if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING)
      continue;

    /* allocate reply structure and fill in header portion */

    pstat = (struct brp_status *)malloc(sizeof(struct brp_status));

    assert(pstat != NULL);

    CLEAR_LINK(pstat->brp_stlink);

    pstat->brp_objtype = MGR_OBJ_JOB;

    strcpy(pstat->brp_objname, pjob->ji_qs.ji_jobid);

    CLEAR_HEAD(pstat->brp_attr);

    append_link(&preply->brp_un.brp_status,&pstat->brp_stlink,pstat);

    /* add attributes to the status reply */

    for (index = 0;(int)mom_rtn_list[index] >= 0;++index) 
      {
      nth = (int)mom_rtn_list[index];
      at  = &pjob->ji_wattr[nth];
      ad  = &job_attr_def[nth];

      if (at->at_flags & ATR_VFLAG_MODIFY) 
        {
        ad->at_encode(
          at, 
          &pstat->brp_attr,
          ad->at_name, 
          NULL,
          ATR_ENCODE_CLIENT);

        /* turn off modify so only sent if changed */
 
        at->at_flags &= ~ATR_VFLAG_MODIFY;
        }
      }

    /* now do resources used */

    encode_used(pjob,&pstat->brp_attr);
    }

  reply_send(preq);

  return;
  }  /* END req_statjob() */





/*
 * del_files - delete the files in a copy files or delete files request
 *
 *	WARNING WARNING WARNING WARNING WARNING WARNING WARNING 
 *
 *	fork_to_user() must be called first so that useruid/gid is set up
 */

static int del_files(

  struct batch_request *preq,      /* I */
  char                 *HDir,      /* I (home directory) */
  char                **pbadfile)  /* O */

  {
  int		 AsUser = FALSE;
  struct rqfpair  *pair;
  int		 rc = 0;
  char		 path[MAXPATHLEN + 1];
  char		 path_alt[MAXPATHLEN + 1];
  char		*pp;
  char		*prmt;
  struct stat	 sb;
  int		 rcstat;
  struct stat	 myspooldir;

  /* NOTE:  may be called as root in TORQUE home dir or as user in user homedir */

  /*
   * Build up path of file using local name only, then unlink it.
   * The first set of files may have the STDJOBFILE
   * flag set, which we need to unlink as root, the others as the user.
   * This is changed from the past.  We no longer delete
   * checkpoint files here.
   */

  if (HDir != NULL)
    {
    /* ignore failure */

    chdir(HDir);
    }

  for (pair = (struct rqfpair *)GET_NEXT(preq->rq_ind.rq_cpyfile.rq_pair);
      pair != NULL;
      pair = (struct rqfpair *)GET_NEXT(pair->fp_link)) 
    {
    prmt = pair->fp_rmt;

    path[0] = '\0';

    if (pair->fp_flag == STDJOBFILE) 
      {
      /* the job's stdout/stderr */

#ifndef NO_SPOOL_OUTPUT
      strncpy(path,path_spool,sizeof(path));
#endif	/* NO_SPOOL_OUTPUT */
      } 
    else if (AsUser == FALSE) 
      {
      /* NOTE:  if routine called as user, all of the following may silently fail */

      setgroups(ngroup,(gid_t *)groups);
      
      setgid(usergid);
      setuid(useruid);   /* run as the user */

      if (HDir != NULL)
        {
        /* ignore failure of chdir */

        chdir(HDir);
        }

      AsUser = TRUE;
      }

    strcat(path,pair->fp_local);

    if (local_or_remote(&prmt) == 0) 
      {
      /* local file, do source and destination match? */
      /* if so, don't delete it		     */

      if (is_file_same(prmt,path) == 1) 
        {
        continue;
        }
      }

    if (stat(path,&sb) == 0) 
      {
      if (S_ISDIR(sb.st_mode)) 
        {
        /* have a directory, must append last segment */
        /* of source name to it for  the unlink	      */

        /* check for  ~/.pbs_spool */
        /* if it isn't a dir., use $HOME us usual */
		
        strcpy(path_alt,path);
        strcat(path_alt,"/.pbs_spool/");

        rcstat = stat(path_alt,&myspooldir);
			
        if ((rcstat == 0) && 
            (S_ISDIR(myspooldir.st_mode)) && 
            ((myspooldir.st_mode & S_IXOTH) == S_IXOTH))
          {
          strcpy(path,path_alt); 
          }
        else
          {
          strcat(path, "/");
          }

        pp = strrchr(prmt,(int)'/');

        if (pp != NULL) 
          {
          ++pp;
          } 
        else if ((pp = strrchr(prmt,(int)':')))
          {
          ++pp;
          } 
        else 
          {
          pp = prmt;
          }

        strcat(path,pp);
        }
      } 
    else 
      {
      sprintf(log_buffer,"cannot stat %s", 
        path);

      LOG_EVENT(
        PBSEVENT_JOB, 
        PBS_EVENTCLASS_REQUEST,
        "del_files", 
        log_buffer);
      }
			
    if (remtree(path) == -1)
      {
      if (errno != ENOENT) 
        {
        sprintf(log_buffer,"Unable to delete file %s for user %s, error = %d",
          path, 
          preq->rq_ind.rq_cpyfile.rq_user, 
          errno);

        LOG_EVENT(
          PBSEVENT_JOB, 
          PBS_EVENTCLASS_REQUEST,
          "del_files", 
          log_buffer);

        add_bad_list(pbadfile,log_buffer,2);

        rc = errno;
        }

#ifdef DEBUG

      } 
    else 
      {
      sprintf(log_buffer,"Deleted file %s for user %s",
        path, 
        preq->rq_ind.rq_cpyfile.rq_user);

      LOG_EVENT(
        PBSEVENT_DEBUG, 
        PBS_EVENTCLASS_FILE,
        "del_files", 
        log_buffer);

#endif  /* DEBUG */
      }
    }

  return(rc);
  }  /* END del_files() */




void req_rerunjob(

  struct batch_request *preq)

  {
  job		*pjob;
  unsigned int	 port;
  int		 rc;
  int		 sock;
  char		*svrport;

  pjob = find_job(preq->rq_ind.rq_rerun);

  if (pjob == NULL) 
    {
    req_reject(PBSE_UNKJOBID,0,preq,NULL,NULL);

    return;
    }

  /* fork to send files back */

  if ((rc = fork_me(preq->rq_conn)) > 0) 
    {
    free_br(preq);	/* parent - note leave connection open   */

    return;
    } 
  else if (rc < 0) 
    {
    req_reject(-rc,0,preq,NULL,NULL);

    return;
    }

  /* Child process ...  for each standard file generate and */
  /* send a Job Files request(s).				  */

  svrport = strchr(pjob->ji_wattr[(int)JOB_ATR_at_server].at_val.at_str,(int)':');

  if (svrport)
    port = atoi(svrport+1);
  else
    port = default_server_port;

  sock = client_to_svr(pjob->ji_qs.ji_un.ji_momt.ji_svraddr,port,1);

  if (sock < 0) 
    {
    LOG_EVENT(
      PBSEVENT_ERROR,
      PBS_EVENTCLASS_REQUEST,
      "req_rerun", 
      "no contact with the server");

    req_reject(PBSE_NOSERVER, 0, preq,NULL,NULL);

    exit(0);
    }

  if (((rc = return_file(pjob,StdOut,sock)) != 0) ||
      ((rc = return_file(pjob, StdErr, sock)) != 0) ||
      ((rc = return_file(pjob, Chkpt, sock)) != 0)) 
    {
    req_reject(rc, 0, preq,NULL,NULL);
    }
  else
    {
    reply_ack(preq);
    (void)close(sock);

    exit(0);
    }

  return;
  }  /* END req_rerunjob() */






/*
 * sys_copy - issue system call to copy file
 *
 *	Check error and retry as required
 */

static int sys_copy(

  int   rmtflg,  /* I */
  char *ag2,
  char *ag3,
  int   conn)

  {
  char *ag0;
  char *ag1;
  int i;
  static char *myid = "sys_copy";
  int loop;
  int rc;

  static int failcount = 0;

  sprintf(rcperr,"%srcperr.%ld", 
    path_spool, 
    (long)getpid());

  for (loop = 1;loop < 5;++loop) 
    {
    if (rmtflg == 0) 
      {	/* local copy */
      ag0 = "/bin/cp";
      ag1 = "-r";

#ifdef SCP_PATH
      } 
    else if (((loop % 2) == 1) && (strcmp(SCP_PATH,"") != 0))
      {	/* remote, try scp */
      ag0 = SCP_PATH;
      ag1 = "-Br";
#endif	/* SCP_PATH */
      } 
    else 
      {
      ag0 = RCP_PATH;
      ag1 = "-r";
      }

    if (LOGLEVEL >= 3)
      {
      sprintf(log_buffer,"executing copy command: %s %s %s %s",
        ag0,
        ag1,
        ag2,
        ag3);
 
      LOG_EVENT(
        PBSEVENT_DEBUG,
        PBS_EVENTCLASS_FILE,
        myid,
        log_buffer);
      }

    if ((rc = fork()) > 0) 
      {
      /* Parent - wait for copy to complete */

      while (((i = wait(&rc)) < 0) && (errno == EINTR));

      if (i == -1)	
        {
        rc = (20000 + errno);	        /* 200xx is error on wait */
        } 
      else if (WIFEXITED(rc))   
        {
        if ((rc = WEXITSTATUS(rc)) == 0) 
          {
          return(rc);		        /* good,  stop now */
          }
        } 
      else if (WIFSTOPPED(rc))  
        {
        rc = (30000 + WSTOPSIG(rc));	/* 300xx is stopped */
        } 
      else if (WIFSIGNALED(rc)) 
        {
        rc = (40000 + WTERMSIG(rc));	/* 400xx is signaled */
        }
      } 
    else if (rc < 0) 
      {
      rc = errno + 10000;	/* error on fork (100xx), retry */
      } 
    else 
      {
      int fd;

      /* child - exec the copy command */

      rpp_terminate();

      close(conn);

      /* redirect stderr to make error from rcp available to MOM */

      if ((fd = open(rcperr,O_RDWR|O_CREAT,0644)) < 0) 
        {
        sprintf(log_buffer,"can't open %s, error = %d",
          rcperr,errno);

        LOG_EVENT(
          PBSEVENT_DEBUG, 
          PBS_EVENTCLASS_FILE,
          myid, 
          log_buffer);

        exit(12);
        };

      if (fd != 2) 
        {
        dup2(fd,2);
      
        close(fd);
        }

      execl(ag0,ag0,ag1,ag2,ag3,NULL);

      /* not reached on success */

      sprintf(log_buffer,"command: %s %s %s %s exec failed %d",
        ag0, 
        ag1, 
        ag2, 
        ag3, 
        errno);

      LOG_EVENT(
        PBSEVENT_DEBUG, 
        PBS_EVENTCLASS_FILE,
        myid,
        log_buffer);

      exit(13);	/* 13, an unlucky number */
      }

    /* copy did not work, try again */

    {
    char tmpLine[1024];

    switch(rc)
      {
      case 1:

        sprintf(tmpLine,"copy request failed");
       
        failcount++;

        break;

      case 0:

        sprintf(tmpLine,"copy request succeeded");

        failcount = 0;

        break;

      default:

        sprintf(tmpLine,"unknown copy failure");

        break;
      }  /* END switch(rc) */

    sprintf(log_buffer,"command: %s %s %s %s status=%d (%s), try=%d",
      ag0, 
      ag1, 
      ag2, 
      ag3, 
      rc, 
      tmpLine,
      loop);
    }  /* END BLOCK */

    LOG_EVENT(PBSEVENT_DEBUG,PBS_EVENTCLASS_FILE,myid,log_buffer);

    if ((loop % 2) == 0)	/* don't sleep between scp and rcp */
      sleep(loop/2 * 3 + 1);

    if (failcount >= 3)
      {
      /* data staging service may be disabled at destination? */

      if (errno == ENFILE)
        {
        snprintf(PBSNodeMsgBuf,sizeof(PBSNodeMsgBuf),
          "ERROR:  NOSTAGE - data staging services disabled");
        }
      }
    }  /* END for (loop) */

  return(rc);	/* tried a bunch of times, just give up */
  }  /* END sys_copy() */
	



		
/*
 * req_cpyfile - process the Copy Files request from the server to dispose
 *	of output from the job.  This is done by a child of MOM since it
 *	might take time.
 *
 *	The supplied PBS means of moving the file is by "rcp".
 * 	A site may wish to change this.
 */


/* NOTE:

---------------------------------------------------------------------------
PBS_BATCH_RunJob (received from sched)
        req_runjob
                svr_startjob
                        svr_stagein ----------------------> req_cpyfile
                                                                fork_to_user[1]
                        svr_strtjob2
                                send_job
                                        PBSD_queuejob ----> req_quejob[2]
                                        PBSD_jscript -----> req_jobscript
                                        PBSD_rdytocmt ----> req_rdytocommit
                                        PBSD_commit ------> req_commit[3]

[1] job not in svr_alljobs list (pjob == NULL)
[2] added to svr_newjobs list
[3] deleted from svr_newjobs, added to srv_alljobs

  therefore it is normal for pjob to be NULL in req_cpyfile.

*/

void req_cpyfile(

  struct batch_request *preq)  /* I */

  {
  char		 arg2[MAXPATHLEN + 1];
  char		 arg3[MAXPATHLEN + 1];
  int		 bad_files = 0;
  char		*bad_list = NULL;
  int		 dir;		
  int		 from_spool;
  int		 len;
  char		 localname[MAXPATHLEN + 1];  /* used only for in-bound */
  char		 localname_alt[MAXPATHLEN + 1];
  struct rqfpair  *pair;
  char		*prmt;
  int		 rc;
  int		 rmtflag;
  struct passwd	 *pw, mypw;
  struct stat	 myspooldir;
  int		 rcstat;
  char		 undelname[MAXPATHLEN + 1];
  struct stat    sb; /* see if local file is a regular file */
#ifdef  _CRAY
  char		 tmpdirname[MAXPATHLEN + 1];
#endif 	/* _CRAY */

  char           EMsg[1024];
  char           HDir[1024];

  if (LOGLEVEL >= 3)
    {
    LOG_EVENT(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      preq->rq_ind.rq_cpyfile.rq_jobid,
      log_buffer);
    }

  rc = (int)fork_to_user(preq,TRUE,HDir,EMsg);

  if (rc < 0) 
    {
    char tmpLine[1024];
    
    /* FAILURE */

    req_reject(-rc,0,preq,mom_host,EMsg);

    if ((rc != -PBSE_SYSTEM) && (rc != -PBSE_BADUSER))
      {
      sprintf(tmpLine,"fork_to_user failed with rc=%d '%s' - exiting",
        rc,
        EMsg);

      log_err(errno,"req_cpyfile",tmpLine);

      exit(rc);
      }

    sprintf(tmpLine,"fork_to_user failed with rc=%d '%s' - returning failure",
      rc,
      EMsg);

    log_err(errno,"req_cpyfile",tmpLine);

    return;
    }

  if (rc > 0)
    {
    /* parent - continue with other tasks */

    /* SUCCESS */

    return;     
    }

  /* child */

  /* now running as user in the user's home directory */

  /* build up cp/rcp command(s), one per file pair */

  dir = preq->rq_ind.rq_cpyfile.rq_dir;

  for (pair = (struct rqfpair *)GET_NEXT(preq->rq_ind.rq_cpyfile.rq_pair);
       pair != NULL;
       pair = (struct rqfpair *)GET_NEXT(pair->fp_link)) 
    {
    if ((pair->fp_rmt != NULL) && (!strcmp(pair->fp_rmt,"/dev/null")))
      {
      /* ignore copies to/from /dev/null */

      continue;
      }

    from_spool = 0;
    prmt       = pair->fp_rmt;
	
    if (local_or_remote(&prmt) == 0) 
      {
      /* destination host is this host, use cp */

      rmtflag = 0;
      } 
    else 
      {
      /* destination host is another, use (pbs_)rcp */

      rmtflag = 1;
      }

    /* which way to copy, in or out? */

    if (dir == STAGE_DIR_OUT) 
      {
      /*
       * out bound copy ...
       * build "from" path name, local to this system
       */

      localname[0] = '\0';

      if (pair->fp_flag == STDJOBFILE) 
        {
#ifndef NO_SPOOL_OUTPUT

        /* stdout | stderr from MOM's spool area */

        strncpy(localname,path_spool,sizeof(localname));

        from_spool = 1;	/* flag as being in spool dir */

        /*
         * note, if NO_SPOOL_OUTPUT is defined, the
         * output is in the user's home directory where
         * we currently are.
         */

#endif	/* NO_SPOOL_OUTPUT */
        }
#if MOM_CHECKPOINT == 1
      else if (pair->fp_flag == JOBCKPFILE) 
        {
        strncpy(localname,path_checkpoint,sizeof(localname));
        }
#endif	/* MOM_CHECKPOINT */

      /* check for $HOME/.pbs_spool */
      /* if it isn't a directory, just use $HOME us usual */
			
      pw = &mypw;
      pw = getpwuid(useruid); 	

      strcpy(localname_alt,pw->pw_dir); 

      rcstat = stat(localname_alt,&myspooldir);

      /* also need o+x perms. to write through as root via */
      /* an nfs mount --assuming root is squashed */

      if ((rcstat == 0) && 
          (S_ISDIR(myspooldir.st_mode)) &&  
          ((myspooldir.st_mode & S_IXOTH) == S_IXOTH))
        {
        strcat(localname_alt,"/.pbs_spool/");

        rcstat= stat(localname_alt,&myspooldir);

        if ((rcstat == 0) && 
            (S_ISDIR(myspooldir.st_mode)) && 
            ((myspooldir.st_mode & S_IXOTH) == S_IXOTH))
          {
          strcpy(localname,localname_alt);
          }
        }

      strcat(localname,pair->fp_local);

#if SRFS

      /* Is this file part of $BIGDIR or $FASTDIR ? */

      if (!strncmp(localname,"/BIGDIR",7)) 
        {
        sprintf(tmpname,"%s/%s",
          tmpdirname(var_value("BIGDIR",preq->rq_ind.rq_cpyfile.rq_jobid)),
          &localname[7]);

        strcpy(localname,tmpname);
        } 
      else if (!strncmp(localname,"/FASTDIR",8)) 
        {
        sprintf(tmpname,"%s/%s",
          tmpdirname(var_value("BIGDIR",preq->rq_ind.rq_cpyfile.rq_jobid)),
          &localname[8]);

        strcpy(localname,tmpname);
        }

#endif /* SRFS */

      /* Is the file there?  If not, don`t trying copy */

      if (access(localname,F_OK|R_OK) < 0)
        {
        if (errno == ENOENT) 
          {
          continue;
          }
        }

      /* Is this a regular file?  We wouldn't want to scp /dev/null! */

      if (stat(localname,&sb) < 0)
        continue;

      if (!S_ISREG(sb.st_mode))
        continue;

      strcpy(arg2,localname);

      /* take (remote) destination name from request */

      arg3[0] = '\0';

      if (rmtflag) 
        {
        /* using rcp, need to prepend the owner name */

        strcat(arg3,preq->rq_ind.rq_cpyfile.rq_owner);
        strcat(arg3,"@");
        }

      strcat(arg3,prmt);
      } 
    else 
      {	
      /* in bound (stage-in) file */

      /* take (remote) source name from request */

      arg2[0] = '\0';

      if (rmtflag) 
        {
        /* using rcp, need to prepend the owner name */

        strcat(arg2,preq->rq_ind.rq_cpyfile.rq_owner);
        strcat(arg2,"@");
        }

      strcat(arg2,prmt);

      strcpy(arg3,pair->fp_local);
      }

    if ((rmtflag == 0) && (is_file_same(arg2,arg3) == 1)) 
      {
      /* local file, source == destination, don't copy */

      continue;
      }

    if ((rc = sys_copy(rmtflag,arg2,arg3,preq->rq_conn)) != 0) 
      {
      FILE *fp;

      /* copy failed */

      bad_files = 1;

      sprintf(log_buffer,"Unable to copy file %s %s %s",
        pair->fp_local,
        (dir == STAGE_DIR_IN) ? "from" : "to",
        pair->fp_rmt);

      add_bad_list(&bad_list,log_buffer,2);

      log_record(
        PBSEVENT_ADMIN, 
        PBS_EVENTCLASS_FILE,
        pair->fp_local, 
        log_buffer);

      /* copy message from rcp as well */

      if ((fp = fopen(rcperr,"r")) != NULL) 
        {
        add_bad_list(&bad_list,">>> error from copy",1);

        while (fgets(log_buffer,LOG_BUF_SIZE,fp) != NULL) 
          {
          len = strlen(log_buffer) - 1;

          if (log_buffer[len] == '\n')
            log_buffer[len] = '\0';

          add_bad_list(&bad_list,log_buffer, 1);

          log_record(
            PBSEVENT_ADMIN, 
            PBS_EVENTCLASS_FILE,
            pair->fp_local, 
            log_buffer);
          }

        fclose(fp);

        add_bad_list(&bad_list,">>> end error output",1);
        }
		
      if (dir == STAGE_DIR_IN) 
        {
        /* delete the stage_in files that were just copied in */

        /* NOTE:  running as user in user homedir */

        del_files(preq,NULL,&bad_list);

#ifndef NO_SPOOL_OUTPUT
        } 
      else if (from_spool == 1) 
        {	
        /* copy out of spool */

        /* Copying out files and in spool area ... */
        /* move to "undelivered" directory         */

        strncpy(localname,path_spool,sizeof(localname));
        strncat(localname,pair->fp_local,sizeof(localname));
        strncpy(undelname,path_undeliv,sizeof(undelname));
        strncat(undelname,pair->fp_local,sizeof(undelname));

        if (rename(localname,undelname) == 0) 
          {
          add_bad_list(&bad_list,output_retained,1);
          add_bad_list(&bad_list,undelname,0);
          } 
        else 
          {
          sprintf(arg3,"Unable to rename %s to %s",
            localname, 
            undelname);

          log_err(errno,"req_cpyfile",arg3);
          }
#endif	/* NO_SPOOL_OUTPUT */
        }

      if (dir == STAGE_DIR_IN) 
        {
        unlink(rcperr);

        break;
        }
      }    /* END if ((rc = sys_copy(rmtflag,arg2,arg3,preq->rq_conn)) != 0) */ 
    else 
      {
      /* Copy in/out succeeded */

      if (dir == STAGE_DIR_OUT) 
        {
        /* have copied out, ok to remove local one */

        if (remtree(localname) < 0) 
          {
          sprintf(arg3,msg_err_unlink, 
            "stage out",
            localname);

          log_err(errno,"req_cpyfile",arg3);

          add_bad_list(&bad_list,arg3,2);

          bad_files = 1;
          }
        }
      }

    unlink(rcperr);
    }  /* END for() */

  if (bad_files) 
    {
    reply_text(preq,PBSE_NOCOPYFILE,bad_list);
    } 
  else 
    {
    reply_ack(preq);
    }

  /* we are the child, exit not return */

  /* SUCCESS */

  exit(0);
  }  /* END req_cpyfile() */





/*
 * req_delfile - delete the specifled output/staged files 
 */

void req_delfile(

  struct batch_request *preq)

  {
  int	 rc;
  char	*bad_list = NULL;

  char   HDir[1024];
  char   EMsg[1024];

  rc = (int)fork_to_user(preq,FALSE,HDir,EMsg);

  if (rc < 0)
    {
    /* FAILURE */

    req_reject(-rc,0,preq,mom_host,EMsg);

    return;
    }

  if (rc > 0) 
    {
    /* parent */

    /* continue with other tasks */

    /* SUCCESS */

    return;
    } 

  /* child */

  /* running as root in TORQUE homedir */

  /* delete the files */

  if ((rc = del_files(preq,HDir,&bad_list)))
    {
    /* FAILURE */

    reply_text(preq,rc,bad_list);

    exit(0);
    } 

  /* SUCCESS */

  reply_ack(preq);

  /* we are the child, exit not return */

  exit(0); 
  }  /* END req_delfile() */





#if MOM_CHECKPOINT == 1
/*
 * Checkpoint the job.
 *
 *	If abort is TRUE, kill it too.  Return a PBS error code.
 */

int mom_checkpoint_job(

  job *pjob,  /* I */
  int  abort) /* I */

  {
  static char	id[] = "mom_checkpoint_job";
  int		hasold = 0;
  int		sesid = -1;
  int		ckerr;
  int		i;
  struct stat	statbuf;
  char		path[MAXPATHLEN+1];
  char		oldp[MAXPATHLEN+1];
  char		file[MAXPATHLEN+1], *name;
  int		filelen;
  task		*ptask;
  extern	char	task_fmt[];

  assert(pjob != NULL);

  strcpy(path,path_checkpoint);
  strcat(path,pjob->ji_qs.ji_fileprefix);
  strcat(path,JOB_CKPT_SUFFIX);

  if (stat(path,&statbuf) == 0) 
    {
    strcpy(oldp,path);   /* file already exists, rename it */

    strcat(oldp,".old");

    if (rename(path,oldp) < 0)
      {
      return(errno);
      }

    hasold = 1;
    }

  if (mkdir(path,0755) == -1)
    goto fail;

  filelen = strlen(path);

  strcpy(file,path);

  name = &file[filelen];

#ifdef _CRAY

  /*
   * if job is suspended and if <abort> is set, resume job first,
   * this is so job will be "Q"ueued and then back into "R"unning
   * when restarted.
   */

  if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_Suspend) && abort) 
    {
    for (ptask = (task *)GET_NEXT(pjob->ji_tasks); 
         ptask != NULL; 
         ptask = (task *)GET_NEXT(ptask->ti_jobtask)) 
      {
      sesid = ptask->ti_qs.ti_sid;

      if (ptask->ti_qs.ti_status != TI_STATE_RUNNING)
        continue;

      /* What to do if some resume work and others don't? */

      if ((ckerr = resume(C_JOB,sesid)) == 0) 
        {
        post_resume(pjob, ckerr);
        } 
      else 
        {
        sprintf(log_buffer,"chkpnt failed: errno=%d sid=%d",
          errno, 
          sesid);

        LOG_EVENT(
          PBSEVENT_JOB, 
          PBS_EVENTCLASS_JOB,
          pjob->ji_qs.ji_jobid, 
          log_buffer);

        return(errno);
        }
      }
    }
#endif	/* _CRAY */

	for (ptask = (task *)GET_NEXT(pjob->ji_tasks);
			ptask != NULL;
			ptask = (task *)GET_NEXT(ptask->ti_jobtask)) {

		sesid = ptask->ti_qs.ti_sid;
		if (ptask->ti_qs.ti_status != TI_STATE_RUNNING)
			continue;
		sprintf(name, task_fmt, ptask->ti_qs.ti_task);
		if (mach_checkpoint(ptask, file, abort) == -1)
			goto fail;
	}

	/* Checkpoint successful */

	(void)job_save(pjob, SAVEJOB_FULL);  /* to save resources_used so far */
	sprintf(log_buffer, "checkpointed to %s", path);
	log_record(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,
		   pjob->ji_qs.ji_jobid, log_buffer);
	if (hasold) 
		(void)remtree(oldp);

       	return (PBSE_NONE);

 fail:
	/*
	** A checkpoint has failed.  Log and return error.
	*/
	ckerr = errno;
	sprintf(log_buffer,"chkpnt failed:errno=%d sid=%d", errno, sesid);
	LOG_EVENT(PBSEVENT_JOB, PBS_EVENTCLASS_JOB,pjob->ji_qs.ji_jobid,
		  log_buffer);

	/*
	** See if any checkpoints worked and abort is set.
	** If so, we need to restart these tasks so the whole job is
	** still running.  This has to wait until we reap the
	** aborted task(s).
	*/
	if (abort)
		return PBSE_CKPSHORT;

	/*
	** Clean up files.
	*/
	(void)remtree(path);
	if (hasold) {
		if (rename(oldp, path) == -1)
			pjob->ji_qs.ji_svrflags &= ~JOB_SVFLG_CHKPT;
	}
	if (ckerr == EAGAIN)
		return (PBSE_CKPBSY);
	else
		return(ckerr);
}





/* 
 * post_chkpt - post processor for start_checkpoint()
 *
 *	Called from scan_for_terminated() when found in ji_mompost;
 *	This sets the "has checkpoint image" bit in the job.
 */

void post_chkpt(pjob, ev)
	job *pjob;
	int  ev;
{
	char		path[MAXPATHLEN+1];
	DIR		*dir;
	struct	dirent	*pdir;
	extern	char	*path_checkpoint;
	tm_task_id	tid;
	task		*ptask;
	int		abort = pjob->ji_flags & MOM_CHKPT_ACTIVE;

	exiting_tasks = 1;	/* make sure we call scan_for_exiting() */
	pjob->ji_flags &= ~MOM_CHKPT_ACTIVE;
	if (ev == 0) {
		pjob->ji_qs.ji_svrflags |= JOB_SVFLG_CHKPT;
		return;
	}

	/*
	** If we get here, an error happened.  Only try to recover
	** if we had abort set.
	*/
	if (abort == 0)
		return;
	/*
	** Set a flag for scan_for_exiting() to be able to
	** deal with a failed checkpoint rather than doing
	** the usual processing.
	*/
	pjob->ji_flags |= MOM_CHKPT_POST;

	/*
	** Set the TI_FLAGS_CHKPT flag for each task that
	** was checkpointed and aborted.
	*/
	strcpy(path, path_checkpoint);
	strcat(path, pjob->ji_qs.ji_fileprefix);
	strcat(path, JOB_CKPT_SUFFIX);

	dir = opendir(path);
	if (dir == NULL)
		return;
	while ((pdir = readdir(dir)) != NULL) {
		if (pdir->d_name[0] == '.')
			continue;
		tid = atoi(pdir->d_name);
		if (tid == 0)
			continue;
		ptask = task_find(pjob, tid);
		if (ptask == NULL)
			continue;
		ptask->ti_flags |= TI_FLAGS_CHKPT;
	}
	closedir(dir);
	return;
}






/*
 * start_checkpoint - start a checkpoint going
 *
 *	checkpoint done from a child because it takes a while 
 */

int start_checkpoint(

  job *pjob,
  int  abort,
  struct batch_request *preq)	/* may be null */

  {
  static char	id[] = "start_checkpoint";
  svrattrl *pal;
  pid_t     pid;
  int       rc;
  int       sock = -1;
  attribute tmph;

  if (mom_does_chkpnt() == 0) 	/* no checkpoint, reject request */
    {
    return(PBSE_NOSUP);
    }

  /* now set up as child of MOM */

  if (preq != NULL)
    sock = preq->rq_conn;

  pid = fork_me(sock);

  if (pid > 0) 
    {
    /* parent, record pid in job for when child terminates */

    pjob->ji_momsubt = pid;
    pjob->ji_mompost = post_chkpt;

    if (preq)
      free_br(preq);

    /* If we are going to have tasks dieing, set a flag. */

    if (abort)
      pjob->ji_flags |= MOM_CHKPT_ACTIVE;
    } 
  else if (pid < 0) 
    {
    char tmpLine[1024];

    /* error on fork */

    sprintf(tmpLine,"cannot fork child process for checkpoint, errno=%d",
      errno);

    log_err(-1,id,tmpLine);

    return(PBSE_SYSTEM);	
    } 
  else 
    {
    /* child - does the checkpoint */

    int hok = 1;

    clear_attr(&tmph, &job_attr_def[(int)JOB_ATR_hold]);

    if (preq) 
      {
      pal = (svrattrl *)GET_NEXT(preq->rq_ind.rq_hold.rq_orig.rq_attr);

      if (pal) 
        {
        hok = job_attr_def[(int)JOB_ATR_hold].at_decode(
							&tmph,
							pal->al_name,
							(char *)0,
							pal->al_value);
			}
		}
		rc = mom_checkpoint_job(pjob, abort);
		if (preq != (struct batch_request *)0) {
			/*
			** rc may be 0, req_reject is used
			** to pass auxcode
			*/
			req_reject(rc, PBS_CHKPT_MIGRATE, preq,NULL,NULL);
		}
		if ( (rc == 0) && (hok == 0) )
			rc = site_mom_postchk(pjob, (int)tmph.at_val.at_long);

		exit(rc);	/* zero exit tells main chkpnt ok */
    }

  return (0);		/* parent return */
  }  /* END start_checkpoint() */

#endif	/* MOM_CHECKPOINT */


/* END requests.c */
