/*
*         OpenPBS (Portable Batch System) v2.3 Software License
* 
* Copyright (c) 1999-2000 Veridian Information Solutions, Inc.
* All rights reserved.
* 
* ---------------------------------------------------------------------------
* For a license to use or redistribute the OpenPBS software under conditions
* other than those described below, or to purchase support for this software,
* please contact Veridian Systems, PBS Products Department ("Licensor") at:
* 
*    www.OpenPBS.org  +1 650 967-4675                  sales@OpenPBS.org
*                        877 902-4PBS (US toll-free)
* ---------------------------------------------------------------------------
* 
* This license covers use of the OpenPBS v2.3 software (the "Software") at
* your site or location, and, for certain users, redistribution of the
* Software to other sites and locations.  Use and redistribution of
* OpenPBS v2.3 in source and binary forms, with or without modification,
* are permitted provided that all of the following conditions are met.
* After December 31, 2001, only conditions 3-6 must be met:
* 
* 1. Commercial and/or non-commercial use of the Software is permitted
*    provided a current software registration is on file at www.OpenPBS.org.
*    If use of this software contributes to a publication, product, or
*    service, proper attribution must be given; see www.OpenPBS.org/credit.html
* 
* 2. Redistribution in any form is only permitted for non-commercial,
*    non-profit purposes.  There can be no charge for the Software or any
*    software incorporating the Software.  Further, there can be no
*    expectation of revenue generated as a consequence of redistributing
*    the Software.
* 
* 3. Any Redistribution of source code must retain the above copyright notice
*    and the acknowledgment contained in paragraph 6, this list of conditions
*    and the disclaimer contained in paragraph 7.
* 
* 4. Any Redistribution in binary form must reproduce the above copyright
*    notice and the acknowledgment contained in paragraph 6, this list of
*    conditions and the disclaimer contained in paragraph 7 in the
*    documentation and/or other materials provided with the distribution.
* 
* 5. Redistributions in any form must be accompanied by information on how to
*    obtain complete source code for the OpenPBS software and any
*    modifications and/or additions to the OpenPBS software.  The source code
*    must either be included in the distribution or be available for no more
*    than the cost of distribution plus a nominal fee, and all modifications
*    and additions to the Software must be freely redistributable by any party
*    (including Licensor) without restriction.
* 
* 6. All advertising materials mentioning features or use of the Software must
*    display the following acknowledgment:
* 
*     "This product includes software developed by NASA Ames Research Center,
*     Lawrence Livermore National Laboratory, and Veridian Information 
*     Solutions, Inc.
*     Visit www.OpenPBS.org for OpenPBS software support,
*     products, and information."
* 
* 7. DISCLAIMER OF WARRANTY
* 
* THIS SOFTWARE IS PROVIDED "AS IS" WITHOUT WARRANTY OF ANY KIND. ANY EXPRESS
* OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
* OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, AND NON-INFRINGEMENT
* ARE EXPRESSLY DISCLAIMED.
* 
* IN NO EVENT SHALL VERIDIAN CORPORATION, ITS AFFILIATED COMPANIES, OR THE
* U.S. GOVERNMENT OR ANY OF ITS AGENCIES BE LIABLE FOR ANY DIRECT OR INDIRECT,
* INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
* LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA,
* OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF
* LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING
* NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE,
* EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* 
* This license will be governed by the laws of the Commonwealth of Virginia,
* without reference to its choice of law rules.
*/
/*
 * The entry point function for MOM.
 */

#include <pbs_config.h>   /* the master config generated by configure */

#include	<assert.h>
#include	<stdio.h>
#include	<stdlib.h>
#include	<unistd.h>
#include        <stdarg.h>

#ifdef _CRAY
#include	<termios.h>
#endif /* _CRAY */

#include	<pwd.h>
#include	<signal.h>
#include	<string.h>
#include	<ctype.h>
#include	<errno.h>
#include	<fcntl.h>
#include	<time.h>
#include	<limits.h>
#include	<netdb.h>
#include	<grp.h>
#include	<sys/types.h>
#include	<sys/param.h>
#include	<sys/times.h>
#include	<sys/stat.h>
#if (PLOCK_DAEMONS & 4)
#include	<sys/lock.h>
#endif	/* PLOCK_DAEMONS */
#include	<netinet/in.h>
#include	<sys/socket.h>
#ifdef _CRAY
#include	<sys/category.h>
#include	<sys/usrv.h>
#include	<sys/sysv.h>
#endif	/* _CRAY */
#include	<sys/time.h>
#include	<sys/resource.h>
#include	<sys/utsname.h>

#include 	"libpbs.h"
#include 	"pbs_ifl.h"
#include	"server_limits.h"
#include	"list_link.h"
#include	"attribute.h"
#include	"resource.h"
#include	"job.h"
#include	"mom_mach.h"
#include	"mom_func.h"
#include	"svrfunc.h"
#include	"pbs_error.h"
#include	"log.h"
#include	"net_connect.h"
#include	"rpp.h"
#include	"dis.h"
#include	"dis_init.h"
#include	"resmon.h"
#include        "pbs_version.h"
#include        "pbs_nodes.h"

#include        "mcom.h"

#ifdef __PPINMEM
#include <sys/mman.h>
#endif /* __PPINMEM */

#define CHECK_POLL_TIME     45
#define DEFAULT_SERVER_STAT_UPDATES 45

#define PBS_MAXSERVER       4
#define PMAX_PORT           32000

/* Global Data Items */

int             ServerStatUpdateInterval = DEFAULT_SERVER_STAT_UPDATES;
int             CheckPollTime            = CHECK_POLL_TIME;

double		cputfactor = 1.00;
unsigned int	default_server_port;
int		exiting_tasks = 0;
float		ideal_load_val = -1.0;
int		internal_state = UPDATE_MOM_STATE;

int		lockfds = -1;
time_t		loopcnt;		/* used for MD5 calc */
float		max_load_val = -1.0;
char		mom_host[PBS_MAXHOSTNAME + 1];
char		pbs_servername[PBS_MAXSERVER][PBS_MAXHOSTNAME + 1];
char		mom_short_name[PBS_MAXHOSTNAME + 1];
int		num_var_env;
char	       *path_epilog;
char           *path_epilogp;
char           *path_epiloguser;
char           *path_epiloguserp;
char           *path_epilogpdel;
char	       *path_jobs;
char	       *path_prolog;
char           *path_prologp;
char           *path_prologuser;
char           *path_prologuserp;
char	       *path_spool;
char	       *path_undeliv;
char           *path_home = PBS_SERVER_HOME;
char           *mom_home;
char		pbs_current_user[PBS_MAXUSER] = "pbs_mom";  /* for libpbs.a */
char	       *msg_daemonname = pbs_current_user;          /* for logs     */
int		pbs_errno;
gid_t		pbsgroup;
unsigned int	pbs_mom_port;
unsigned int	pbs_rm_port;
list_head	mom_polljobs;	/* jobs that must have resource limits polled */
list_head	svr_newjobs;	/* jobs being sent to MOM */
list_head	svr_alljobs;	/* all jobs under MOM's control */
int		termin_child = 0;
time_t		time_now = 0;
time_t		polltime = 0;
extern list_head svr_requests;
extern struct var_table vtable;	/* see start_exec.c */
#if MOM_CHECKPOINT == 1
char	       *path_checkpoint = (char *)0;
static resource_def *rdcput;
#endif	/* MOM_CHECKPOINT */
double		wallfactor = 1.00;

/* externs */

extern int      server_stream;  /* connection to the server... */
extern unsigned int pe_alarm_time;
extern time_t   pbs_tcp_timeout;

time_t          LastServerUpdateTime = 0;

time_t          MOMStartTime              = 0;
time_t          MOMLastSendToServerTime   = 0;
time_t          MOMLastRecvFromServerTime = 0;
char            MOMLastRecvFromServerCmd[MMAX_LINE];

int             MOMRecvHelloCount         = 0;
int             MOMRecvClusterAddrsCount  = 0;
int             MOMSendHelloCount         = 0;
char            MOMSendStatFailure[MMAX_LINE];

char            MOMConfigVersion[64];
char            MOMUNameMissing[64];            

int             MOMConfigDownOnError      = 0;

#define TMAX_JE  64

pjobexec_t      TMOMStartInfo[TMAX_JE];

               
/* prototypes */

extern void     add_resc_def(char *,char *);


#define PMOMTCPTIMEOUT 60  /* duration in seconds mom TCP requests will block */


/* Local Data Items */

static char *log_file = NULL;

enum PMOMStateEnum { 
  MOM_RUN_STATE_RUNNING, 
  MOM_RUN_STATE_EXIT, 
  MOM_RUN_STATE_KILLALL };

static enum PMOMStateEnum mom_run_state;

static int recover = 0;

static int      call_hup = 0;
static int      nconfig;
static char    *path_log;

struct	config_list {
  struct config	      c;
  struct config_list *c_link;
  };

int                     LOGLEVEL = 0;  /* valid values (0 - 10) */
int                     DEBUGMODE = 0;
char                    CHECKPOINT_SCRIPT[1024];
long                    TJobStartBlockTime = 5; /* seconds to wait for job to launch before backgrounding */
long                    TJobStartTimeout = 300; /* seconds to wait for job to launch before purging */


char                   *ret_string;
int			ret_size;
struct	config         *config_array = NULL;
struct	config_list    *config_list = NULL;
sigset_t		allsigs;
int			rm_errno;
unsigned int            reqnum = 0;		/* the packet number */

int			port_care = TRUE;	/* secure connecting ports */
uid_t			uid = 0;		/* uid we are running with */
int			alarm_time = 10;	/* time before alarm */

extern void            *okclients;		/* accept connections from */
char                  **maskclient = NULL;	/* wildcard connections */
int			mask_num = 0;
int			mask_max = 0;
u_long			localaddr = 0;

char			extra_parm[] = "extra parameter(s)";
char			no_parm[]    = "required parameter not found";

int			cphosts_num = 0;
struct cphosts         *pcphosts = NULL;

static	int		config_file_specified = 0;
static	char		config_file[_POSIX_PATH_MAX] = "config";

char                    PBSNodeMsgBuf[1024];
char                    PBSNodeCheckPath[1024];
int                     PBSNodeCheckInterval;

/* sync w/#define JOB_SUBSTATE_XXX (in include/job.h)*/

const char *PJobSubState[] = {
  "TRANSIN",                /* Transit in, wait for commit */
  "TRANSICM",               /* Transit in, wait for commit */
  "TRNOUT",                 /* transiting job outbound */
  "TRNOUTCM",               /* transiting outbound, rdy to commit */
  "SUBSTATE04",
  "SUBSTATE05",
  "SUBSTATE06",
  "SUBSTATE07",
  "SUBSTATE08",
  "SUBSTATE09",
  "QUEUED",                 /* job queued and ready for selection */
  "PRESTAGEIN",             /* job queued, has files to stage in */
  "SUBSTATE12",
  "SYNCRES",                /* job waiting on sync start ready */
  "STAGEIN",                /* job staging in files then wait */
  "STAGEGO",                /* job staging in files and then run */
  "STAGECMP",               /* job stage in complete */
  "SUBSTATE17",
  "SUBSTATE18",
  "SUBSTATE19",
  "HELD",      /* job held - user or operator */
  "SYNCHOLD",  /* job held - waiting on sync regist */
  "DEPNHOLD",  /* job held - waiting on dependency */
  "SUBSTATE23",
  "SUBSTATE24",
  "SUBSTATE25",
  "SUBSTATE26",
  "SUBSTATE27",
  "SUBSTATE28",
  "SUBSTATE29",
  "WAITING",   /* job waiting on execution time */
  "SUBSTATE31",
  "SUBSTATE32",
  "SUBSTATE33",
  "SUBSTATE34",
  "SUBSTATE35",
  "SUBSTATE36",
  "STAGEFAIL", /* job held - file stage in failed */
  "SUBSTATE38",
  "SUBSTATE39",
  "PRERUN",    /* job sent to MOM to run */
  "STARTING",  /* final job start initiated */
  "RUNNING",   /* job running */
  "SUSPEND",   /* job suspended, CRAY only */
  "SUBSTATE44",
  "SUBSTATE45",
  "SUBSTATE46",
  "SUBSTATE47",
  "SUBSTATE48",
  "SUBSTATE49",
  "EXITING",   /* Start of job exiting processing */
  "STAGEOUT",  /* job staging out (other) files   */
  "STAGEDEL",  /* job deleteing staged out files  */
  "EXITED",    /* job exit processing completed   */
  "ABORT",     /* job is being aborted by server  */
  "SUBSTATE55",
  "SUBSTATE56",
  "SUBSTATE57",
  "OBIT",      /* (MOM) job obit notice sent */
  "COMPLETED",
  "RERUN",     /* job is rerun, recover output stage */
  "RERUN1",    /* job is rerun, stageout phase */
  "RERUN2",    /* job is rerun, delete files stage */
  "RERUN3",    /* job is rerun, mom delete job */
  NULL };


/* sync w/#define IS_XXX */

const char *PBSServerCmds[] = {
  "NULL",
  "HELLO",
  "CLUSTER_ADDRS",
  "UPDATE",
  "STATUS",
  NULL };


/*
**	These routines are in the "dependent" code.
*/

extern	void	dep_initialize A_((void));
extern	void	dep_cleanup A_((void));

/* External Functions */

extern void  catch_child A_((int));
extern void  init_abort_jobs A_((int));
extern void  scan_for_exiting();
extern void  scan_for_terminated();

/* Local public functions */

static void stop_me A_((int));
static void PBSAdjustLogLevel A_((int));
int         TMOMScanForStarting(void);


/* Local private functions */

static char *mk_dirs A_((char *));
int is_update_stat(int);


int MUSNPrintF(

  char **BPtr,   /* I */
  int   *BSpace, /* I */
  char  *Format, /* I */
  ...)           /* I */

  {
  int len;

  va_list Args;

  if ((BPtr == NULL) ||
      (BSpace == NULL) ||
      (Format == NULL) ||
      (*BSpace <= 0))
    {
    return(FAILURE);
    }

  va_start(Args,Format);

  len = vsnprintf(*BPtr,*BSpace,Format,Args);

  va_end(Args);

  if (len <= 0)
    {
    return(FAILURE);
    }

  *BPtr += len;
  *BSpace -= len;

  return(SUCCESS);
  }  /* END MUSNPrintf() */




int MUStrNCat(

  char **BPtr,   /* I (modified) */
  int   *BSpace, /* I (modified) */
  char  *Src)    /* I */

  {
  int index;

  if ((BPtr == NULL) || (BSpace == NULL) || (*BSpace <= 0))
    {
    return(FAILURE);
    }

  if ((Src == NULL) || (Src[0] == '\0'))
    {
    return(SUCCESS);
    }

  for (index = 0;index < *BSpace - 1;index++)
    {
    if (Src[index] == '\0')
      break;

    (*BPtr)[index] = Src[index];
    }  /* END for (index) */

  (*BPtr)[index] = '\0';

  *BPtr   += index;
  *BSpace -= index;

  return(SUCCESS);
  }  /* END MUStrNCat() */


char *nullproc(

  struct rm_attribute *attrib)

  {
  char *id = "nullproc";

  log_err(-1,id,"should not be called");

  return(NULL);
  }  /* END nullproc() */




static char *arch(

  struct rm_attribute *attrib)

  {
  char *id = "arch";

  struct config *cp;

  if (attrib != NULL) 
    {
    log_err(-1,id,extra_parm);

    rm_errno = RM_ERR_BADPARAM;

    return(NULL);
    }

  /* locate arch string */

  for (cp = config_array;cp->c_name != NULL;cp++)
    {
    if (cp->c_u.c_value == NULL)
      continue;

    if (strcmp(cp->c_name,"arch"))
      continue; 

    return(cp->c_u.c_value);
    }  /* END for (cp) */

  return(PBS_MACH);
  }  /* END arch() */




static char *opsys(
 
  struct rm_attribute *attrib)  /* I */

  {
  char *id = "opsys";

  struct config *cp;

  if (attrib != NULL) 
    {
    log_err(-1,id,extra_parm);

    rm_errno = RM_ERR_BADPARAM;

    return(NULL);
    }

  /* locate opsys string */

  for (cp = config_array;cp->c_name != NULL;cp++)
    {
    if (cp->c_u.c_value == NULL)
      continue;

    if (strcmp(cp->c_name,"opsys"))
      continue; 

    return(cp->c_u.c_value);
    }  /* END for (cp) */

  return(PBS_MACH);
  }  /* END opsys() */





char *getuname()

  {
  struct utsname  n;
  static char    *name = NULL;

  if (name == NULL) 
    {
    if (uname(&n) == -1)
      {
      return(NULL);
      }

    sprintf(ret_string,"%s %s %s %s %s", 
      n.sysname,
      n.nodename, 
      n.release, 
      n.version, 
      n.machine);

    name = strdup(ret_string);
    }  /* END if (name == NULL) */

  return(name);
  }  /* END getuname() */




static char *reqmsg(

  struct rm_attribute *attrib)

  {
  char  *id = "reqmsg";

  if (attrib != NULL)
    {
    log_err(-1,id,extra_parm);

    rm_errno = RM_ERR_BADPARAM;

    return(NULL);
    }

  return(PBSNodeMsgBuf);
  }  /* END reqmsg() */




static char *reqgres(

  struct rm_attribute *attrib)  /* I (ignored) */

  {
  char  *id = "reqgres";

  struct config *cp;

  static char   GResBuf[1024];
  char          tmpLine[1024];

  if (attrib != NULL)
    {
    log_err(-1,id,extra_parm);

    rm_errno = RM_ERR_BADPARAM;

    return(NULL);
    }

  /* build gres string */

  /* FORMAT:  <GRES>:<VALUE>[+<GRES>:<VALUE>]... */

  GResBuf[0] = '\0';

  for (cp = config_array;cp->c_name != NULL;cp++)
    {
    if (cp->c_u.c_value == NULL)
      continue;

    if (!strcmp(cp->c_name,"node_check_interval") ||
        !strcmp(cp->c_name,"node_check_script") ||
        !strcmp(cp->c_name,"ideal_load") ||
        !strcmp(cp->c_name,"max_load") ||
        !strcmp(cp->c_name,"arch") ||
        !strcmp(cp->c_name,"opsys") ||
        !strncmp(cp->c_name,"size",strlen("size")))
      {
      continue;
      }

    if (GResBuf[0] != '\0')
      strncat(GResBuf,"+",1024);

    snprintf(tmpLine,1024,"%s:%s",
      cp->c_name,
      cp->c_u.c_value);

    strncat(GResBuf,tmpLine,1024);
    }  /* END for (cp) */

  return(GResBuf);
  }  /* END reqgres() */




static char *reqstate(

  struct rm_attribute *attrib)  /* I (ignored) */

  {
  char *id = "reqstate";

  static char state[1024];

  if ((internal_state & INUSE_DOWN) && (MOMConfigDownOnError != 0))
    strcpy(state,"down");
  else if (internal_state & INUSE_BUSY)
    strcpy(state,"busy");
  else
    strcpy(state,"free");

  return(state);
  }  /* END reqstate() */




static char *requname(

  struct rm_attribute *attrib)

  {
  char	*id = "uname";
  char	*cp;

  if (attrib != NULL) 
    {
    log_err(-1,id,extra_parm);

    rm_errno = RM_ERR_BADPARAM;

    return(NULL);
    }

  cp = getuname();

  return(cp);
  }  /* END requname() */





static char *validuser(

  struct rm_attribute *attrib)

  {
  char	*id = "valid_user";
  struct passwd *p;

  if ((attrib == NULL) || (attrib->a_value == NULL)) 
    {
    log_err(-1,id,no_parm);
    rm_errno = RM_ERR_NOPARAM;

    return(NULL);
    }

  p = getpwnam(attrib->a_value);

  if (p != NULL) 
    {
    return("yes");
    } 

  return("no");
  }    /* END validuser() */





char *loadave(

  struct rm_attribute *attrib)

  {
  char	      *id = "loadave";
  static char  ret_string[20];
  double       la;

  if (attrib) 
    {
    log_err(-1,id,extra_parm);

    rm_errno = RM_ERR_BADPARAM;

    return(NULL);
    }

  if (get_la(&la) != 0) 
    {
    rm_errno = RM_ERR_SYSTEM;

    return(NULL);
    }

  sprintf(ret_string,"%.2f",
    la);

  return(ret_string);
  }  /* END loadave() */




struct	config	common_config[] = {
  { "arch",      {arch} },
  { "opsys",     {opsys} },
  { "uname",     {requname} },
  { "validuser", {validuser} },
  { "message",   {reqmsg} },
  { "gres",      {reqgres} },
  { "state",     {reqstate} },
  { NULL,        {nullproc} } };




/*
**	Search the array of resources read from the config files.
*/

struct config *rm_search(

  struct config	*where,
  char          *what)

  {
  struct config	*cp;

  if (where == NULL || what == NULL)
    {
    return NULL;
    }

  for (cp = where;cp->c_name != NULL;cp++) 
    {
    if (strcmp(cp->c_name,what) == 0)
      {
      return(cp);
      }
    }    /* END for (cp) */

  return(NULL);
  }  /* END rm_search() */





/*
**	Search the various resource lists.
*/

char *dependent(

  char	              *res,
  struct rm_attribute *attr)

  {
  struct config	       *ap;
  extern struct	config  standard_config[];
  extern struct	config  dependent_config[];

  ap = rm_search(common_config,res);

  if (ap != NULL)
    {
    return(ap->c_u.c_func(attr));
    }

  ap = rm_search(standard_config,res);

  if (ap != NULL)
    {
    return(ap->c_u.c_func(attr));
    }

  ap = rm_search(dependent_config,res);

  if (ap != NULL)
    {
    return(ap->c_u.c_func(attr));
    }

  rm_errno = RM_ERR_UNKNOWN;

  return(NULL);
  }  /* END dependent() */






void DIS_rpp_reset()

  {
  if (dis_getc != rpp_getc) 
    {
    dis_getc = rpp_getc;
    dis_puts = (int (*) A_((int, const char *, size_t)) )rpp_write;
    dis_gets = (int (*) A_((int, char *, size_t)) )rpp_read;
    disr_skip   = (int (*) A_((int, size_t)) )rpp_skip;

    disr_commit = rpp_rcommit;
    disw_commit = rpp_wcommit;
    }

  return;
  }  /* END DIS_rpp_reset() */





/*
**	Initialize standard resource array
*/

void initialize()

  {
  char *id = "initialize";

  log_record(PBSEVENT_SYSTEM,0,id,"independent");

  dep_initialize();

  return;
  }




void cleanup()

  {
  dep_cleanup();

  return;
  }




/*
**	Clean up after a signal.
*/

void die(

  int sig)

  {
  char *id = "die";

  if (sig > 0) 
    {
    sprintf(log_buffer,"caught signal %d", 
      sig);
 
    log_record(PBSEVENT_SYSTEM,0,id,log_buffer);
    }
  else
    {
    log_record(PBSEVENT_SYSTEM,0,id,"abnormal termination");
    }
		
  cleanup();

  log_close(1);

  exit(1);
  }  /* END die() */




/*
**	Check for fatal memory allocation error.
*/

void memcheck(

  char *buf)

  {
  if (buf != NULL)
    {
    return;
    }

  log_err(-1,"memcheck","memory allocation failed");

  die(0);

  return;
  }  /* END memcheck() */





/*
**	Check the ret_string buffer to make sure that there is
**	enought room starting at *spot to hold len characters more.
**	If not, realloc the buffer and make *spot point to
**	the corresponding place that it used to point to in
**	the old buffer.
*/

void checkret(

  char **spot,
  int    len)

  {
  char *id = "checkret";
  char *hold;

  if ((*spot - ret_string) < (ret_size - len))
    {
    return;
    }

  ret_size += len*2;				/* new buf size */

  sprintf(log_buffer,"size increased to %d", 
    ret_size);

  log_record(PBSEVENT_SYSTEM,0,id,log_buffer);

  hold = realloc(ret_string,ret_size);		/* new buf */

  memcheck(hold);

  *spot = *spot - ret_string + hold;		/* new spot in buf */

  ret_string = hold;

  return;
  }  /* END checkret() */





char *skipwhite(

  char *str)

  {
  for (;*str;str++) 
    {
    if (!isspace(*str))
      break;
    }

  return(str);
  }





char *tokcpy(

  char *str,
  char *tok)

  {
  for (;*str;str++,tok++) 
    {
    if (!isalnum(*str) && *str != ':' && *str != '_')
      break;

    *tok = *str;
    }  /* END tokcpy() */

  *tok = '\0';

  return(str);
  }  /* END tokcpy() */




void rmnl(

  char *str)

  {
  int i;

  i = strlen(str);

  while (--i) 
    {
    if ((*(str + i) != '\n') && !isspace((int)*(str + i))) 
      break;

    *(str+i) = '\0';
    }

  return;
  }





u_long addclient(

  char *name)  /* I */

  {
  static char	  id[] = "addclient";
  struct hostent *host, *gethostbyname();
  struct in_addr  saddr;
  u_long	  ipaddr;

  if ((host = gethostbyname(name)) == NULL) 
    {
    sprintf(log_buffer,"host %s not found", 
      name);

    log_err(-1,id,log_buffer);

    return(0);
    }

  memcpy((char *)&saddr,host->h_addr,host->h_length);

  ipaddr = ntohl(saddr.s_addr);

  tinsert(ipaddr,&okclients);

  return(ipaddr);
  }  /* END addclient() */





static u_long setserver(

  char *value)  /* I */
  
  {
  int index;
  int rc;

  if ((value == NULL) || (value[0] == '\0'))
    {
    /* FAILURE */

    return(1);
    }

  for (index = 0;index < PBS_MAXSERVER;index++)
    {
    if (!strcmp(pbs_servername[index],value))
      {
      /* servername already added */

      /* IGNORE DUPLICATE REQUEST */

      return(0);
      }

    if (pbs_servername[index][0] == '\0')
      break;
    }  /* END for (index) */

  if (index >= PBS_MAXSERVER)
    {
    /* buffer is full */

    /* FAILURE */

    return(1);
    }

  strncpy(pbs_servername[index],value,PBS_MAXHOSTNAME);

  rc = addclient(pbs_servername[index]);

  return(rc);
  }  /* END setserver() */






static u_long setlogevent(

  char *value)

  {
  char *bad;

  *log_event_mask = strtol(value,&bad,0);

  if ((*bad == '\0') || isspace((int)*bad))
    {
    return(1);
    }

  return(0);
  }  /* END setlogevent() */




static	u_long restricted(

  char *name)

  {
  static char id[] = "restricted";

  log_record(PBSEVENT_SYSTEM, PBS_EVENTCLASS_SERVER, id, name);

  if (mask_max == 0) 
    {
    maskclient = (char **)calloc(4, sizeof(char *));

    mask_max = 4;
    }

  maskclient[mask_num++] = strdup(name);

  if (mask_num == mask_max) 
    {
    mask_max *= 2;

    maskclient = (char **)realloc(
      maskclient,
      mask_max * sizeof(char *));
    }

  return(1);
  }  /* END restricted */





static u_long configversion(

  char *Value)  /* I */

  {
  static char   id[] = "configversion";

  log_record(PBSEVENT_SYSTEM,PBS_EVENTCLASS_SERVER,id,Value);

  if (Value == NULL)
    {
    /* FAILURE */

    return(0);
    }

  strncpy(MOMConfigVersion,Value,sizeof(MOMConfigVersion));

  /* SUCCESS */

  return(1);
  }  /* END configversion() */





static u_long setdownonerror(

  char *Value)  /* I */

  {
  static char   id[] = "setdownonerror";
  int           enable = 0;

  log_record(PBSEVENT_SYSTEM,PBS_EVENTCLASS_SERVER,id,Value);

  if (Value == NULL)
    {
    /* FAILURE */

    return(0);
    }

  /* accept various forms of "true", "yes", and "1" */
  switch (Value[0])
    {
    case 't':
    case 'T':
    case 'y':
    case 'Y':
    case '1':

      enable = 1;
    
      break;
    }

  if (enable)
    {
    MOMConfigDownOnError=1;
    }

  return(1);
  }  /* END setdownonerror() */




static u_long cputmult(

  char *value)  /* I */

  {
  static char id[] = "cputmult";

  log_record(PBSEVENT_SYSTEM,PBS_EVENTCLASS_SERVER,id,value);

  if ((cputfactor = atof(value)) == 0.0)
    {
    return(0);	/* error */
    }

  return(1);
  }  /* END cputmult() */





static u_long wallmult(

  char *value)

  {
  static char	id[] = "wallmult";

  double tmpD;

  if (value == NULL)
    {
    /* FAILURE */

    return(0);
    }

  log_record(PBSEVENT_SYSTEM,PBS_EVENTCLASS_SERVER,id,value);

  tmpD = atof(value);

  if ((tmpD == 0.0) && (value[0] != '\0'))
    {
    /* FAILURE */

    return(0);	
    }

  /* SUCCESS */

  wallfactor = tmpD;

  return(1);
  }  /* END wallmult() */




static u_long usecp(

  char *value)  /* I */

  {
  char *pnxt;
  static int   cphosts_max = 0;

  static char *id = "usecp";

  /* FORMAT:  <HOST>:<FROM> <TO> */

  /*
   * HvB and Willem added this for logging purpose
   */

  log_record(
    PBSEVENT_SYSTEM, 
    PBS_EVENTCLASS_SERVER, 
    id, 
    value);

  if (cphosts_max == 0) 
    {
    pcphosts = malloc(2 * sizeof(struct cphosts));

    cphosts_max = 2;
    } 
  else if (cphosts_max == cphosts_num) 
    {
    pcphosts = realloc(
      pcphosts,
      (cphosts_max + 2) * sizeof(struct cphosts));

   cphosts_max += 2;
   }

  pnxt = strchr(value,(int)':');

  if (pnxt == NULL) 
    {
    /* request failed */

    sprintf(log_buffer,"invalid host specification: %s", 
      value);

    log_err(-1,id,log_buffer);

    return(0);
    }

  *pnxt++ = '\0';

  (pcphosts + cphosts_num)->cph_hosts = strdup(value);

  value = pnxt;	/* now ptr to path */

  while (!isspace(*pnxt))
    pnxt++;

  *pnxt++ = '\0';

  (pcphosts + cphosts_num)->cph_from = strdup(value);

  (pcphosts + cphosts_num)->cph_to   = strdup(skipwhite(pnxt));
	
  cphosts_num++;
	
  return(1);
  }  /* END usecp() */




static unsigned long prologalarm(

  char *value)  /* I */

  {
  int i;

  log_record(
    PBSEVENT_SYSTEM, 
    PBS_EVENTCLASS_SERVER,
    "prolog_alarm",
    value);

  i = (int)atoi(value);

  if (i <= 0) 
    {
    return(0);	/* error */
    }

  pe_alarm_time = (unsigned int)i;

  return(1);
  }  /* END prologalarm() */





static unsigned long setloglevel(

  char *value)  /* I */

  {
  int i;

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "setloglevel",
    value);

  i = (int)atoi(value);

  if (i < 0)
    {
    return(0);  /* error */
    }

  LOGLEVEL = (unsigned int)i;

  return(1);
  }  /* END setloglevel() */




static unsigned long jobstartblocktime(

  char *value)  /* I */

  {
  int i;

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "startblocktime",
    value);

  i = (int)strtol(value,NULL,10);

  if ((i < 0) || ((i == 0) && (value[0] != '0')))
    {
    return(0);  /* error */
    }

  TJobStartBlockTime = (unsigned int)i;

  return(1);
  }  /* END jobstartblocktime() */

static unsigned long setstatusupdatetime(

  char *value)  /* I */

  {
  int i;

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "setstateuspdatetime",
    value);

  i = (int)strtol(value,NULL,10);

  if (i < 1)
    {
    return(0);  /* error */
    }

  ServerStatUpdateInterval = (unsigned int)i;

  return(1);
  }  /* END setstatusupdatetime() */

static unsigned long setcheckpolltime(

  char *value)  /* I */

  {
  int i;

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "setcheckpolltime",
    value);

  i = (int)strtol(value,NULL,10);

  if (i < 1)
    {
    return(0);  /* error */
    }

  CheckPollTime = (unsigned int)i;

  return(1);
  }  /* END setcheckpolltime() */

/*
**	Add static resource or shell escape line from config file.
**	This is a support routine for read_config().
*/

static void add_static(

  char *str,     /* I */
  char *file,    /* I */
  int   linenum)

  {
  int	 i;
  char	 name[50];
  struct config_list *cp;

  str = tokcpy(str,name); /* resource name */
  str = skipwhite(str);	  /* resource value */

  if (*str == '!')	/* shell escape command */
    {
    rmnl(str);
    }
  else 
    {			/* get the value */
    i = strlen(str);

    while (--i) 
      {	
      /* strip trailing blanks */

      if (!isspace((int)*(str+i)))
        break;

      *(str + i) = '\0';
      }
    }

  cp = (struct config_list *)malloc(sizeof(struct config_list));

  memcheck((char *)cp);

  cp->c_link = config_list;
  cp->c.c_name = strdup(name);

  memcheck(cp->c.c_name);

  cp->c.c_u.c_value = strdup(str);

  memcheck(cp->c.c_u.c_value);

  sprintf(log_buffer,"%s[%d] add name %s value %s",
    file, 
    linenum, 
    name, 
    str);

  log_record(
    PBSEVENT_DEBUG,
    0,
    "add_static",
    log_buffer);

  config_list = cp;

  return;
  }  /* END add_static() */





static unsigned long setidealload(

  char *value)

  {
  char	 newstr[50] = "ideal_load ";
  float	 val;

  val = atof(value);

  log_record(
    PBSEVENT_SYSTEM, 
    PBS_EVENTCLASS_SERVER,
    "ideal_load",
    value);

  if (val < 0.0)
    {
    return(0);	/* error */
    }

  ideal_load_val = val;

  if (max_load_val < 0.0)
    max_load_val = val;	/* set a default */

  strcat(newstr,value);

  add_static(newstr,"config",0);

  nconfig++;

  return(1);
  }  /* END setidealload() */





static unsigned long setnodecheckscript(

  char *value)

  {
  char   newstr[1024] = "node_check_script ";

  struct stat sbuf;

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "node_check_script",
    value);

  if ((stat(value,&sbuf) == -1) || !(sbuf.st_mode & S_IXUSR))
    {
    /* file does not exist or is not executable */

    return(0);  /* error */
    }

  strncpy(PBSNodeCheckPath,value,sizeof(PBSNodeCheckPath));

  strcat(newstr,value);

  add_static(newstr,"config",0);

  nconfig++;

  return(1);
  }  /* END setnodecheckscript() */





static unsigned long setnodecheckinterval(

  char *value)

  {
  char newstr[1024] = "node_check_interval ";

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "node_check_interval",
    value);

  PBSNodeCheckInterval = (int)strtol(value,NULL,10);

  strcat(newstr,value);

  add_static(newstr,"config",0);

  nconfig++;

  return(1);
  }  /* END setnodecheckinterval() */





static unsigned long settimeout(

  char *value)

  {
  char newstr[1024];

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "timeout",
    value);

  DIS_tcp_settimeout(strtol(value,NULL,10));

  snprintf(newstr,sizeof(newstr),"%s %s",
    "timeout",
    value);

  add_static(newstr,"config",0);

  nconfig++;

  return(1);
  }  /* END settimeout() */





static unsigned long setmaxload(

  char *value)  /* I */

  {
  char	 newstr[50] = "max_load ";
  float	 val;

  val = atof(value);

  log_record(PBSEVENT_SYSTEM,PBS_EVENTCLASS_SERVER,"max_load",value);

  if (val < 0.0)
    {
    return(0);	/* error */
    }

  max_load_val = val;

  if (ideal_load_val < 0.0)
    ideal_load_val = val;

  strcat(newstr,value);

  add_static(newstr,"config",0);

  nconfig++;

  return(1);
  }  /* END max_load() */





static unsigned long setcheckpointscript(

  char *value)  /* I */

  {
  struct stat sbuf;

  log_record(
    PBSEVENT_SYSTEM,
    PBS_EVENTCLASS_SERVER,
    "checkpoint_script",
    value);

  if ((stat(value,&sbuf) == -1) || !(sbuf.st_mode & S_IXUSR))
    {
    /* file does not exist or is not executable */

    return(0);  /* error */
    }

  strncpy(CHECKPOINT_SCRIPT,value,sizeof(CHECKPOINT_SCRIPT));

  return(1);
  }  /* END setcheckpointscript() */





/*
**	Open and read the config file.  Save information in a linked
**	list.  After reading the file, create an array, copy the list
**	elements to the array and free the list.
*/

int read_config(

  char *file)  /* I */

  {
  static char id[] = "read_config";

  static struct specials {
    char            *name;
    u_long          (*handler)();
    } special[] = {
      { "clienthost",   setserver },
      { "configversion",configversion },
      { "cputmult",     cputmult },
      { "headnode",     setserver },
      { "ideal_load",   setidealload },
      { "logevent",     setlogevent },
      { "loglevel",     setloglevel },
      { "max_load",     setmaxload },
      { "prologalarm",  prologalarm },
      { "restricted",   restricted },
      { "jobstartblocktime", jobstartblocktime },
      { "usecp",        usecp },
      { "wallmult",     wallmult },
      { "pbsserver",    setserver },
      { "node_check_script", setnodecheckscript },
      { "node_check_interval", setnodecheckinterval },
      { "timeout",      settimeout },
      { "checkpoint_script", setcheckpointscript },
      { "down_on_error", setdownonerror },
      { "status_update_time", setstatusupdatetime },
      { "check_poll_time", setcheckpolltime },
      { NULL,           NULL } };

  FILE	                *conf;
  struct stat            sb;
  struct config_list	*cp;
  struct config		*ap;
  char                   line[120];
  char                   name[50];
  char                  *str;
  char                  *ptr;

  int                    linenum;
  int                    i;

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer,"updating configuration using file '%s'",
      (file != NULL) ? file : "NULL");

    log_record(
      PBSEVENT_SYSTEM,
      PBS_EVENTCLASS_SERVER,
      id,
      log_buffer);
    }

  for (i = 0;i < mask_num;i++)
    {
    free(maskclient[i]);
    }

  mask_num = 0;

  if (file == NULL)
    file = config_file;

  if (file[0] == '\0')
    {
    log_record(
      PBSEVENT_SYSTEM,
      PBS_EVENTCLASS_SERVER,
      id,
      "ALERT:  no config file specified");

    return(0);	/* no config file */
    }

  if (stat(file,&sb) == -1) 
    {
    sprintf(log_buffer,"fstat: %s", 
      file);

    log_err(errno,id,log_buffer);

    if (config_file_specified)
      {
      /* file specified and not there, return failure */

      log_record(
        PBSEVENT_SYSTEM,
        PBS_EVENTCLASS_SERVER,
        id,
        "ALERT:  cannot open config file - no file");

      return(1); 
      }

    /* "config" file not located, return success */

    if (LOGLEVEL >= 3)
      {
      sprintf(log_buffer,"cannot open file '%s'",
        file);

      log_record(
        PBSEVENT_SYSTEM,
        PBS_EVENTCLASS_SERVER,
        id,
        log_buffer);
      }

    return(0); 
    }

#if !defined(DEBUG) && !defined(NO_SECURITY_CHECK)

  if (chk_file_sec(file,0,0,S_IWGRP|S_IWOTH,1))
    {
    /* not authorized to access specified file, return failure */

    log_record(
      PBSEVENT_SYSTEM,
      PBS_EVENTCLASS_SERVER,
      id,
      "ALERT:  cannot open config file - permissions");

    return(1);
    }

#endif	/* NO_SECURITY_CHECK */

  if ((conf = fopen(file,"r")) == NULL) 
    {
    sprintf(log_buffer,"fopen: %s",
      file);

    log_err(errno,id,log_buffer);

    return(1);
    }

  nconfig = 0;
  linenum = 0;

  while (fgets(line,sizeof(line),conf)) 
    {
    linenum++;

    if (line[0] == '#')	/* comment */
      continue;

    if ((ptr = strchr(line,'#')) != NULL)
      {
      /* allow inline comments */

      *ptr = '\0';
      }
 
    str = skipwhite(line);	/* pass over initial whitespace */

    if (*str == '\0')
      continue;

    if (LOGLEVEL >= 6)
      {
      sprintf(log_buffer,"processing config line '%.64s'",
        str);

      log_record(
        PBSEVENT_SYSTEM,
        PBS_EVENTCLASS_SERVER,
        id,
        log_buffer);
      }

    if (*str == '$') 
      {	
      /* special command */

      str = tokcpy(++str,name); /* resource name */

      for (i = 0;special[i].name;i++) 
        {
        if (strcasecmp(name,special[i].name) == 0)
          break;
        }  /* END for (i) */

      if (special[i].name == NULL) 
        {
	/* didn't find it */

        sprintf(log_buffer,"special command name %s not found (ignoring line)",
          name);

        log_err(-1,id,log_buffer);

        continue;
        }

      str = skipwhite(str);		/* command param */

      rmnl(str);

      if (special[i].handler(str) == 0) 
        {
        sprintf(log_buffer,"%s[%d] special command %s failed with %s",
          file,
          linenum,
          name,
          str);

        log_err(-1,id,log_buffer);
        }

      continue;
      }

    add_static(str,file,linenum);

    nconfig++;
    }  /* END while (fgets()) */
		
  /*
  **	Create a new array.
  */

  if (config_array != NULL) 
    {
    for (ap = config_array;ap->c_name != NULL;ap++) 
      {
      free(ap->c_name);
      free(ap->c_u.c_value);
      }

    free(config_array);
    }

  config_array = (struct config *)calloc(nconfig + 1,sizeof(struct config));

  memcheck((char *)config_array);

  /*
  **	Copy in the new information saved from the file.
  */

  for (i = 0,ap = config_array;i < nconfig;i++,ap++) 
    {
    *ap = config_list->c;
    cp = config_list->c_link;

    free(config_list);	/* don't free name and value strings */
    config_list = cp;	/* they carry over from the list */
    }

  ap->c_name = NULL;		/* one extra */

  fclose(conf);

  return(0);
  }  /* END read_config() */






/*
**	Get an rm_attribute structure from a string.  If a NULL is passed
**	for the string, use the previously remembered string.
*/

struct rm_attribute *momgetattr(

  char *str) /* I */

  {
  char *id = "momgetattr";

  static char	cookie[] = "tag:";	/* rm_attribute to ignore */
  static char	*hold = NULL;
  static char	qual[80] = "";
  static char	valu[4096] = "";
  static struct	rm_attribute	attr = {qual, valu};
  int	        level, i;

  if (str == NULL)	/* if NULL is passed, use prev value */
    str = hold;

  /* FORMAT: ??? */

  do 
    {
    str = skipwhite(str);

    if (*str++ != '[')
      {
      return(NULL);
      }
		
    str = skipwhite(str);		/* copy qualifier */
    str = tokcpy(str,qual);
    str = skipwhite(str);
		
    if (*str++ != '=')
      {
      return(NULL);
      }
		
    level = 0;

    for (i = 0;*str;str++,i++) 
      {
      if (*str == '[')
        {
        level++;
        }
      else if (*str == ']') 
        {
        if (level == 0)
          break;
  
        level--;
        }

      valu[i] = *str;
      }

    if (*str++ != ']')
      {
      return(NULL);
      }
		
    valu[i] = '\0';

    if (LOGLEVEL >= 7)
      {
      sprintf(log_buffer,"found %s = %s\n",
        qual,
        valu);

      log_record(
        PBSEVENT_JOB,
        PBS_EVENTCLASS_JOB,
        id,
        log_buffer);
      }
    } while (strncmp(qual,cookie,sizeof(cookie)-1) == 0);

  hold = str;

  if (LOGLEVEL >= 5)
    {
    sprintf(log_buffer,"passing back %s = %s\n",
      qual,
      valu);

    log_record(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      id,
      log_buffer);
    }

  return(&attr);
  }  /* END momgetattr() */





/*
**	Check the request against the format of the line read from
**	the config file.  If it is a static value, there should be
**	no params.  If it is a shell escape, the parameters (if any)
**	should match the command line for the system call.
*/

char *conf_res(

  char	              *s,
  struct rm_attribute *attr)

  {
  char	*id = "conf_res";
  char	*name[RM_NPARM];
  char	*value[RM_NPARM];
  int	used[RM_NPARM];  /* (boolean) */
  char	param[80], *d;
  int	i, fd, len;
  FILE	*child;
  char	*child_spot;
  int	child_len;

  if (*s != '!') 
    {	
    /* static value */

    if (attr != NULL) 
      {
      sprintf(ret_string,"? %d", 
        RM_ERR_BADPARAM);

      return(ret_string);
      }

    return(s);
    }

  /*
  **	From here on we are going to put together a shell command
  **	to do the requestor's bidding.  Parameter substitution
  **	is the first step.
  */

  for (i = 0;i < RM_NPARM;i++) 
    {	
    /* remember params */

    if (attr == NULL)
      break;

    name[i] = strdup(attr->a_qualifier);

    memcheck(name[i]);
    
    value[i] = strdup(attr->a_value);

    memcheck(value[i]);

    used[i] = 0;

    attr = momgetattr(NULL);
    }  /* END for (i) */

  if (attr) 
    {			/* too many params */
    log_err(-1,id,"too many params");

    sprintf(ret_string,"? %d",
      RM_ERR_BADPARAM);

    goto done;
    }

  name[i] = NULL;

  for (d = ret_string,s++;*s;) 
    {
    /* scan command */

    if (*s == '%') 
      {	
      /* possible token */

      char *hold;

      hold = tokcpy(s + 1,param);

      for (i = 0;name[i];i++) 
        {
        if (strcmp(param, name[i]) == 0)
          break;
        }

      if (name[i]) 
        {	/* found a match */
        char	*x = value[i];

        while (*x)
          {
          *d++ = *x++;
          }

        s = hold;

        used[i] = 1;
        }
      else
        {
        *d++ = *s++;
        }
      }
    else
      {
      *d++ = *s++;
      }
    }

  for (i = 0;name[i];i++) 
    {
    if (!used[i]) 
      {		/* parameter sent but not used */
      log_err(-1,id,
        "unused parameters");

      sprintf(ret_string,"? %d", 
        RM_ERR_BADPARAM);

      goto done;
      }
    }    /* END for (i) */
			
  *d = '\0';

  DBPRT(("command: %s\n",
    ret_string))

  if ((child = popen(ret_string,"r")) == NULL) 
    {
    log_err(errno,id,"popen");

    sprintf(ret_string,"? %d", 
      RM_ERR_SYSTEM);
 
    goto done;
    }

  fd = fileno(child);

  child_spot = ret_string;
  child_len = 0;
  child_spot[0] = '\0';

  while ((len = read(fd,child_spot,ret_size - child_len)) > 0) 
    {
    for (i = 0;i < len;i++) 
      {
      if (child_spot[i] == '\n')
        break;
      }

    if (i < len) 
      {		
      /* found newline */

      child_len += i + 1;

      break;
      }

    child_len += len;
    child_spot += len;

    checkret(&child_spot,len);
    }

  if (len == -1) 
    {
    log_err(errno,id,"pipe read");

    sprintf(ret_string,"? %d", 
      RM_ERR_SYSTEM);

    fclose(child);

    goto done;
    }

  pclose(child);

  if (child_len > 0)
    ret_string[child_len - 1] = '\0';	/* hack off newline */

done:

  for (i = 0;name[i] != NULL;i++) 
    {		/* free up params */
    free(name[i]);
    free(value[i]);
    }  /* END for (i) */

  return(ret_string);
  }  /* END conf_res() */




static void catch_abort(

  int sig)

  {
  struct rlimit rlimit;

  /*
   * Reset ourselves to the default signal handler to try and
   * prevent recursive core dumps.
   */

  struct sigaction act;

  sigemptyset(&act.sa_mask);
  act.sa_flags   = 0;
  act.sa_handler = SIG_DFL;

  sigaction(SIGSEGV,&act,NULL);
  sigaction(SIGBUS, &act,NULL);
  sigaction(SIGFPE, &act,NULL);
  sigaction(SIGILL, &act,NULL);
  sigaction(SIGTRAP,&act,NULL);
  sigaction(SIGSYS, &act,NULL);

  log_err (sig,"mom_main","Caught fatal core signal");
  rlimit.rlim_cur = RLIM_INFINITY;
  rlimit.rlim_max = RLIM_INFINITY;

  setrlimit(RLIMIT_CORE,&rlimit);
  abort();

  return;
  }  /* END catch_abort() */




static void catch_hup(

  int sig)

  {
  sprintf(log_buffer,"caught signal %d", 
    sig);

  log_record(PBSEVENT_SYSTEM,0,"catch_hup","reset");

  call_hup = 1;

  rpp_dbprt = 1 - rpp_dbprt;	/* toggle debug prints for RPP */

  return;
  }  /* END catch_hup() */




/*
**	Do a restart of resmom.
**	Read the last seen config file and 
**	Clean up and reinit the dependent code.
*/

static void process_hup()

  {
  char	*id = "process_hup";

  call_hup = 0;
  log_record(PBSEVENT_SYSTEM,0,id,"reset");

  log_close(1);
  log_open(log_file,path_log);

  read_config(NULL);
  cleanup();

  initialize();
  
  return;
  }  /* END process_hup() */




/*
**	Got an alarm call.
**	Close all general network connections, clean up and reinit the
**	dependent code.
*/

void toolong(

  int sig)

  {
  char *id = "toolong";

  log_record(PBSEVENT_SYSTEM,0,id,"alarm call");

  if (LOGLEVEL >= 1)
    DBPRT(("alarm call\n"))

  return;
  }  /* END toolong() */







#ifdef	DEBUG

void log_verbose(

  char	*id,
  char	*buf,
  int	 len)

  {
  int	i;
  char	*cp;

  len = MIN(len, 50);

  cp = log_buffer;

  for (i = 0;i < len;i++) 
    {
    int c = buf[i];

    if (isprint(c))
      {
      *cp++ = c;
      }
    else 
      {
      sprintf(cp,"(%d)", 
        c);

      cp += strlen(cp);
      }
    }

  *cp = '\0';

  log_record(PBSEVENT_DEBUG,0,id,log_buffer);

  return;
  }  /* END log_verbose() */


#else
#define	log_verbose(a, b, c)
#endif

/*
**	See if an IP address matches any names stored as "restricted"
**	access hosts.  Return 0 if a name matches, 1 if not.
*/

int bad_restrict(

  u_long ipadd)

  {
  struct hostent *host, *gethostbyaddr();
  struct in_addr in;
  int	i, len1, len2;
  char	*cp1, *cp2;

  in.s_addr = htonl(ipadd);

  if ((host = gethostbyaddr(
        (void *)&in,
        sizeof(struct in_addr), 
        AF_INET)) == NULL)
    {
    return(1);
    }

  len1 = strlen(host->h_name) - 1;

  for (i = 0;i < mask_num;i++) 
    {
    len2 = strlen(maskclient[i]) - 1;

    if (len1 < len2)
      continue;

    cp1 = &host->h_name[len1];
    cp2 = &maskclient[i][len2];

    /* check case insensitve */

    while ((len2 >= 0) && (tolower(*cp1) == tolower(*cp2))) 
      {
      cp1--;
      cp2--;

      len2--;
      }  /* END while () */

    if (((len2 == 0) && (*cp2 == '*')) || (len2 == -1))
      {
      return(0);
      }
    }    /* END for (i) */

  return(1);
  }  /* END bad_restrict() */




/* init_server_stream() - open a connection to pbs_server */

int init_server_stream(void)

  {
  static char id[] = "init_server_stream";
  int ServerIndex = 0;

  if (LOGLEVEL >= 5)
    {
    sprintf(log_buffer,"%s: trying to open %s port %d",
      id,
      pbs_servername[ServerIndex],
      default_server_port);

    log_record(PBSEVENT_SYSTEM,0,id,log_buffer);
    }

  if ((server_stream = rpp_open(
         pbs_servername[ServerIndex],
         default_server_port,
         MOMSendStatFailure)) < 0)
    {
    if (LOGLEVEL >= 6)
      {
      sprintf(log_buffer,"%s: cannot open rpp connection, rc=%d",
        id,
        server_stream);

      log_record(PBSEVENT_SYSTEM,0,id,log_buffer);
      }

    server_stream = -1;

    return(DIS_EOF);
    }

  if (addclient(pbs_servername[ServerIndex]) == 0)                                       
    {
    rpp_close(server_stream);
    server_stream = -1;

    return(DIS_EOF);
    } 

  if (LOGLEVEL >= 3)
    {
    sprintf(log_buffer,"%s: added connection to %s",
      id,
      pbs_servername[ServerIndex]);

    log_record(PBSEVENT_SYSTEM,0,id,log_buffer);                                         
    }

  return(DIS_SUCCESS);
  }  /* END init_server_stream() */





/*
 **   is_update_stat
 **   This should update the PBS server with the status information
 **   that the resource manager should need.  This should allow for
 **   less trouble on the part of the resource manager.  It can get
 **   this information from the server rather than going to each mom.
 */

int is_update_stat(

  int ServerIndex) /* I */

  {
  static char id[] = "is_update_stat";

  static char *stats[] = {
    "arch", 
    "opsys",
    "uname", 
    "sessions", 
    "nsessions", 
    "nusers",
    "idletime", 
    "totmem", 
    "availmem", 
    "physmem", 
    "ncpus", 
    "loadave",
    "message",
    "gres",
    "netload",
    "size",
    "state",
    NULL };

  char   cp[1024];
  char   name[100];
  char   buff[32768];
  char  *curr, *value;
  struct config  *ap;
  struct rm_attribute *attr;
  int    restrictrm = 0;
  int    i;
  int    ret;
  void   (*close_io)A_((int));
  int    (*flush_io)A_((int));

  char  *ptr;

  time(&MOMLastSendToServerTime);

  if (ServerIndex != 0)
    {
    /* NOTE:  attempt to support multiple servers per MOM */

    /* NO-OP */
    }

  close_io = (void(*) A_((int)))rpp_close;
  flush_io = rpp_flush;

  if (LOGLEVEL >= 6)
    {
    log_record(PBSEVENT_SYSTEM,0,id,"composing status update for server");
    }

  DIS_rpp_reset();

  ret = diswsi(server_stream,IS_PROTOCOL);

  if (ret != DIS_SUCCESS)
    {
    log_err(ret,id,"cannot specify protocol");

    goto isdone;
    }

  ret = diswsi(server_stream,IS_PROTOCOL_VER);

  if (ret != DIS_SUCCESS)
    {
    log_err(ret,id,"cannot specify protocol version");

    goto isdone;
    }

  ret = diswsi(server_stream,IS_STATUS);

  if (ret != DIS_SUCCESS)
    {
    log_err(ret,id,"cannot specify command type");

    goto isdone;
    }

  for (i = 0;stats[i] != NULL;i++) 
    {
    /* FORMAT:  <ATTR> <VAL> */

    strcpy(cp,stats[i]);

    curr = skipwhite(cp);
    curr = tokcpy(curr,name);

    buff[0] = '\0';

    if (LOGLEVEL >= 8)
      log_record(PBSEVENT_SYSTEM,0,id,"clearing alarm in is_update_stat");

    alarm(0);

    if (strlen(name) == 0) 
      {             
      /* no name */

      sprintf(buff,"%s=? %d",
        cp, 
        RM_ERR_UNKNOWN);
      }
    else 
      {
      ap = rm_search(config_array,name);

      if (!strcmp(name,"size"))
        {
        if (ap == NULL)
          continue;

        /* only report size if specified in mom config */

        attr = momgetattr(ap->c_u.c_value);

        if (attr == NULL)
          continue;
        }
      else if (!strcmp(name,"arch"))
        {
        if (ap == NULL)
          continue;

        /* only report arch if specified in mom config */

        if (ap->c_u.c_value == NULL)
          continue;
        }
      else
        {
        attr = momgetattr(curr);
        }
 
      if (LOGLEVEL >= 7)
        log_record(PBSEVENT_SYSTEM,0,id,"setting alarm in is_update_stat");

      alarm(alarm_time);

      if ((!strcmp(name,"arch")) && (ap != NULL))
        {
        /* report arch */

        snprintf(buff,sizeof(buff),"%s=%s",
          name,
          ap->c_u.c_value);
        }
      else if ((!strcmp(name,"opsys")) && (ap != NULL))
        {
        /* report opsys */

        snprintf(buff,sizeof(buff),"%s=%s",
          name,
          ap->c_u.c_value);
        }
      else if ((ap != NULL) && 
               !restrictrm && 
                strcmp(name,"size"))
        {    
        /* static */

        ptr = conf_res(ap->c_u.c_value,attr);

        if ((ptr != NULL) && (ptr[0] != '\0'))
          {
          /* all static attributes are optional */

          continue;
          }

        snprintf(buff,sizeof(buff),"%s=%s",
          cp,
          ptr);
        }
      else 
        {      
        /* check dependent code */

        log_buffer[0] = '\0';

        value = dependent(name,attr);

        if (value != NULL)
          {
          if (value[0] == '\0')
            {
            /* value not set (attribute optional) */

            continue;
            }

          sprintf(buff,"%s=%s",
            cp,
            value);
          }
        else 
          {  
          /* value not set (attribute required) */

          sprintf(buff,"%s=? %d",
            cp,
            rm_errno);
          }
        }
      }      /* END else (strlen(name) == 0) */

    if (buff[0] == '\0')
      continue;

    if (LOGLEVEL >= 7)
      {
      sprintf(log_buffer,"%s: sending to server \"%s\"",
        id,
        buff);

      log_record(PBSEVENT_SYSTEM,0,id,log_buffer);
      }

    ret = diswst(server_stream, 
      buff);

    if (ret != DIS_SUCCESS) 
      {
      sprintf(log_buffer,"write string failed %s",
        dis_emsg[ret]);

      log_err(ret,id,log_buffer);

      goto isdone;
      }
    }    /* END for (i) */

  if (LOGLEVEL >= 8)
    log_record(PBSEVENT_SYSTEM,0,id,"clearing alarm in is_update_stat");

  alarm(0);

  if (flush_io(server_stream) == -1) 
    {
    log_err(errno,id,"flush");

    ret = -1;

    goto isdone;
    }

  if (LOGLEVEL >= 3)
    {
    log_record(PBSEVENT_SYSTEM,0,id,"status update successfully sent to server");
    }

  /* It would be redundant to send state since it is already in status */

  internal_state &= ~UPDATE_MOM_STATE;

  return(ret);

isdone:

  alarm(0);

  DBPRT(("%s: send error %s\n",
    id, 
    dis_emsg[ret]))

  return ret;
  }  /* END is_update_stat() */




/*
**	Process a request for the resource monitor.  The i/o
**	will take place using DIS over a tcp fd or an rpp stream.
*/

int rm_request(

  int	iochan,
  int	version,
  int	tcp)     /* I */

  {
  static char id[] = "rm_request";
  char	name[100];
  char	output[BUFSIZ << 2];
  int	len;
  int		command, ret;
  int		restrictrm = 0;
  char		*curr, *value, *cp, *body;
  struct	config		*ap;
  struct	rm_attribute	*attr;
  struct	sockaddr_in	*addr;
  unsigned long	ipadd;
  u_short	port;
  void		(*close_io)	A_((int));
  int		(*flush_io)	A_((int));
  extern struct	connection	svr_conn[];

  char *BPtr;
  int   BSpace;

  errno = 0;

  if (tcp) 
    {
    ipadd = svr_conn[iochan].cn_addr;
    port = svr_conn[iochan].cn_port;

    close_io = close_conn;
    flush_io = DIS_tcp_wflush;
    }
  else 
    {
    addr = rpp_getaddr(iochan);
    ipadd = ntohl(addr->sin_addr.s_addr);
    port = ntohs((unsigned short)addr->sin_port);

    close_io = (void(*) A_((int)) )rpp_close;
    flush_io = rpp_flush;
    }

  if (version != RM_PROTOCOL_VER) 
    {
    sprintf(log_buffer, "protocol version %d unknown", 
      version);
 
    goto bad;
    }

  if (((port_care != FALSE) && (port >= IPPORT_RESERVED)) ||
      !tfind(ipadd,&okclients)) 
    {
    if (bad_restrict(ipadd)) 
      {
      sprintf(log_buffer,"bad attempt to connect - unauthorized (port: %d)",
        port);

      goto bad;
      }

    restrictrm = 1;
    }

  /* looks okay, find out what command it is */

  command = disrsi(iochan,&ret);

  if (ret != DIS_SUCCESS) 
    {
    sprintf(log_buffer,"no command %s", 
      dis_emsg[ret]);

    goto bad;
    }

  switch (command) 
    {
    case RM_CMD_CLOSE:		/* no response to this */

      close_io(iochan);

      return(1);

      /*NOTREACHED*/

      break;

    case RM_CMD_REQUEST:

      /* query resource data */

      reqnum++;

      ret = diswsi(iochan,RM_RSP_OK);

      if (ret != DIS_SUCCESS) 
        {
        sprintf(log_buffer,"write request response failed: %s",
          dis_emsg[ret]);

        goto bad;
        }

      for (;;) 
        {
        cp = disrst(iochan,&ret);

        if (ret == DIS_EOD)
          {
          break;
          }

        if (ret != DIS_SUCCESS) 
          {
          sprintf(log_buffer,"problem with request line: %s",
            dis_emsg[ret]);

          goto bad;
          }

        curr = skipwhite(cp);
        curr = tokcpy(curr,name);

        if (name[0] == '\0') 
          {
          /* no name */

          sprintf(output,"%s=? %d",
            cp, 
            RM_ERR_UNKNOWN);
          }
        else 
          {
          if (!strcmp(name,"clearjob="))
            {
            char *ptr;

            job *pjob;

            ptr = name + strlen("clearjob=");

            /* purge job if local */

            if ((pjob = (job *)GET_NEXT(svr_alljobs)) != NULL)
              {
              char tmpLine[1024];

              for (;pjob != NULL;pjob = (job *)GET_NEXT(pjob->ji_alljobs))
                {
                if ((ptr != NULL) && 
                     strcasecmp(ptr,"all") && 
                     strcmp(ptr,pjob->ji_qs.ji_jobid))
                  continue;  

                sprintf(tmpLine,"clearing job %s",
                  pjob->ji_qs.ji_jobid);

                log_record(PBSEVENT_SYSTEM,0,id,tmpLine);

                job_purge(pjob);
                }
              }

            /* remove job from spool directory */

            if ((ptr != NULL) && 
                (ptr[0] != '\0') &&
                strcasecmp(ptr,"all"))
              {
              char tmpLine[1024];

              sprintf(tmpLine,"%s%s",
                path_jobs,
                ptr);

              errno = 0;

              remove(tmpLine);

              sprintf(log_buffer,"removed file '%s', errno=%d (%s)",
                tmpLine,
                errno,
                strerror(errno));

              log_record(PBSEVENT_SYSTEM,0,id,log_buffer);
              }

            strcpy(output,"clear completed");
            }
          else if (!strncasecmp(name,"clearmsg",strlen("clearmsg")))
            {
            /*  clear rm messages */

            PBSNodeMsgBuf[0] = '\0';

            strcpy(output,"messages cleared");

            log_record(PBSEVENT_SYSTEM,0,id,"messages cleared");
            }
          else if (!strncasecmp(name,"cycle",strlen("cycle")))
            {
            /*  force immediate cycle */

            LastServerUpdateTime = 0;

            strcpy(output,"cycle forced");

            log_record(PBSEVENT_SYSTEM,0,id,"reporting cycle forced");
            }
          else if (!strncasecmp(name,"status_update_time",strlen("status_update_time")))
            {
            /* set or report status_update_time */

            if ( (*curr == '=') && ((*curr)+1 != '\0' ))
              {
              setstatusupdatetime(curr+1);
              }

            sprintf(output,"status_update_time=%d",
              ServerStatUpdateInterval);
            }
          else if (!strncasecmp(name,"check_poll_time",strlen("check_poll_time")))
            {
            /* set or report check_poll_time */

            if ( (*curr == '=') && ((*curr)+1 != '\0' ))
              {
              setcheckpolltime(curr+1);
              }

            sprintf(output,"check_poll_time=%d",
              CheckPollTime);
            }
          else if (!strncasecmp(name,"jobstartblocktime",strlen("jobstartblocktime")))
            {
            /* set or report jobstartblocktime */

            if ( (*curr == '=') && ((*curr)+1 != '\0' ))
              {
              jobstartblocktime(curr+1);
              }

            sprintf(output,"jobstartblocktime=%d",
              TJobStartBlockTime);
            }
          else if (!strncasecmp(name,"loglevel",strlen("loglevel")))
            {
            /* set or report loglevel */

            if ( (*curr == '=') && ((*curr)+1 != '\0' ))
              {
              setloglevel(curr+1);
              }

            sprintf(output,"loglevel=%d",
              LOGLEVEL);
            }
          else if (!strncasecmp(name,"down_on_error",strlen("down_on_error")))
            {
            /* set or report loglevel */

            if ( (*curr == '=') && ((*curr)+1 != '\0' ))
              {
              setdownonerror(curr+1);
              }

            sprintf(output,"down_on_error=%d",
              LOGLEVEL);
            }
          else if (!strncasecmp(name,"diag",strlen("diag")))
            {
            char tmpLine[1024];

            int rc;

            int verbositylevel = 0;

            time_t Now;

            char *ptr;

            job *pjob;

            time(&Now);

            ptr = name + strlen("diag");

            verbositylevel = (int)strtol(ptr,NULL,10);

            output[0] = '\0';

            BPtr = output;
            BSpace = sizeof(output);

            sprintf(tmpLine,"\nHost: %s/%s   Server: %s   Version: %s\n",
              mom_short_name,
              mom_host,
              pbs_servername[0],  /* FIXME: how do we know index? */
              PBS_VERSION);

            MUStrNCat(&BPtr,&BSpace,tmpLine);

            if (LOGLEVEL >= 2)
              {
              sprintf(tmpLine,"PID:                    %ld\n",
                (long)getpid());

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            sprintf(tmpLine,"HomeDirectory:          %s\n",
              (mom_home != NULL) ? mom_home : "N/A");

            MUStrNCat(&BPtr,&BSpace,tmpLine);

            if (MOMConfigVersion[0] != '\0')
              {
              sprintf(tmpLine,"ConfigVersion:          %s\n",
                MOMConfigVersion);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            sprintf(tmpLine,"MOM active:             %ld seconds\n",
              (long)Now - MOMStartTime);

            MUStrNCat(&BPtr,&BSpace,tmpLine);

            if (MOMLastRecvFromServerTime > 0)
              {
              sprintf(tmpLine,"Last Msg From Server:   %ld seconds (%s)\n",
                (long)Now - MOMLastRecvFromServerTime,
                (MOMLastRecvFromServerCmd[0] != '\0') ?
                 MOMLastRecvFromServerCmd : "N/A");
              }
            else
              {
              sprintf(tmpLine,"WARNING:  no messages received from server\n");
              }                   
 
            MUStrNCat(&BPtr,&BSpace,tmpLine);

            if (MOMLastSendToServerTime > 0)
              {
              sprintf(tmpLine,"Last Msg To Server:     %ld seconds\n",
                (long)Now - MOMLastSendToServerTime);
              }
            else
              {
              sprintf(tmpLine,"WARNING:  no messages sent to server\n");
              }

            MUStrNCat(&BPtr,&BSpace,tmpLine);

            if (verbositylevel >= 1)
              {
              sprintf(tmpLine,"Server Update Interval: %d seconds\n",
                ServerStatUpdateInterval);
  
              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if (PBSNodeMsgBuf[0] != '\0')
              {
              sprintf(tmpLine,"MOM Message:            %s (use 'momctl -q clearmsg' to clear)\n",
                PBSNodeMsgBuf);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if ((MOMRecvHelloCount > 0) || (MOMRecvClusterAddrsCount > 0))
              {
              if (verbositylevel >= 1)
                {
                sprintf(tmpLine,"Init Msgs Received:     %d hellos/%d cluster-addrs\n",
                  MOMRecvHelloCount,
                  MOMRecvClusterAddrsCount);

                MUStrNCat(&BPtr,&BSpace,tmpLine);

                sprintf(tmpLine,"Init Msgs Sent:         %d hellos\n",
                  MOMSendHelloCount);

                MUStrNCat(&BPtr,&BSpace,tmpLine);
                }
              }
            else
              {
              sprintf(tmpLine,"WARNING:  no hello/cluster-addrs messages received from server\n");

              MUStrNCat(&BPtr,&BSpace,tmpLine);

              sprintf(tmpLine,"Init Msgs Sent:         %d hellos\n",
                MOMSendHelloCount);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if (MOMSendStatFailure[0] != '\0')
              {
              sprintf(tmpLine,"WARNING:  could not open connection to server, %s\n",
                MOMSendStatFailure);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if (MOMUNameMissing[0] != '\0')
              {
              sprintf(tmpLine,"WARNING:  passwd file is corrupt (job requests user '%s' - not found in local passwd file)\n",
                MOMUNameMissing);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            sprintf(tmpLine,"LOGLEVEL:               %d (use SIGUSR1/SIGUSR2 to adjust)\n",
              LOGLEVEL);

            MUStrNCat(&BPtr,&BSpace,tmpLine);

            if (verbositylevel >= 1)
              {
              sprintf(tmpLine,"Communication Model:    %s\n",
#if RPP
                "RPP");
#else  /* RPP */
                "TCP");
#endif /* RPP */

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if ((verbositylevel >= 1) && (pbs_tcp_timeout > 0))
              {
              sprintf(tmpLine,"TCP Timeout:            %d seconds\n",
                (int)pbs_tcp_timeout);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if (verbositylevel >= 1)
              {
              sprintf(tmpLine,"Prolog Alarm Time:      %d seconds\n",
                pe_alarm_time);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if (verbositylevel >= 2)
              {
              /* check alarm */

              rc = alarm(alarm_time);

              alarm(rc);

              sprintf(tmpLine,"Alarm Time:             %d of %d seconds\n",
                rc,
                alarm_time);

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }

            if (verbositylevel >= 1)
              {
              /* display okclient list */

              tmpLine[0] = '\0';

              tlist(okclients,tmpLine,sizeof(tmpLine));

              MUSNPrintF(&BPtr,&BSpace,"Trusted Client List:    %s\n",
                tmpLine);
              }

            /* joblist */

            if ((pjob = (job *)GET_NEXT(svr_alljobs)) == NULL)
              {
              sprintf(tmpLine,"JobList:                NONE\n");

              MUStrNCat(&BPtr,&BSpace,tmpLine);
              }
            else
              {
              for (;pjob != NULL;pjob = (job *)GET_NEXT(pjob->ji_alljobs))
                {
                if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING)
                  continue;

                sprintf(tmpLine,"Job[%s]  State=%s\n",
                  pjob->ji_qs.ji_jobid,
                  PJobSubState[pjob->ji_qs.ji_substate]);

                MUStrNCat(&BPtr,&BSpace,tmpLine);
                }
              }

            MUStrNCat(&BPtr,&BSpace,"\ndiagnostics complete\n");

            log_record(PBSEVENT_SYSTEM,0,id,"internal diagnostics complete");
            }
          else
            {
            ap = rm_search(config_array,name);

            attr = momgetattr(curr);

            if (LOGLEVEL >= 3)
              log_record(PBSEVENT_SYSTEM,0,id,"setting alarm in rm_request");

            alarm(alarm_time);

            if (ap && !restrictrm) 
              {	
              /* static */

              sprintf(output,"%s=%s",
                cp,
                conf_res(ap->c_u.c_value,attr));
              }
            else 
              {	
              /* check dependent code */

              log_buffer[0] = '\0';

              value = dependent(name,attr);

              if (value != NULL) 
                {
                sprintf(output,"%s=%s",
                  cp, 
                  value);
                }
              else 
                {	
                /* not found anywhere */

                sprintf(output,"%s=? %d",
                  cp, 
                  rm_errno);
                }
              }

            alarm(0);
            }
          }  /* END (name[0] == '\0') */

        free(cp);

        ret = diswst(iochan,output);

        if (ret != DIS_SUCCESS) 
          {
          sprintf(log_buffer,"write string failed %s",
            dis_emsg[ret]);

          goto bad;
          }
        }    /* END for () */

      break;

    case RM_CMD_CONFIG:

      {
      char *ptr;

      if (restrictrm) 
        {
        log_err(-1,id,"restricted configure attempt");

        goto bad;
        }

      log_record(PBSEVENT_SYSTEM,0,id,"configure");

      body = disrst(iochan,&ret);

      /* FORMAT:  FILE:<FILENAME> or <FILEDATA> (NYI) */

      if (ret == DIS_EOD)
        {
        /* no file specified, use default */

        body = NULL;
        }
      else if (ret != DIS_SUCCESS) 
        {
        sprintf(log_buffer,"problem with config body %s",
          dis_emsg[ret]);

        goto bad;
        }
      else
        {
        FILE *fp;

        if ((ptr = strstr(body,"CONFIG:")) != NULL)
          {
          ptr += strlen("CONFIG:");

          /* overwrite config with data and clear body */

          if ((fp = fopen(config_file,"w+")) == NULL)
            {
            printf(log_buffer,"cannot open config file %s",
              config_file);

            goto bad;
            }

          if (fwrite(ptr,1,strlen(ptr) + 1,fp) < 0)
            {
            fclose(fp);

            printf(log_buffer,"cannot write config file %s",
              config_file);

            goto bad;
            }

          fclose(fp);

          body = NULL;
          }
        }

      len = read_config(body);

      ret = diswsi(iochan,len ? RM_RSP_ERROR : RM_RSP_OK);

      if (ret != DIS_SUCCESS) 
        {
        sprintf(log_buffer,"write config response failed %s",
          dis_emsg[ret]);

        goto bad;
        }
      }    /* END (case RM_CMD_CONFIG) */

      break;

    case RM_CMD_SHUTDOWN:

      if (restrictrm) 
        {
        log_err(-1,id,"restricted shutdown attempt");

        goto bad;
        }

      log_record(PBSEVENT_SYSTEM,0,id,"shutdown");

      ret = diswsi(iochan,RM_RSP_OK);

      if (ret != DIS_SUCCESS) 
        {
        sprintf(log_buffer,"write shutdown response failed %s",
          dis_emsg[ret]);

        log_err(-1,id,log_buffer);
        }

      flush_io(iochan);

      close_io(iochan);

      cleanup();

      log_close(1);

      rpp_shutdown();

      exit(0);

      /*NOTREACHED*/

      break;

    default:

      sprintf(log_buffer,"unknown command %d",
        command);

      log_err(-1,id,log_buffer);

      ret = diswsi(iochan,RM_RSP_ERROR);

      if (ret != DIS_SUCCESS) 
        {
        sprintf(log_buffer,"write default response failed %s",
          dis_emsg[ret]);

        goto bad;
        }

      ret = diswst(iochan,log_buffer);

      if (ret != DIS_SUCCESS) 
        {
        sprintf(log_buffer,"write string failed %s",
          dis_emsg[ret]);

        goto bad;
        }

      break;
    }  /* END switch(command) */

  if (flush_io(iochan) == -1) 
    {
    log_err(errno,id,"flush");

    goto bad;
    }

  return 0;

bad:

  sprintf(output,"\n\tmessage refused from port %d addr %ld.%ld.%ld.%ld", 
    port,
    (ipadd & 0xff000000) >> 24,
    (ipadd & 0x00ff0000) >> 16,
    (ipadd & 0x0000ff00) >> 8,
    (ipadd & 0x000000ff));

  strcat(log_buffer,output);

  log_err(errno,id,log_buffer);

  close_io(iochan);

  return(-1);
  }  /* END rm_request() */





/*
** Read a RPP message from a stream, figure out if it is a
** Resource Monitor request or an InterMom message.
*/

void do_rpp(

  int stream)  /* I */

  {
  static char		id[] = "do_rpp";

  int			ret, proto, version;
  void	im_request	A_((int,int));
  void	is_request	A_((int,int,int *));
  void	im_eof		A_((int,int));

  DIS_rpp_reset();
  proto = disrsi(stream,&ret);

  if (ret != DIS_SUCCESS) 
    {
    DBPRT(("%s: cannot get protocol %s\n",
      id,
      dis_emsg[ret]))

    im_eof(stream,ret);

    return;
    }

  version = disrsi(stream,&ret);

  if (ret != DIS_SUCCESS) 
    {
    DBPRT(("%s: no protocol version number %s\n",
      id, 
      dis_emsg[ret]))

    im_eof(stream,ret);

    return;
    }

  switch (proto) 
    {
    case RM_PROTOCOL:

      DBPRT(("%s: got a resource monitor request\n", 
        id))

      if (rm_request(stream,version,0) == 0)
        rpp_eom(stream);

      break;

    case IM_PROTOCOL:

      if (LOGLEVEL >= 6)
        {
        log_record(
          PBSEVENT_JOB,
          PBS_EVENTCLASS_JOB,
          id,
          "got an internal task manager request in do_rpp");
        }

      im_request(stream,version);

      break;

    case IS_PROTOCOL:

      {
      int tmpI;

      if (LOGLEVEL >= 3)
        {
        log_record(
          PBSEVENT_JOB,
          PBS_EVENTCLASS_JOB,
          id,
          "got an inter-server request");
        }

      time(&MOMLastRecvFromServerTime);

      is_request(stream,version,&tmpI);

      strcpy(MOMLastRecvFromServerCmd,PBSServerCmds[tmpI]);
      }  /* END BLOCK */

      break;

    default:

      if (LOGLEVEL >= 1)
        {
        sprintf(log_buffer,"unexpected request protocol type %d received",
          proto);

        log_record(
          PBSEVENT_JOB,
          PBS_EVENTCLASS_JOB,
          id,
          "got an inter-server request");
        }

      rpp_close(stream);

      break;
    }  /* END switch (proto) */

  return;
  }  /* END do_rpp() */





void rpp_request(

  int fd)	/* not used */

  {
  static char id[] = "rpp_request";
  int         stream;

  for (;;) 
    {
    if ((stream = rpp_poll()) == -1) 
      {
      log_err(errno,id,"rpp_poll");

      break;
      }

    if (stream == -2)
      {
      /* unknown stream identifier */

      break;
      }

    do_rpp(stream);
    }  /* END for () */

  return;
  }  /* END rpp_request() */





int do_tcp(

  int fd)

  {
  static char id[] = "do_tcp";

  int ret, proto, version;
  int tm_request A_((int stream, int version));

  time_t tmpT;

  tmpT = pbs_tcp_timeout;

  pbs_tcp_timeout = 0;

  proto = disrsi(fd,&ret);

  if (tmpT > 0)
    {
    /* restore */

    pbs_tcp_timeout = tmpT;
    }
  else
    {
    /* initialize */

    pbs_tcp_timeout = PMOMTCPTIMEOUT;
    }

  switch (ret) 
    {
    case DIS_SUCCESS:		/* worked */

      break;

    case DIS_EOF:			/* closed */

      close_conn(fd);

      /* continue to next case */
 
    case DIS_EOD:			/* still open */

      return(1);

      /*NOTREACHED*/

      break;

    default:

      sprintf(log_buffer, "no protocol number: %s",
        dis_emsg[ret]);

      goto bad;

      /*NOTREACHED*/

      break;
    }  /* END switch (ret) */

  version = disrsi(fd, &ret);

  if (ret != DIS_SUCCESS) 
    {
    DBPRT(("%s: no protocol version number %s\n",
      id, dis_emsg[ret]))

    goto bad;
    }

  switch (proto) 
    {
    case RM_PROTOCOL:

      {
      time_t tmpT;

      DBPRT(("%s: got a resource monitor request\n", 
        id))

      tmpT = pbs_tcp_timeout;

      pbs_tcp_timeout = 0;

      ret = rm_request(fd,version,1);

      if (tmpT > 0)
        {
        /* restore */

        pbs_tcp_timeout = tmpT;
        }
      else
        {
        /* initialize */

        pbs_tcp_timeout = PMOMTCPTIMEOUT;
        }
      }    /* END BLOCK (case RM_PROTOCOL) */

      break;

    case TM_PROTOCOL:

      DBPRT(("%s: got an internal task manager request\n", 
        id))

      ret = tm_request(fd, version);

      break;

    default:

      DBPRT(("%s: unknown request %d\n", 
        id, 
        proto))

      goto bad;

      /*NOTREACHED*/

      break;
    }  /* END switch (proto) */

  return(ret);

bad:

  close_conn(fd);

  return(-1);
  }  /* END do_tcp() */





void tcp_request(

  int fd)

  {
  static	char id[] = "tcp_request";
  int		c;
  long		ipadd;
  char		address[80];
  extern struct	connection	svr_conn[];

  ipadd = svr_conn[fd].cn_addr;

  sprintf(address, "%ld.%ld.%ld.%ld:%d",
    (ipadd & 0xff000000) >> 24,
    (ipadd & 0x00ff0000) >> 16,
    (ipadd & 0x0000ff00) >> 8,
    (ipadd & 0x000000ff),
    ntohs(svr_conn[fd].cn_port));

  if (LOGLEVEL >= 6)
    {
    sprintf(log_buffer,"%s: fd %d addr %s\n",
      id,
      fd,
      address);

    log_record(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      "tcp_request",
      log_buffer);
    }

  DIS_tcp_setup(fd);

  if (!tfind(ipadd,&okclients)) 
    {
    sprintf(log_buffer,"bad connect from %s", 
      address);

    log_err(errno,id,log_buffer);

    close_conn(fd);

    return;
    }

  log_buffer[0] = '\0';

  for (c = 0;;c++) 
    {
    DIS_tcp_funcs();

    if (do_tcp(fd))
      break;
    }  /* END for (c = 0) */

  DBPRT(("%s: processed %d\n", 
    id, 
    c))

  return;
  }  /* END tcp_request() */





/*
 *	Kill a job.
 *	Call with the job pointer and a signal number.
 */

int kill_job(

  job *pjob,  /* I */
  int  sig)   /* I */

  {
  task	*ptask;
  int	ct = 0;

  const char *id = "kill_job";

  if (LOGLEVEL >= 2)
    {
    log_record(
      PBSEVENT_JOB, 
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid, 
      (char *)id);
    }

  /* NOTE:  should cahnge be made to only execute precancel epilog if job is active? (NYI) */

  /* NOTE:  epilog blocks until complete, which may cause issues if shutdown grace time is
            enabled.  Change model to allow epilog.precancel to run in background and have
            kill_task() executed once it is complete (NYI) */

  /* NOTE:  this will allow kill_job to return immediately and will require sigchild 
            harvesting and the kill_task loop to be called once this signal is received */

  /* NOTE:  if path_epilogpdel is not set, kill_task should be called immediately (NYI) */

  if (run_pelog(PE_EPILOGUSER,path_epilogpdel,pjob,PE_IO_TYPE_NULL) != 0)
    {
    log_err(-1,(char *)id,"precancel epilog failed");

    sprintf(PBSNodeMsgBuf,"ERROR:  precancel epilog failed");
    }

  ptask = (task *)GET_NEXT(pjob->ji_tasks);

  while (ptask != NULL) 
    {
    if (ptask->ti_qs.ti_status == TI_STATE_RUNNING) 
      {
      if (LOGLEVEL >= 4)
        {
        log_record(
          PBSEVENT_JOB, 
          PBS_EVENTCLASS_JOB,
          pjob->ji_qs.ji_jobid,
          "kill_job found a task to kill");
        }

      ct += kill_task(ptask,sig);
      }

    ptask = (task *)GET_NEXT(ptask->ti_jobtask);
    }  /* END while (ptask != NULL) */

  if (LOGLEVEL >= 6)
    {
    log_record(
      PBSEVENT_JOB,
      PBS_EVENTCLASS_JOB,
      pjob->ji_qs.ji_jobid, 
      "kill_job done");
    }

  return(ct);
  }  /* END kill_job() */





/*
 * finish_loop - the finish of MOM's main loop
 *	Actually the heart of the loop
 */

static void finish_loop(

  time_t waittime)  /* I (in seconds) */

  {
  static char id[] = "finish_loop";

  time_t tmpTime;
  time_t time_now;
  
  /* check for any extra rpp messages */

  rpp_request(42);

  if (termin_child)
    scan_for_terminated();

  /* if -p, must poll tasks inside jobs to look for completion */

  if (recover == 2)
    scan_non_child_tasks();

  if (exiting_tasks)
    scan_for_exiting();	

  TMOMScanForStarting();

  /* unblock signals */

  if (sigprocmask(SIG_UNBLOCK,&allsigs,NULL) == -1)
    log_err(errno,id,"sigprocmask(UNBLOCK)");

  time_now = time((time_t *)0);

  tmpTime = MIN(waittime,time_now - (LastServerUpdateTime + ServerStatUpdateInterval));

  tmpTime = MIN(tmpTime,time_now - (polltime + CheckPollTime));

  tmpTime = MAX(1,tmpTime);

  /* wait for a request to process */

  if (wait_request(tmpTime) != 0)
    {
    if (errno == EBADF)
      {
      init_network(pbs_mom_port,process_request);

      init_network(pbs_rm_port,tcp_request);
      }

    log_err(-1,msg_daemonname,"wait_request failed");
    }

  /* block signals while we do things */

  if (sigprocmask(SIG_BLOCK,&allsigs,NULL) == -1)
    log_err(errno,id,"sigprocmask(BLOCK)");

  return;
  }  /* END finish_loop() */





/*
 * mom_lock - lock out other MOMs from this directory.
 */

static void mom_lock(

  int fds,
  int op)   /* F_WRLCK or F_UNLCK */

  {
  struct flock flock;

  flock.l_type   = op;
  flock.l_whence = SEEK_SET;
  flock.l_start  = 0;
  flock.l_len    = 0;	/* whole file */

  if (fcntl(fds,F_SETLK,&flock) < 0) 
    {
    char tmpPath[256];
 
    tmpPath[0] = '\0';
 
    getcwd(tmpPath,sizeof(tmpPath));

    sprintf(log_buffer,"cannot lock '%s/mom.lock' - another mom running",
      (tmpPath[0] != '\0') ? tmpPath : "$MOM_HOME");

    log_err(errno,msg_daemonname,log_buffer);

    fprintf(stderr,"%s\n",
      log_buffer);

    exit(1);
    }

  return;
  }  /* END mom_lock() */





/*
 * size decoding routine.
 *
 *	Accepts a resource pointer and a pointer to the unsigned long integer
 *	to receive the decoded value.  It returns the decoded value in kb.
 *
 *		sizeof(word) = sizeof(int)
 */

unsigned long getsize(

  resource *pres)  /* I */

  {
  unsigned long	value;
  unsigned long	shift;

  if (pres->rs_value.at_type != ATR_TYPE_SIZE)
    {
    return(0);
    }

  value = pres->rs_value.at_val.at_size.atsv_num;
  shift = pres->rs_value.at_val.at_size.atsv_shift;

  if (pres->rs_value.at_val.at_size.atsv_units == ATR_SV_WORDSZ) 
    {
    if (value > ULONG_MAX / sizeof(int))
      {
      return(0);
      }

    value *= sizeof(int);
    }

  if (shift > 10) 
    {
    shift -= 10;

    return(value << shift);
    }

  shift = 10 - shift;

  return(value >> shift);
  }





/*
 * time decoding routine.
 *
 *	Accepts a resource pointer and a pointer to the unsigned long integer
 *	to receive the decoded value.  It returns the decoded value of time
 *	in seconds.
 */

unsigned long gettime(

  resource *pres)

  {
  if (pres->rs_value.at_type != ATR_TYPE_LONG)
    {
    return(0);
    }

  if (pres->rs_value.at_val.at_long < 0)
    {
    return(0);
    }

  return((unsigned long)pres->rs_value.at_val.at_long);
  }



/* log_buffer reports detailed failure reason */

/* return 0:  no issues detected */
/* return 1:  over limit/child termination request detected */

int job_over_limit(

  job *pjob)  /* I */

  {
  attribute	*attr;
  attribute	*used;
  resource	*limresc;
  resource	*useresc;
  struct resource_def	*rd;
  long		total;
  int		index, i;
  unsigned long	limit;
  char		*units;

  if (mom_over_limit(pjob)) 
    {		
    /* mom limits violated, log_buffer populated */

    /* no more POLL's */

    pjob->ji_nodekill = pjob->ji_nodeid;

    return(1);
    }

  if ((pjob->ji_numnodes == 1) ||		/* no other nodes */
     ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) == 0))	/* not MS */
    {
    return(0);
    }

  if (pjob->ji_nodekill != TM_ERROR_NODE) 
    {
    hnodent *pnode = &pjob->ji_hosts[pjob->ji_nodekill];

    if (pnode->hn_sister != 0)
      {
      sprintf(log_buffer,"node %d (%s) requested job die, code %d",
        pjob->ji_nodekill, 
        pnode->hn_host, 
        pnode->hn_sister);

      return(1);
      }
    }

  attr = &pjob->ji_wattr[JOB_ATR_resource];
  used = &pjob->ji_wattr[JOB_ATR_resc_used];

  for (limresc = (resource *)GET_NEXT(attr->at_val.at_list);
       limresc != NULL;
       limresc = (resource *)GET_NEXT(limresc->rs_link)) 
    {
    if ((limresc->rs_value.at_flags & ATR_VFLAG_SET) == 0)
      continue;

    rd = limresc->rs_defin;

    if (strcmp(rd->rs_name,"cput") == 0)
      index = 0;
    else if (strcmp(rd->rs_name,"mem") == 0)
      index = 1;
    else
      continue;

    useresc = find_resc_entry(used,rd);

    if (useresc == NULL)
      continue;

    if ((useresc->rs_value.at_flags & ATR_VFLAG_SET) == 0)
      continue;

    total = (index == 0) ? gettime(useresc) : getsize(useresc);

    for (i = 0;i < pjob->ji_numnodes-1;i++) 
      {
      noderes *nr = &pjob->ji_resources[i];

      total += ((index == 0) ? nr->nr_cput : nr->nr_mem);
      }

    limit = (index == 0) ? gettime(limresc) : getsize(limresc);

    if (limit <= total)
      break;
    }

  if (limresc == NULL)
    {
    /* no limit violation detected, job ok */

    return(0);
    }

  units = index == 0 ? "secs" : "kb";

  sprintf(log_buffer,"%s job total %lu %s exceeded limit %lu %s",
    rd->rs_name, 
    total, 
    units, 
    limit, 
    units);

  pjob->ji_nodekill = pjob->ji_nodeid;

  return(1);
  }  /* END job_over_limit() */




void usage(

  char *prog)  /* I */

  {
  fprintf(stderr,"Usage: %s\n",
    prog);

  fprintf(stderr,"  -a <INT>  \\\\ ALARM TIME\n");
  fprintf(stderr,"  -c <PATH> \\\\ CONFIG FILE\n");
  fprintf(stderr,"  -C <PATH> \\\\ CHECKPOINT DIR\n");
  fprintf(stderr,"  -d <PATH> \\\\ HOME DIR\n");
  fprintf(stderr,"  -C <PATH> \\\\ CHECKPOINT DIR\n");
  fprintf(stderr,"  -L <PATH> \\\\ LOGFILE\n");
  fprintf(stderr,"  -M <INT>  \\\\ MOM PORT\n");
  fprintf(stderr,"  -p        \\\\ recover jobs\n");
  fprintf(stderr,"  -r        \\\\ recover jobs (2)\n");
  fprintf(stderr,"  -R <INT>  \\\\ RM PORT\n");
  fprintf(stderr,"  -S <INT>  \\\\ SERVER PORT\n");
  fprintf(stderr,"  -x        \\\\ DO NOT USE PRIVILEGED PORTS\n");
  fprintf(stderr,"  -v        \\\\ VERSION\n");

  exit(1);
  }  /* END usage() */



int MOMInitialize(void)

  {
  MOMConfigVersion[0] = '\0';

  /* SUCCESS */

  return(0);
  }  /* END MOMInitialize() */




/*
 * main - the main program of MOM
 */

int main(

  int   argc,    /* I */
  char *argv[])  /* I */

  {
  static	char	id[] = "mom_main";

  int	 	errflg, c;
  FILE		*dummyfile;
  task		*ptask;
  char		*ptr;
  int		tryport;
  int		rppfd;			/* fd for rm and im comm */
  int		privfd = 0;			/* fd for sending job info */
  double	myla;
  struct sigaction act;
  job		*pjob;
  extern time_t	wait_time;
  extern char	*optarg;
  extern int	optind;

#if MOM_CHECKPOINT == 1
  resource	*prscput;
#endif /* MOM_CHECKPOINT */

#ifdef __PPINMEM
  int           mlockall_return;
  int           MOMISLOCKED = 0;
#endif /* __PPINMEM */

  time(&MOMStartTime);

  if (getenv("PBSMOMHOME") != NULL)
    {
    path_home = getenv("PBSMOMHOME");
    }

  /* must be started with real and effective uid of 0 */

  if ((getuid() != 0) || (geteuid() != 0)) 
    {
    fprintf(stderr, "%s: must be run as root\n", 
      argv[0]);

    return(1);
    }

  MOMInitialize();

  pbsgroup = getgid();
  loopcnt = time(NULL);

  /* Get our default service port */

  pbs_mom_port = get_svrport(PBS_MOM_SERVICE_NAME,"tcp",
    PBS_MOM_SERVICE_PORT);

  default_server_port = get_svrport(PBS_BATCH_SERVICE_NAME,"tcp",
    PBS_BATCH_SERVICE_PORT_DIS);

  pbs_rm_port = get_svrport(PBS_MANAGER_SERVICE_NAME,"tcp", 
    PBS_MANAGER_SERVICE_PORT);

  errflg = 0;

  while ((c = getopt(argc,argv,"a:c:C:d:M:S:R:L:prxv")) != -1) 
    {
    switch(c) 
      {
      case 'd':	/* directory */

        path_home = optarg;

        break;

      case 'c':	/* config file */

        config_file_specified = 1;

        strcpy(config_file,optarg);	/* remember name */

        break;

      case 'M':
 
        pbs_mom_port = (unsigned int)atoi(optarg);

        if (pbs_mom_port == 0) 
          {
          fprintf(stderr,"Bad MOM port value %s\n",
            optarg);

          exit(1);
          }

        break;

      case 'S':

        default_server_port = (unsigned int)atoi(optarg);

        if (default_server_port == 0) 
          {
          fprintf(stderr,"Bad Server port value %s\n",
            optarg);

          exit(1);
          }

        break;

      case 'R':

        pbs_rm_port = (unsigned int)atoi(optarg);

        if (pbs_rm_port == 0) 
          {
          fprintf(stderr,"Bad RM port value %s\n",
            optarg);

          exit(1);
          }

        break;

      case 'L':

        log_file = optarg;

        break;

      case 'a':

        alarm_time = (int)strtol(optarg,&ptr,10);

        if ((alarm_time <= 0) || (*ptr != '\0')) 
          {
          fprintf(stderr,"%s: bad alarm time\n", 
            optarg);

          errflg = 1;
          }

        break;

      case 'C':

#if MOM_CHECKPOINT == 1

        if (*(optarg+strlen(optarg)) == '/') 
          {
          path_checkpoint = optarg;
          }
        else 
          {
          path_checkpoint = malloc(strlen(optarg) + 2);

          strcpy(path_checkpoint,optarg);

          strcat(path_checkpoint,"/");
          }
#else

        fprintf(stderr,"Not compiled with CHECKPOINT\n");

#endif	/* MOM_CHECKPOINT */

        break;

      case 'p':

        if (recover == 0)
          recover = 2;
        else
          errflg = 1;

        break;

      case 'r':

        if (recover == 0)
          recover = 1;
        else
          errflg = 1;

        break;

      case 'x':

        port_care = FALSE;

        break;

      case 'v':

        fprintf(stderr,"version: %s\n",
          "N/A");

        break;

      case '?':
      default:

        errflg = 1;
 
        break;
      }  /* END switch(c) */
    }    /* END while ((c = getopt(argc,argv,"d:c:M:S:R:L:a:xC:pr")) != -1) */

  if ((errflg > 0) || (optind != argc))
    {
    usage(argv[0]);		/* exits */
    }

  /* The following is code to reduce security risks                */
  /* start out with standard umask, system resource limit infinite */

  umask(022);

  if (getenv("PBSLOGLEVEL") != NULL)
    {
    LOGLEVEL = (int)strtol(getenv("PBSLOGLEVEL"),NULL,0);
    }

  if (getenv("PBSDEBUG") != NULL)
    {
    DEBUGMODE = 1;
    }

  /* modify program environment */

  if ((num_var_env = setup_env(PBS_ENVIRON)) == -1)
    {
    exit(1);
    }

  c = getgid();

  setgroups(1,(gid_t *)&c);	/* secure suppl. groups */

  c = sysconf(_SC_OPEN_MAX);

  /* Close any inherited extra files, leaving stdin-err open */

  while (--c > 2)
    close(c);	/* close any file desc left open by parent */

#ifndef DEBUG
#ifdef _CRAY

  limit(C_JOB,      0,L_CPROC, 0);
  limit(C_JOB,      0,L_CPU,   0);
  limit(C_JOBPROCS, 0,L_CPU,   0);
  limit(C_PROC,     0,L_FD,  255);
  limit(C_JOB,      0,L_FSBLK, 0);
  limit(C_JOBPROCS, 0,L_FSBLK, 0);
  limit(C_JOB,      0,L_MEM  , 0);
  limit(C_JOBPROCS, 0,L_MEM  , 0);

#else /* _CRAY */

  {
  struct rlimit rlimit;

  rlimit.rlim_cur = RLIM_INFINITY;
  rlimit.rlim_max = RLIM_INFINITY;
  setrlimit(RLIMIT_CPU,   &rlimit);
  setrlimit(RLIMIT_FSIZE, &rlimit);
  setrlimit(RLIMIT_DATA,  &rlimit);
#ifdef	RLIMIT_RSS
  setrlimit(RLIMIT_RSS  , &rlimit);
#endif	/* RLIMIT_RSS */
#ifdef	RLIMIT_VMEM
  setrlimit(RLIMIT_VMEM, &rlimit);
#endif	/* RLIMIT_VMEM */
  }  /* END BLOCK */
#endif	/* else _CRAY */
#endif	/* DEBUG */

  /* set up and validate home paths */

  c = 0;

  mom_home         = mk_dirs("mom_priv");
  path_jobs        = mk_dirs("mom_priv/jobs/");
  path_epilog      = mk_dirs("mom_priv/epilogue");
  path_prolog      = mk_dirs("mom_priv/prologue");
  path_epiloguser  = mk_dirs("mom_priv/epilogue.user");
  path_prologuser  = mk_dirs("mom_priv/prologue.user");
  path_epilogp     = mk_dirs("mom_priv/epilogue.parallel");
  path_prologp     = mk_dirs("mom_priv/prologue.parallel");
  path_epiloguserp = mk_dirs("mom_priv/epilogue.user.parallel");
  path_prologuserp = mk_dirs("mom_priv/prologue.user.parallel");
  path_epilogpdel  = mk_dirs("mom_priv/epilogue.precancel");

  path_log         = mk_dirs("mom_logs");
  path_spool       = mk_dirs("spool/");
  path_undeliv     = mk_dirs("undelivered/");

#if MOM_CHECKPOINT == 1

  if (path_checkpoint == NULL)	/* if not -C option */
    path_checkpoint = mk_dirs("checkpoint/");

  /* locate cput resource definition, needed for checking chkpt time */

  rdcput = find_resc_def(svr_resc_def,"cput",svr_resc_size);

#if !defined(DEBUG) && !defined(NO_SECURITY_CHECK)

  c = chk_file_sec(path_checkpoint, 1, 0, S_IWGRP|S_IWOTH, 1);

#endif  /* not DEBUG and not NO_SECURITY_CHECK */
#endif	/* MOM_CHECKPOINT */

  /* change working directory to mom_priv */

  if (chdir(mom_home) == -1) 
    {
    char tmpLine[1024];

    sprintf(tmpLine,"cannot change directory to home '%s'",
      mom_home);

    perror(tmpLine);

    return(1);
    }

#if !defined(DEBUG) && !defined(NO_SECURITY_CHECK)

  c |= chk_file_sec(path_jobs,   1, 0, S_IWGRP|S_IWOTH, 1);
  c |= chk_file_sec(path_spool,  1, 1, S_IWOTH, 0);
  c |= chk_file_sec(PBS_ENVIRON, 0, 0, S_IWGRP|S_IWOTH, 0);

  if (c)
    {
    return(3);
    }

#endif  /* not DEBUG and not NO_SECURITY_CHECK */

  /* open log file while std in,out,err still open, forces to fd 4 */

  if ((c = log_open(log_file,path_log)) != 0) 
    {	
    /* use given name */

    fprintf(stderr,"pbs_mom: Unable to open logfile\n");
 
    return(1);
    }

  lockfds = open("mom.lock",O_CREAT|O_WRONLY,0644);

  if (lockfds < 0) 
    {
    strcpy(log_buffer,"pbs_mom: Unable to open lock file\n");
    
    return(1);
    }
 
  mom_lock(lockfds,F_WRLCK);	/* See if other MOMs are running */

  /* initialize the network interface */

  if (init_network(pbs_mom_port,process_request) != 0) 
    {
    c = errno;

    sprintf(log_buffer,"server port = %u, errno = %d",
      pbs_mom_port, 
      c);

    if (c == EADDRINUSE)
      strcat(log_buffer,", already in use");

    strcat(log_buffer,"\n");

    log_err(-1,msg_daemonname,log_buffer);

    fprintf(stderr,log_buffer);

    return(3);
    }

  if (init_network(pbs_rm_port,tcp_request) != 0) 
    {
    c = errno;

    sprintf(log_buffer,"resource (tcp) port = %u, errno = %d",
      pbs_rm_port, 
      c);

    if (c == EADDRINUSE)
      strcat(log_buffer,", already in use");

    strcat(log_buffer,"\n");

    log_err(-1,msg_daemonname,log_buffer);

    fprintf(stderr,log_buffer);

    return(3);
    }

  net_set_type(Secondary,TaskManagerDIS);

  /* go into the background and become own session/process group */

#ifndef DEBUG

  mom_lock(lockfds,F_UNLCK);	/* unlock so child can relock */

  if (DEBUGMODE == 0)
    {
    if (fork() > 0)
      {
      return (0);	/* parent goes away */
      }

    if (setsid() == -1) 
      {
      log_err(errno,msg_daemonname,"setsid failed");

      return(2);
      }

    fclose(stdin);
    fclose(stdout);
    fclose(stderr);

    dummyfile = fopen("/dev/null","r");
    assert((dummyfile != 0) && (fileno(dummyfile) == 0));

    dummyfile = fopen("/dev/null","w");
    assert((dummyfile != 0) && (fileno(dummyfile) == 1));

    dummyfile = fopen("/dev/null","w");
    assert((dummyfile != 0) && (fileno(dummyfile) == 2));
    }  /* END if (DEBUGMODE == 0) */

  mom_lock(lockfds,F_WRLCK);	/* lock out other MOMs */
	
#else	/* DEBUG */
#if	defined(_CRAY)
	
  /* CRAY cannot restart checkpointed job if MOM has controlling tty */

  sprintf(log_buffer,"/tmp/pbs_mom.%d", 
    getpid());

  printf("Debug output will be in %s\n", 
    log_buffer);

  freopen(log_buffer,"w",stdout);
  freopen(log_buffer,"w",stderr);

  ioctl(0,TCCLRCTTY,0);
  close(0);
#endif	/* _CRAY */
  setvbuf(stdout,NULL,_IOLBF,0);
  setvbuf(stderr,NULL,_IOLBF,0);
#endif /* DEBUG */

  /* write MOM's pid into lockfile */

  ftruncate(lockfds,(off_t)0);

  sprintf(log_buffer,"%ld\n",
    (long)getpid());

  write(lockfds,log_buffer,strlen(log_buffer) + 1);

#if (PLOCK_DAEMONS & 4)
  plock(PROCLOCK);	/* lock daemon into memory */
#endif
	
  sigemptyset(&allsigs);
  act.sa_mask = allsigs;
  act.sa_flags = 0;

  /*
  **	Signals to be ignored.
  */

  act.sa_handler = SIG_IGN;
  sigaction(SIGPIPE,&act,NULL);

#ifdef SIGINFO
  sigaction(SIGINFO,&act,NULL);
#endif /* SIGINFO */

  sigaddset(&allsigs,SIGHUP);	/* remember to block these */
  sigaddset(&allsigs,SIGINT);	/* during critical sections */
  sigaddset(&allsigs,SIGTERM);	/* so we don't get confused */
  sigaddset(&allsigs,SIGCHLD);
#ifdef _CRAY
  sigaddset(&allsigs,WJSIGNAL);
#endif
  act.sa_mask = allsigs;

  /*
  **	We want to abort system calls
  **	and call a function.
  */
#ifdef	SA_INTERRUPT
  act.sa_flags |= SA_INTERRUPT;	/* don't restart system calls */
#endif

  act.sa_handler = catch_child;	/* set up to catch death of child */
  sigaction(SIGCHLD,&act,NULL);

#ifdef _CRAY
  sigaction(WJSIGNAL,&act,NULL);
#endif

  /*
   * Catch these signals to ensure we core dump even if
   * our rlimit for core dumps is set to 0 initially.
   *
   * Chris Samuel - VPAC
   * csamuel@vpac.org - 29th July 2003
   *
   * Now conditional on the PBSCOREDUMP environment variable.
   */
 
  if (getenv("PBSCOREDUMP"))
    {
    act.sa_handler = catch_abort;   /* make sure we core dump */

    sigaction(SIGSEGV,&act,NULL);
    sigaction(SIGBUS,&act,NULL);
    sigaction(SIGFPE,&act,NULL);
    sigaction(SIGILL,&act,NULL);
    sigaction(SIGTRAP,&act,NULL);
    sigaction(SIGSYS,&act,NULL);
    }

  act.sa_handler = catch_hup;	/* do a restart on SIGHUP */
  sigaction(SIGHUP, &act, NULL);

  act.sa_handler = toolong;	/* handle an alarm call */
  sigaction(SIGALRM,&act,NULL);

  act.sa_handler = stop_me;	/* shutdown for these */
  sigaction(SIGINT,&act,NULL);
  sigaction(SIGTERM,&act,NULL);

  act.sa_handler  = PBSAdjustLogLevel;
  sigaction(SIGUSR1,&act,NULL);
  sigaction(SIGUSR2,&act,NULL);

#ifdef	SIGXCPU
  sigaction(SIGXCPU,&act,NULL);
#endif

#ifdef	SIGXFSZ
  sigaction(SIGXFSZ,&act,NULL);
#endif

#ifdef	SIGCPULIM
  sigaction(SIGCPULIM,&act,NULL);
#endif

#ifdef	SIGSHUTDN
  sigaction(SIGSHUTDN,&act,NULL);
#endif

#ifdef _CRAY

  /* Special code for CRAY MLS Systems */

  if (sysconf(_SC_CRAY_SECURE_SYS)) 
    {
    struct usrv usrv;

    if (getusrv(&usrv) < 0) 
      {  
      fprintf(stderr, "cannot get security info\n");

      return(1);
      }

    usrv.sv_permit = 0;
    usrv.sv_intcat = 0;
    usrv.sv_valcat = 0;

    if (setusrv(&usrv) < 0) 
      {
      fprintf(stderr,"cannot put security info\n");
        
      return(1);
      }

    if (setucat(0) < 0) 
      {
      fprintf(stderr, "cannot put security cat\n");

      return(2);
      }
    }

#endif	/* _CRAY */

  /* initialize variables */

  CLEAR_HEAD(svr_newjobs);
  CLEAR_HEAD(svr_alljobs);
  CLEAR_HEAD(mom_polljobs);
  CLEAR_HEAD(svr_requests);

  if ((c = gethostname(mom_host,PBS_MAXHOSTNAME)) == 0) 
    {
    strcpy(mom_short_name,mom_host);

    c = get_fullhostname(mom_host,mom_host,PBS_MAXHOSTNAME);

    if (c != 0)
      {
      log_err(-1,msg_daemonname,"Unable to get my full hostname");

      return(-1);
      }
    }

  if (c == -1) 
    {
    log_err(-1,msg_daemonname,"Unable to get my host name");

    return(-1);
    }

  time_now = time((time_t *)0);

  ret_size = 4096;

  if ((ret_string = malloc(ret_size)) == NULL) 
    {
    perror("malloc");

    exit(1);
    }

  if ((rppfd = rpp_bind(pbs_rm_port)) == -1) 
    {
    log_err(errno,id,"rpp_bind");

    exit(1);
    }

  rpp_fd = -1;		/* force rpp_bind() to get another socket */

  tryport = (port_care != FALSE) ? IPPORT_RESERVED : PMAX_PORT;

  while (--tryport > 0) 
    {
    if ((privfd = rpp_bind(tryport)) != -1)
      break;

    if ((errno != EADDRINUSE) && (errno != EADDRNOTAVAIL))
      break;
    }

  if (privfd == -1) 
    {
    log_err(errno, id, "no privileged ports");

    exit(1);
    }

  localaddr = addclient("localhost");

  addclient(mom_host);

  if (gethostname(ret_string,ret_size) == 0)
    addclient(ret_string);

  if (read_config(NULL)) 
    {
    fprintf(stderr,"%s: config file '%s' failed\n",
      argv[0], 
      config_file);

    exit(1);
    }

  initialize();		/* init RM code */

  add_conn(rppfd,Primary,(pbs_net_t)0,0,rpp_request);
  add_conn(privfd,Primary,(pbs_net_t)0,0,rpp_request);

  /* initialize machine dependent polling routines */

  if ((c = mom_open_poll()) != PBSE_NONE) 
    {
    log_err(c,msg_daemonname,"pre_poll failed");

    return(3);
    }
		
  /* recover & abort Jobs which were under MOM's control */

  init_abort_jobs(recover);

  /* record the fact that we are up and running */

  log_record(
    PBSEVENT_SYSTEM|PBSEVENT_FORCE, 
    PBS_EVENTCLASS_SERVER,
    msg_daemonname, 
    "Is up");

  /*
   * Now at last, we are ready to do some work, the following
   * section constitutes the "main" loop of MOM
   */

  mom_run_state = MOM_RUN_STATE_RUNNING;

  for (;mom_run_state == MOM_RUN_STATE_RUNNING;finish_loop(wait_time)) 
    {
    if (call_hup)
      {
      process_hup();
      }

    end_proc();

    time_now = time((time_t *)0);

#if IBM_SP2==2
    query_adp();
#endif	/*IBM_SP2 */

    /* check if loadave means we should be "busy" */

    if (max_load_val > 0.0) 
      {
      get_la(&myla);

      /* check if need to update busy state */

      check_busy(myla);
      }

    /* are we connected to the server? */

    if (server_stream == -1)
      {
      MOMRecvClusterAddrsCount=0;

      /* we're either just starting up, or the server has gone away.
       * Either way, let's be sure to say hello */

      if (init_server_stream() != DIS_SUCCESS)
        {
        continue;                                                                        
        }

      is_compose(server_stream,IS_HELLO);

      rpp_flush(server_stream);

      MOMSendHelloCount++;

      log_record(PBSEVENT_SYSTEM,0,id,"hello sent to server");
      }

    /* Don't do any other processing until we've re-established
     * contact with server */

    if (MOMRecvClusterAddrsCount < 1)
      continue;

    /*
     *  Update the server on the status of this mom.
     */

    if (time_now > (LastServerUpdateTime + ServerStatUpdateInterval))
      {
      check_state((LastServerUpdateTime == 0));

      if (is_update_stat(0) == DIS_SUCCESS)
         {
         LastServerUpdateTime = time_now;
         }
      }

    /* if needed, update server with my state change */
    /* can be changed in check_busy(), query_adp(), and is_update_stat() */

    if (internal_state & UPDATE_MOM_STATE)
      state_to_server(0);

    if (time_now < (polltime + CheckPollTime))
      {
      continue;
      }

    polltime = time_now;

    /* are there any jobs? */

    if ((pjob = (job *)GET_NEXT(svr_alljobs)) == NULL)
      continue;

    /* there are jobs so update status */

    if (mom_get_sample() != PBSE_NONE)
      continue;

    for (;pjob != NULL;pjob = (job *)GET_NEXT(pjob->ji_alljobs)) 
      {
      if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING)
        continue;

      /* update information for my tasks */

      mom_set_use(pjob);
      rpp_io();

      /* has all job processes vanished undetected ?       */
      /* double check by sig0 to session pid for each task */

      if (pjob->ji_flags & MOM_NO_PROC) 
        {
        pjob->ji_flags &= ~MOM_NO_PROC;

        ptask = (task *)GET_NEXT(pjob->ji_tasks);

        while (ptask != NULL) 
          {
#ifdef _CRAY
          if (pjob->ji_globid == NULL)
            break;

          c = atoi(pjob->ji_globid);

          if ((kill((pid_t)c,0) == -1) && (errno == ESRCH)) 
            {
#else	/* not cray */
          if ((kill(ptask->ti_qs.ti_sid,0) == -1) && (errno == ESRCH)) 
            {
#endif	/* not cray */

            LOG_EVENT(
              PBSEVENT_JOB, 
              PBS_EVENTCLASS_JOB, 
              id, 
              "no active process found");

            ptask->ti_qs.ti_exitstat = 0;

            ptask->ti_qs.ti_status = TI_STATE_EXITED;

            pjob->ji_qs.ji_un.ji_momt.ji_exitstat = 0;

            if (LOGLEVEL >= 6)
              {
              log_record(
                PBSEVENT_ERROR,
                PBS_EVENTCLASS_JOB,
                pjob->ji_qs.ji_jobid,
                "saving task (main loop)");
              }

            task_save(ptask);

            exiting_tasks = 1;
            }  /* END if ((kill == -1) && ...) */

          ptask = (task *)GET_NEXT(ptask->ti_jobtask);
          }    /* END while (ptask != NULL) */
        }      /* END if (pjob->ji_flags & MOM_NO_PROC) */

#if MOM_CHECKPOINT == 1

      /* see if need to checkpoint any job */

      if (pjob->ji_chkpttime == 0)
        continue;

      prscput = find_resc_entry(
        &pjob->ji_wattr[(int)JOB_ATR_resc_used],
        rdcput);

      if (pjob->ji_chkptnext>prscput->rs_value.at_val.at_long)
        continue;

      pjob->ji_chkptnext = 
        prscput->rs_value.at_val.at_long +
        pjob->ji_chkpttime;

      if ((c = start_checkpoint(pjob,0,0)) == PBSE_NONE)
        continue;

      if (c == PBSE_NOSUP)
        continue;

      /* getting here means something bad happened */

      sprintf(log_buffer,"Checkpoint failed, error %d",
        c);

      message_job(pjob,StdErr,log_buffer);

      log_record(
        PBSEVENT_JOB, 
        PBS_EVENTCLASS_JOB,
        pjob->ji_qs.ji_jobid, 
        log_buffer);
#endif	/* MOM_CHECKPOINT */
      }  /* END for (pjob) */

    /* check on over limit condition for polled jobs */

    for (pjob = (job *)GET_NEXT(mom_polljobs);pjob;
         pjob = (job *)GET_NEXT(pjob->ji_jobque)) 
      {
      if (pjob->ji_qs.ji_substate != JOB_SUBSTATE_RUNNING)
        continue;

      /*
      ** Send message to get info from other MOM's
      ** if I am Mother Superior for the job and
      ** it is not being killed.
      */

      if ((pjob->ji_qs.ji_svrflags & JOB_SVFLG_HERE) &&
          (pjob->ji_nodekill == TM_ERROR_NODE)) 
        {
        /*
        ** If can't send poll to everybody, the
        ** time has come to die.
        */

        if (send_sisters(pjob,IM_POLL_JOB) != pjob->ji_numnodes - 1)
          {
          sprintf(log_buffer,"cannot contact sisters - node %d failed\n",
            pjob->ji_nodeid);

          log_record(PBSEVENT_JOB | PBSEVENT_FORCE,
            PBS_EVENTCLASS_JOB,
            pjob->ji_qs.ji_jobid,
            log_buffer);

          pjob->ji_nodekill = pjob->ji_nodeid;
          }
        }

      c = pjob->ji_qs.ji_svrflags;

      if (c & JOB_SVFLG_OVERLMT2) 
        {
        kill_job(pjob,SIGKILL);

        continue;
        }
      else if (c & JOB_SVFLG_OVERLMT1) 
        {
        kill_job(pjob,SIGTERM);

        pjob->ji_qs.ji_svrflags |= JOB_SVFLG_OVERLMT2;

        continue;
        }

      log_buffer[0] = '\0';

      if (job_over_limit(pjob) != 0) 
        {
        log_record(PBSEVENT_JOB | PBSEVENT_FORCE,
          PBS_EVENTCLASS_JOB,
          pjob->ji_qs.ji_jobid,
          log_buffer);

        if (c & JOB_SVFLG_HERE) 
          {
          char *kill_msg;

          kill_msg = malloc(80 + strlen(log_buffer));

          sprintf(kill_msg,"=>> PBS: job killed: %s\n",
            log_buffer);

          message_job(pjob,StdErr,kill_msg);

          free(kill_msg);
          }

        kill_job(pjob,SIGTERM);

        pjob->ji_qs.ji_svrflags |= JOB_SVFLG_OVERLMT1;
        }
      }    /* END for (pjob) */

#ifdef __PPINMEM
    /* call mlockall() only 1 time, since it seems to leak mem */

    if (MOMISLOCKED == 0)
      {
      /* make sure pbs_mom stays in RAM and doesn't get paged out */

      mlockall_return = mlockall(MCL_CURRENT | MCL_FUTURE);

      if (mlockall_return == -1)
        {
        perror("pbs_mom:mom_main.c:mlockall():");

        exit(1);
        }

      MOMISLOCKED = 1;
      }
#endif /* __PPINMEM */
    }  /* END for (;mom_run_state == MOM_RUN_STATE_RUNNING;) */
 
  /* have exited main loop */

  if (mom_run_state == MOM_RUN_STATE_KILLALL) 
    {
    /* kill any running jobs */

    pjob = (job *)GET_NEXT(svr_alljobs);

    while (pjob != NULL) 
      {
      if (pjob->ji_qs.ji_substate == JOB_SUBSTATE_RUNNING) 
        {
        kill_job(pjob,SIGKILL);

        pjob->ji_qs.ji_substate = JOB_SUBSTATE_EXITING;

        job_save(pjob,SAVEJOB_QUICK);
        }
      else
        {
        term_job(pjob);
        }

      pjob = (job *)GET_NEXT(pjob->ji_alljobs);
      }  /* END while (pjob != NULL) */

    if (termin_child)
      scan_for_terminated();

    if (exiting_tasks)
      scan_for_exiting();
    }  /* END if (mom_run_state == MOM_RUN_STATE_KILLALL) */

  /* shutdown mom */

  mom_close_poll();

  rpp_shutdown();

  net_close(-1);		/* close all network connections */
 
  log_record(
    PBSEVENT_SYSTEM | PBSEVENT_FORCE, 
    PBS_EVENTCLASS_SERVER,
    msg_daemonname, 
    "Is down");

  log_close(1);

  return(0);
  }  /* END main() */




/*
 * mk_dirs - make the directory names used by MOM 
 */

static char *mk_dirs(

  char *base)  /* I */

  {
  char *pn;
  int   ltop = strlen(path_home);

  pn = malloc(ltop + strlen(base) + 2);

  if (pn == NULL)
    {
    /* cannot allocate memory */

    exit(2);
    }

  strcpy(pn,path_home);

  if (*(path_home + ltop - 1) != '/')
    strcat(pn,"/");

  strcat(pn,base);

  return(pn);
  }  /* END mk_dirs() */




/*
 * stop_me = signal handler for SIGTERM
 */

void stop_me(

  int sig)  /* I */

  {
  const char *dowhat;

  /* just exit, leaving jobs running */

  mom_run_state = MOM_RUN_STATE_EXIT;

  dowhat = "leaving jobs running, just exiting";

  sprintf(log_buffer,"caught signal %d: %s", 
    sig, 
    dowhat);

  log_record(
    PBSEVENT_SYSTEM | PBSEVENT_FORCE, 
    PBS_EVENTCLASS_SERVER,
    msg_daemonname, 
    log_buffer);

  return;
  }  /* END void stop_me() */




void PBSAdjustLogLevel(

  int sig)  /* I */

  {
  if (sig == SIGUSR1)
    {
    /* increase log level */
  
    LOGLEVEL = MIN(LOGLEVEL + 1,10);
    }
  else if (sig == SIGUSR2)
    {
    /* increase log level */

    LOGLEVEL = MAX(LOGLEVEL - 1,0);
    }

  sprintf(log_buffer,"received signal %d: adjusting loglevel to %d",
    sig,
    LOGLEVEL);

  log_record(
    PBSEVENT_SYSTEM | PBSEVENT_FORCE,
    PBS_EVENTCLASS_SERVER,
    msg_daemonname,
    log_buffer);

  return;
  }  /* END PBSAdjustLogLevel() */




/* if pjob is NULL, return empty slot, otherwise return slot containing job */

int TMOMJobGetStartInfo(

  job         *pjob, /* I */
  pjobexec_t **TJEP) /* O */

  {
  int index;

  for (index = 0;index < TMAX_JE;index++)
    {
    if (TMOMStartInfo[index].pjob == pjob)
      {
      *TJEP = &TMOMStartInfo[index];

      return(SUCCESS);
      }
    }    /* END for (index) */

  return(FAILURE);
  }  /* END TMOMJobGetStartInfo() */





int TMOMScanForStarting(void)

  {
  job *pjob;
  job *nextjob;

  int  Count;
  int  RC;
  int  SC;

  pjob = (job *)GET_NEXT(svr_alljobs);
                                                                                
  while (pjob != NULL)
    {
    nextjob = (job *)GET_NEXT(pjob->ji_alljobs);

    if (pjob->ji_qs.ji_substate == JOB_SUBSTATE_STARTING)
      {
      pjobexec_t *TJE;

      if (TMOMJobGetStartInfo(pjob,&TJE) == FAILURE)
        {
        sprintf(log_buffer,"job %s start data lost, server will retry",
          pjob->ji_qs.ji_jobid);
                                                                                
        log_record(
          PBSEVENT_ERROR,
          PBS_EVENTCLASS_JOB,
          pjob->ji_qs.ji_jobid,
          log_buffer);

        exec_bail(pjob,JOB_EXEC_RETRY);

        pjob = nextjob;

        continue;
        }

      /* check if job is ready */

      if (TMomCheckJobChild(TJE,1,&Count,&RC) == FAILURE)
        {
        long STime;

        if (LOGLEVEL >= 3)
          {
          sprintf(log_buffer,"job %s child not started, will check later",
            pjob->ji_qs.ji_jobid);
                                                                                
          log_record(
            PBSEVENT_ERROR,
            PBS_EVENTCLASS_JOB,
            pjob->ji_qs.ji_jobid,
            log_buffer);
          }

        /* if job has been in prerun > TJobStartTimeout, purge job */

        STime = pjob->ji_wattr[(int)JOB_ATR_mtime].at_val.at_long;

        if ((STime > 0) && ((time_now - STime) > TJobStartTimeout))
          {
          sprintf(log_buffer,"job %s child not started after %ld seconds, server will retry",
            pjob->ji_qs.ji_jobid,
            TJobStartTimeout);
                                                                                
          log_record(
            PBSEVENT_ERROR,
            PBS_EVENTCLASS_JOB,
            pjob->ji_qs.ji_jobid,
            log_buffer);

          memset(TJE,0,sizeof(pjobexec_t));

          exec_bail(pjob,JOB_EXEC_RETRY);
          } 
        }
      else 
        {
        /* NOTE:  TMomFinalizeJob3() populates SC */
                                                                                
        if (TMomFinalizeJob3(TJE,Count,RC,&SC) == FAILURE)
          {
          sprintf(log_buffer,"ALERT:  job failed phase 3 start, server will retry");                                                                                
          log_record(
            PBSEVENT_ERROR,
            PBS_EVENTCLASS_JOB,
            pjob->ji_qs.ji_jobid,
            log_buffer);

          memset(TJE,0,sizeof(pjobexec_t));
                                                                                
          exec_bail(pjob,SC);
          }
        else
          {
          /* job successfully started */

          memset(TJE,0,sizeof(pjobexec_t));

          if (LOGLEVEL >= 3)
            {
            sprintf(log_buffer,"job %s reported successful start",
              pjob->ji_qs.ji_jobid);

            LOG_EVENT(
              PBSEVENT_JOB,
              PBS_EVENTCLASS_JOB,
              pjob->ji_qs.ji_jobid,
              log_buffer);
            }
          }
        }    /* END else (TMomCheckJobChild() == FAILURE) */
      }      /* END if (pjob->ji_qs.ji_substate == JOB_SUBSTATE_PRERUN) */

    pjob = nextjob;
    }        /* END while (pjob != NULL) */

  return(SUCCESS);
  }  /* END TMOMScanForStarting() */

/* END mom_main.c */

